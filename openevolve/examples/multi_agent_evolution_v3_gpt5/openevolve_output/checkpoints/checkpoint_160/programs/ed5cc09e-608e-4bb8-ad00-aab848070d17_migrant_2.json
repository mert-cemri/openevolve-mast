{"id": "ed5cc09e-608e-4bb8-ad00-aab848070d17_migrant_2", "code": "# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport random\nimport time\nimport ast\nimport hashlib\nfrom typing import Tuple, Iterable, Callable\n\n# Evolution parameters (tunable)\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5\nROLE_MAX_ATTEMPTS = 3\nVERIFY_REQUIRED_STREAK = 2\nNO_PROGRESS_GRACE = 2  # rounds before terminating for lack of progress\n\n# ---------------------------\n# Actions\n# ---------------------------\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call wrapper and clear contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = LLM_MAX_RETRIES\n    base_backoff: float = LLM_BACKOFF_BASE\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _call_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries, exponential backoff and jitter. Returns string or error marker.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_UNAVAILABLE\", self.name, \"LLMInterface not configured; using deterministic fallback marker\")\n            return \"LLM_ERROR:LLM_UNAVAILABLE\"\n\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                low = resp.strip().lower()\n                if low.startswith(\"error\") or \"error communicating\" in low:\n                    last_err = resp\n                    raise RuntimeError(f\"LLM returned error-like text: {resp[:200]}\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Attempt {attempt} success len={len(resp)}\")\n                return resp\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < self.max_retries:\n                    backoff = self.base_backoff * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Giving up after {self.max_retries} attempts: {last_err}\")\n        return f\"LLM_ERROR:{last_err}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return an artifact string.\"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"Empty idea; returning deterministic fallback code\")\n            return (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback placeholder.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a compact, production-ready Python module implementing the task.\\n\"\n            \"Return only valid Python source code. Include docstrings and input validation where reasonable.\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._call_llm(messages)\n        if isinstance(code, str) and code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback code\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea[:120]}\"\"\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder implementation.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        # validate parseable Python\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, f\"Generated code not parseable: {e}\")\n            return (\n                f'\"\"\"Fallback due to parse error for: {idea[:120]}\"\"\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback after parse error.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated code len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No code provided; returning minimal test\")\n            return \"def test_placeholder():\\n    assert True\\n\"\n        # extract symbols\n        symbols = []\n        try:\n            parsed = ast.parse(code)\n            for n in parsed.body:\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n        except Exception:\n            symbols = []\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided module. \"\n            \"Include nominal and at least one edge-case. Return only pytest code.\\n\\n\"\n            f\"Public symbols (heuristic): {', '.join(symbols[:6]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{(code or '')[:3000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._call_llm(messages)\n        if isinstance(tests, str) and tests.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback tests\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_exists():\\n\"\n                f\"    # basic presence test for {target}\\n\"\n                f\"    assert True\\n\"\n            )\n        # validate tests parseable and contain assert or test_ function\n        try:\n            parsed_tests = ast.parse(tests)\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in parsed_tests.body)\n            has_assert = \"assert \" in tests or any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            if not (has_test_fn or has_assert):\n                raise ValueError(\"No tests/asserts detected\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Tests invalid: {e}\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # quick static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: manual review recommended; \" + (\"; \".join(issues) if issues else \"no static issues found\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review supplied\")\n            return review\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review and end with a single-line VERDICT: PASS or VERDICT: FAIL.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests (truncated):\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        review = await self._call_llm(messages)\n        if isinstance(review, str) and review.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM review unavailable; requesting changes\")\n            return \"REQUEST_CHANGE: Automated review unavailable; request human review.\"\n        if \"VERDICT:\" not in (review or \"\"):\n            review = (review or \"\").strip() + \"\\n\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Performing deterministic verification\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # code parse and detect defs\n        code_defs = set()\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_defs = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            code_ok = bool(parsed_code and code_defs)\n            diagnostics.append(f\"code_defs:{len(code_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n\n        # tests parse and assert presence\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests)) or (\"assert \" in (tests or \"\"))\n            tests_ok = has_test_fn or has_assert\n            diagnostics.append(\"tests_has_assert\" if has_assert else \"tests_no_assert\")\n            diagnostics.append(\"tests_has_test_fn\" if has_test_fn else \"tests_no_test_fn\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        # cross-reference\n        try:\n            if code_defs and tests_ok:\n                for name in code_defs:\n                    if name and name in (tests or \"\"):\n                        referenced = True\n                        break\n                diagnostics.append(f\"tests_reference_count:{sum(1 for n in code_defs if n in (tests or ''))}\")\n            else:\n                diagnostics.append(\"tests_reference_count:0\")\n        except Exception as e:\n            diagnostics.append(f\"reference_check_error:{str(e)[:160]}\")\n\n        verified = code_ok and tests_ok and referenced\n        status = \"PASS\" if verified else \"FAIL\"\n        # stable digest for change detection\n        try:\n            digest_src = (code or \"\").encode() + b\"||\" + (tests or \"\").encode()\n            digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n        result = f\"VERIFICATION_RESULT: {status} | digest={digest} | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n# ---------------------------\n# Roles\n# ---------------------------\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities, watch/trigger logic, and idempotency.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = kwargs.get(\"env\", None)\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        \"\"\"Decide whether to respond to a message.\"\"\"\n        if not message:\n            return False\n        if getattr(message, \"id\", None) in self._processed_ids:\n            return False\n        # explicit addressing: send_to (preferred) or sent_to\n        send_to = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n        if send_to:\n            try:\n                if isinstance(send_to, (set, list)):\n                    if self.name in send_to or self.profile in send_to or \"*\" in send_to:\n                        return True\n                elif isinstance(send_to, str):\n                    if send_to in (self.name, self.profile, \"*\"):\n                        return True\n            except Exception:\n                pass\n        # watch-trigger\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input to coders\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action with retries and return produced Message (or None).\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message id={getattr(message,'id',None)}\")\n            return None\n\n        action = self.actions[0]\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_MAX_ATTEMPTS:\n            attempts += 1\n            try:\n                # Dispatch by action type\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    code_text = getattr(message, \"content\", \"\") if message else \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        # find latest code artifact\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    # collect latest code and tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    lowered = (out or \"\").lower()\n                    if lowered.startswith(\"request_change\") or \"request_change\" in lowered or \"request_changes\" in lowered:\n                        recipients = {\"SimpleCoder\", \"SimpleTester\"}\n                    else:\n                        recipients = {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = set()  # broadcast handled by orchestrator\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark processed input to avoid reprocessing\n                if message and getattr(message, \"id\", None):\n                    self._processed_ids.add(message.id)\n\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced {getattr(response,'id',None)} cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:200]}\")\n                await asyncio.sleep(0.1 * attempts)\n        # exhausted attempts\n        fail = f\"ROLE_FAILED: {self.name} after {ROLE_MAX_ATTEMPTS} attempts - {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, fail[:200])\n        response = Message(\n            content=fail,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\n# ---------------------------\n# Environment\n# ---------------------------\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing, processed-tracking and artifact lookup.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered: role_name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure id exists for non-pydantic fallback\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        # normalize send_to\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def mark_delivered(self, role: Role, message: Message):\n        if not getattr(message, \"id\", None):\n            return\n        self._delivered.setdefault(role.name, set()).add(message.id)\n        if self.tracer:\n            self.tracer.log(\"ENV_MARK_DELIVERED\", \"Environment\", f\"{role.name} delivered {message.id}\")\n\n    def has_been_delivered(self, role: Role, message: Message) -> bool:\n        return getattr(message, \"id\", None) in self._delivered.get(role.name, set())\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to role that should be handled by it.\"\"\"\n        out: List[Message] = []\n        delivered = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if not mid or mid in delivered:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                # mark self-produced messages as delivered for this role\n                delivered.add(mid)\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            targeted = False\n            try:\n                if isinstance(send_to, (set, list)):\n                    if role.name in send_to or role.profile in send_to:\n                        targeted = True\n                elif isinstance(send_to, str):\n                    if send_to in (role.name, role.profile):\n                        targeted = True\n            except Exception:\n                targeted = False\n            if targeted:\n                out.append(msg)\n                delivered.add(mid)\n                continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n                delivered.add(mid)\n                continue\n        return out\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names.\"\"\"\n        cause_set = set(cause_names)\n        for msg in reversed(self.history):\n            if getattr(msg, \"cause_by\", None) in cause_set:\n                return msg\n        return None\n\n# ---------------------------\n# Team orchestrator\n# ---------------------------\n\nclass Team:\n    \"\"\"Orchestrates roles, termination, verification handshake, and stability checks.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self._verify_streak: int = 0\n        self._verify_required: int = VERIFY_REQUIRED_STREAK\n        self._last_digest: Optional[str] = None\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role(self, role: Role) -> int:\n        \"\"\"Process pending messages for a role and return number of produced messages.\"\"\"\n        produced = 0\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            return 0\n        for msg in msgs:\n            # Protect against role processing its own message\n            if getattr(msg, \"sent_from\", None) == role.name:\n                self.env.mark_delivered(role, msg)\n                continue\n            try:\n                resp = await role.act(msg)\n            except Exception as e:\n                self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {e}\")\n                resp = Message(content=f\"ERROR: role {role.name} crashed: {str(e)}\", role=role.profile, cause_by=\"RoleCrash\", sent_from=role.name, send_to=set())\n            # mark delivered even if resp is None so we don't retry forever\n            self.env.mark_delivered(role, msg)\n            if resp:\n                self.env.publish_message(resp)\n                produced += 1\n                # update verification streak if verifier role\n                if isinstance(role, SimpleVerifier):\n                    content = resp.content or \"\"\n                    if \"VERIFICATION_RESULT: PASS\" in content:\n                        # extract digest if present\n                        digest = None\n                        for token in content.split(\"|\"):\n                            token = token.strip()\n                            if token.startswith(\"digest=\"):\n                                digest = token.split(\"=\", 1)[1]\n                                break\n                        if digest and digest == self._last_digest:\n                            self._verify_streak += 1\n                        elif digest:\n                            self._last_digest = digest\n                            self._verify_streak = 1\n                        else:\n                            # pass without digest: treat as single pass but not stable\n                            self._last_digest = None\n                            self._verify_streak += 1\n                        self.tracer.log(\"VERIFY_UPDATE\", \"Team\", f\"streak={self._verify_streak} digest={digest}\")\n                    else:\n                        if self._verify_streak > 0:\n                            self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Resetting streak {self._verify_streak}->0\")\n                        self._verify_streak = 0\n                        self._last_digest = None\n        return produced\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; require {self._verify_required} stable verifications to stop early\")\n        # initial message to coder(s)\n        coder_targets = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_targets\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        # deterministic processing order to reduce races\n        orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(n_round):\n            round_num = round_idx + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            round_new_msgs = 0\n\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    # ensure coder sees initial on first round\n                    if isinstance(role, SimpleCoder) and round_idx == 0:\n                        # if initial not delivered to coder yet, ensure delivery\n                        if not self.env.has_been_delivered(role, initial_msg):\n                            # deliver initial message for processing\n                            self.env._delivered.setdefault(role.name, set()).discard(initial_msg.id) if False else None\n                    produced = await self._process_role(role)\n                    round_new_msgs += produced\n\n            # compute progress\n            if len(self.env.history) == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} complete produced={round_new_msgs} verify_streak={self._verify_streak}\")\n\n            # termination: require at least one full round and stable verification streak\n            if self._verify_streak >= self._verify_required and round_num >= 1:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self._verify_streak} passes; stopping\")\n                verified = True\n                break\n\n            # stop if no progress for multiple rounds\n            if no_progress_rounds >= NO_PROGRESS_GRACE:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating early\")\n                break\n\n            # if stalled but not yet terminated, nudge coder once\n            if round_new_msgs == 0:\n                for r in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                    nudge = Message(\n                        content=f\"Nudge: please refine implementation for: {self.idea}\",\n                        instruct_content=self.idea,\n                        role=\"System\",\n                        sent_from=\"Orchestrator\",\n                        cause_by=\"Nudge\",\n                        send_to={r.profile}\n                    )\n                    self.env.publish_message(nudge)\n\n            # cooperative yield\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        summary = f\"Project '{self.idea}' finished after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "ed5cc09e-608e-4bb8-ad00-aab848070d17", "generation": 3, "timestamp": 1754659078.4143724, "iteration_found": 0, "metrics": {"runs_successfully": 1.0, "overall_score": 0.5, "combined_score": 0.23076923076923073, "avg_failures_per_task": 3.3333333333333335, "total_failures": 20.0, "successful_runs": 6.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.0, "combined_score": 0.0, "avg_failures_per_task": 14.0, "error": "unterminated string literal (detected at line 163) (tmpx9xxep1j.py, line 163)"}, "island": 2, "migrant": true}, "artifacts_json": null, "artifact_dir": null}