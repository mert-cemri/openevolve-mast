{"id": "ff5e6279-86c2-4a13-bb11-33e2b41e7b55", "code": "# -*- coding: utf-8 -*-\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nimport random\nimport time\nfrom typing import Tuple, Iterable\n\n# Goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing and delivered tracking\n# - Deterministic orchestration and idempotent processing\n# - Strong verification & validation\n# - Error handling and retries for LLM/API failures\n# - Stable termination requiring consecutive verification confirmations\n\nLLM_MAX_RETRIES = 3\nLLM_BASE_BACKOFF = 0.5\nROLE_ACT_TIMEOUT = 30.0\nROLE_ACT_RETRIES = 2\nREQUIRED_STABLE_PASSES = 2\n\ndef _preview(text: Optional[str], n: int = 120) -> str:\n    if not text:\n        return \"\"\n    return text if len(text) <= n else text[:n] + \"...\"\n\ndef _normalize_send_to_field(msg: Message) -> Set[str]:\n    s = getattr(msg, \"send_to\", None)\n    if s is None:\n        try:\n            s = set(getattr(msg, \"sent_to\", set()) or set())\n        except Exception:\n            s = set()\n    # ensure set\n    return set(s or set())\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call and deterministic fallback.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = LLM_MAX_RETRIES\n    backoff: float = LLM_BASE_BACKOFF\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    fallback = \"LLM_UNAVAILABLE: deterministic fallback\"\n                    if tracer:\n                        tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and (resp.strip() == \"\" or resp.lower().startswith(\"error\")):\n                    last_err = resp\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM returned error-like response: {_preview(resp,200)}\")\n                    await asyncio.sleep(self.backoff * (2 ** (attempt - 1)) + random.random() * 0.1)\n                    continue\n                return resp\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {e}\"\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, _preview(last_err, 200))\n                await asyncio.sleep(self.backoff * (2 ** (attempt - 1)) + random.random() * 0.1)\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err or 'unknown'}\"\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_preview={_preview(idea,120)}\")\n        if not idea or not idea.strip():\n            fallback = (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback implementation.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Empty idea -> placeholder\")\n            return fallback\n\n        prompt = (\n            \"You are a professional Python developer. Return only valid Python source code that implements the task. \"\n            \"Include docstrings and basic input validation. Keep functions small and testable.\\n\\n\"\n            f\"Task:\\n{idea}\\n\"\n        )\n        messages = [{\"role\":\"system\",\"content\":\"You are an expert Python programmer.\"},\n                    {\"role\":\"user\",\"content\":prompt}]\n        code = await self.ask_with_retry(messages)\n\n        # validate parseability\n        try:\n            ast.parse(code or \"\")\n            parsed_ok = True\n        except Exception as e:\n            parsed_ok = False\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, f\"Parse error: {_preview(str(e),160)}\")\n            code = (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback: returns provided value.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)} parsed_ok={parsed_ok}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            fallback = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No code -> placeholder test\")\n            return fallback\n\n        truncated = (code or \"\")[:3000]\n        # collect top-level symbols to guide tests\n        symbols = []\n        try:\n            tree = ast.parse(code)\n            for node in tree.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)) and not node.name.startswith(\"_\"):\n                    symbols.append(node.name)\n        except Exception:\n            symbols = []\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module. Return only the test source.\\n\\n\"\n            f\"Public symbols: {', '.join(symbols[:8]) or '(none detected)'}\\n\\nModule (truncated):\\n{truncated}\\n\"\n        )\n        messages = [{\"role\":\"system\",\"content\":\"You are an expert QA engineer.\"},\n                    {\"role\":\"user\",\"content\":prompt}]\n        tests = await self.ask_with_retry(messages)\n\n        # validate tests parse and presence of asserts or test_ functions\n        valid = False\n        try:\n            parsed = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n            valid = bool(has_test_fn or has_assert)\n        except Exception:\n            valid = False\n\n        if not valid:\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, \"Generated tests invalid or insufficient; using fallback\")\n            tests = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)} valid={valid}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: Manual check recommended. REVIEW_DECISION: REQUEST_CHANGE\"\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review simulated\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise review and end with REVIEW_DECISION: APPROVE or REVIEW_DECISION: REQUEST_CHANGE.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:2000]}\\n\\nTests (truncated):\\n{(tests or '')[:2000]}\"\n        )\n        messages = [{\"role\":\"system\",\"content\":\"You are a senior software engineer.\"},\n                    {\"role\":\"user\",\"content\":prompt}]\n        review = await self.ask_with_retry(messages)\n\n        # ensure a decision token exists\n        if not isinstance(review, str) or \"REVIEW_DECISION:\" not in review:\n            # heuristic decision\n            decision = \"REQUEST_CHANGE\"\n            try:\n                ast.parse(code or \"\")\n                if (\"assert\" in (tests or \"\")) or (\"def test_\" in (tests or \"\")):\n                    decision = \"APPROVE\"\n            except Exception:\n                decision = \"REQUEST_CHANGE\"\n            review = (review or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"No explicit decision from LLM, inferred {decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        entities: Set[str] = set()\n        tests_have_asserts = False\n        cross_ref_ok = False\n\n        # code syntax and entities\n        try:\n            code_tree = ast.parse(code or \"\")\n            code_ok = True\n            for node in code_tree.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)) and not getattr(node, \"name\", \"\").startswith(\"_\"):\n                    entities.add(node.name)\n            details.append(\"code_syntax: ok\")\n            details.append(f\"code_entities: {len(entities)}\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {_preview(str(e),120)})\")\n\n        # tests syntax and asserts\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            tests_ok = True if tests and tests.strip() else False\n            tests_have_asserts = any(isinstance(n, ast.Assert) for n in ast.walk(tests_tree))\n            details.append(\"tests_syntax: ok\" if tests_ok else \"tests_syntax: empty\")\n            details.append(\"tests_asserts: ok\" if tests_have_asserts else \"tests_asserts: none\")\n            # cross reference\n            test_names = {n.id for n in ast.walk(tests_tree) if isinstance(n, ast.Name)}\n            cross_ref_ok = bool(entities and not entities.isdisjoint(test_names))\n            details.append(f\"tests_reference_count: {len(entities & test_names) if entities else 0}\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {_preview(str(e),120)})\")\n\n        passed = code_ok and tests_ok and tests_have_asserts and cross_ref_ok\n        digest_src = (code or \"\").encode(\"utf-8\") + b\"\\n--\\n\" + (tests or \"\").encode(\"utf-8\")\n        digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if passed else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with single responsibility, watch list and idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    action: Optional[Action] = None\n    watch_list: Set[str] = set()\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.action = None\n        self.watch_list = set()\n        self.env = kwargs.get(\"env\", None)\n        self._processed: Set[str] = set()\n\n    def set_action(self, action: Action):\n        self.action = action\n\n    def _watch(self, actions: Iterable[Type[Action]]):\n        self.watch_list = {getattr(a, \"name\", str(a)) for a in actions}\n\n    def should_handle(self, msg: Message) -> bool:\n        if msg is None:\n            return False\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed:\n            return False\n        send_to = _normalize_send_to_field(msg)\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.action:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No action configured\")\n            return None\n\n        if message and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message,'id',None)}\")\n            return None\n\n        msg_id = getattr(message, \"id\", None)\n        if msg_id and msg_id in self._processed:\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Already processed {msg_id}\")\n            return None\n\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Running {self.action.name} for msg={msg_id}\")\n\n        try:\n            # dispatch by action type with explicit input gathering\n            if isinstance(self.action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await self.action.run(idea or \"\")\n                send_to = {SimpleTester.profile}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteTest):\n                code_text = (message.content if message and message.cause_by == SimpleWriteCode.name else \"\") or \"\"\n                if not code_text and self.env:\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                out = await self.action.run(code_text)\n                send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteReview):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # route based on review decision\n                decision = \"REQUEST_CHANGE\" if \"REQUEST_CHANGE\" in (out or \"\").upper() else \"APPROVE\"\n                if decision == \"REQUEST_CHANGE\":\n                    send_to = {SimpleCoder.profile}\n                else:\n                    send_to = {SimpleVerifier.profile}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleVerify):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # broadcast verification result for traceability\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n            else:\n                out = await self.action.run(getattr(message, \"content\", \"\") if message else \"\")\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {type(e).__name__}: {str(e)[:200]}\"\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(content=err, role=self.profile, cause_by=\"RoleException\", sent_from=self.name, send_to={SimpleCoder.profile})\n\n        # mark processed to maintain idempotency\n        if msg_id:\n            self._processed.add(msg_id)\n        try:\n            self._processed.add(getattr(response, \"id\", \"\"))\n        except Exception:\n            pass\n\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(response,'id',None)} cause_by={response.cause_by} send_to={sorted(list(_normalize_send_to_field(response)))}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteCode(context=self.context))\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteTest(context=self.context))\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteReview(is_human=self.is_human, context=self.context))\n        self._watch([SimpleWriteTest.name])\n\nclass SimpleVerifier(Role):\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleVerify(context=self.context))\n        self._watch([SimpleWriteTest.name, SimpleWriteReview.name, SimpleWriteCode.name])\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing and delivered tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered map: role.name -> set(msg.id)\n        self._delivered: Dict[str, Set[str]] = {}\n        # index by cause_by for artifact lookup\n        self._by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role {role.name} ({role.profile}) watching {sorted(list(role.watch_list))}\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to set\n        try:\n            message.send_to = _normalize_send_to_field(message)\n        except Exception:\n            message.send_to = set()\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if getattr(message, \"cause_by\", \"\"):\n            self._by_cause.setdefault(message.cause_by, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_PUBLISH\", \"Environment\", f\"Msg {getattr(message,'id',None)} from {message.sent_from} cause_by={message.cause_by} to={sorted(list(message.send_to))} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to a role that the role should handle.\"\"\"\n        out: List[Message] = []\n        seen = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            if not getattr(msg, \"id\", None):\n                continue\n            if msg.id in seen:\n                continue\n            # avoid self messages\n            if getattr(msg, \"sent_from\", None) == role.name:\n                seen.add(msg.id)\n                continue\n            targeted = bool(msg.send_to and (role.profile in msg.send_to or role.name in msg.send_to))\n            watched = getattr(msg, \"cause_by\", None) in role.watch_list\n            if targeted or watched:\n                out.append(msg)\n                seen.add(msg.id)\n        return out\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names.\"\"\"\n        for cname in cause_names:\n            msgs = self._by_cause.get(cname, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Orchestrator with deterministic sequencing, verification stability, nudges and robust error handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self._last_digest: Optional[str] = None\n        self._streak: int = 0\n        self._required_streak: int = REQUIRED_STABLE_PASSES\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {_preview(idea,200)}\")\n\n    async def _safe_act(self, role: Role, message: Optional[Message]) -> Optional[Message]:\n        \"\"\"Call role.act with timeout and limited retries.\"\"\"\n        last_err = None\n        for attempt in range(1, ROLE_ACT_RETRIES + 2):\n            try:\n                self.tracer.log(\"ROLE_ATTEMPT\", role.name, f\"Attempt {attempt} act on msg={getattr(message,'id',None)}\")\n                resp = await asyncio.wait_for(role.act(message), timeout=ROLE_ACT_TIMEOUT)\n                if resp and getattr(resp, \"content\", None) is not None:\n                    return resp\n                last_err = \"empty_response\"\n            except asyncio.TimeoutError:\n                last_err = \"timeout\"\n                self.tracer.log(\"ROLE_TIMEOUT\", role.name, f\"Timeout on attempt {attempt}\")\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {e}\"\n                self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception attempt {attempt}: {_preview(str(e),160)}\")\n            await asyncio.sleep(0.1 * attempt)\n        # failure message\n        return Message(content=f\"ERROR: role {role.name} failed after retries: {last_err}\", role=role.profile, cause_by=\"System\", sent_from=role.name, send_to={r.profile for r in self.env.roles})\n\n    @staticmethod\n    def _extract_digest(text: str) -> Optional[str]:\n        if not isinstance(text, str):\n            return None\n        for part in text.split(\"|\"):\n            p = part.strip()\n            if p.startswith(\"digest=\"):\n                return p.split(\"=\",1)[1]\n        return None\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds with required_streak={self._required_streak}\")\n\n        # Kickoff: targeted to coder profiles\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial = Message(content=f\"Project kickoff: {self.idea}\", instruct_content=self.idea, role=\"Human\", sent_from=\"User\", cause_by=\"UserInput\", send_to=coder_profiles)\n        self.env.publish_message(initial)\n\n        verified = False\n        rounds_executed = 0\n\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(1, n_round + 1):\n            rounds_executed = round_idx\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            any_new = 0\n\n            for RoleType in order:\n                roles = [r for r in self.env.roles if isinstance(r, RoleType)]\n                for role in roles:\n                    try:\n                        incoming = self.env.get_messages_for_role(role)\n                        # ensure coders get initial on first round\n                        if isinstance(role, SimpleCoder) and round_idx == 1:\n                            if initial.id not in {m.id for m in incoming}:\n                                incoming = [initial] + incoming\n                                self.env._delivered.setdefault(role.name, set()).add(initial.id)\n                        for msg in incoming:\n                            resp = await self._safe_act(role, msg)\n                            # delivered already updated by get_messages_for_role; mark processing here for trace\n                            if resp:\n                                # enrich routing if absent\n                                if not getattr(resp, \"send_to\", None):\n                                    if isinstance(role, SimpleCoder):\n                                        resp.send_to = {SimpleTester.profile}\n                                    elif isinstance(role, SimpleTester):\n                                        resp.send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                                    elif isinstance(role, SimpleReviewer):\n                                        if isinstance(resp.content, str) and resp.content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                                            resp.send_to = {SimpleCoder.profile}\n                                            resp.cause_by = \"REQUEST_CHANGE\"\n                                        else:\n                                            resp.send_to = {SimpleVerifier.profile}\n                                    elif isinstance(role, SimpleVerifier):\n                                        resp.send_to = {r.profile for r in self.env.roles}\n                                self.env.publish_message(resp)\n                                any_new += 1\n\n                                # handle verifier result to update streak\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    if \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                        digest = self._extract_digest(resp.content)\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._streak = 1\n                                            self.tracer.log(\"VERIFIER_PASS\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                        else:\n                                            self._streak = 0\n                                            self._last_digest = None\n                                    else:\n                                        # reset on fail\n                                        self._streak = 0\n                                        self._last_digest = None\n                    except Exception as e:\n                        self.tracer.log(\"ROUND_ERROR\", \"Team\", f\"Error processing role {role.name}: {type(e).__name__}: {_preview(str(e),160)}\")\n                        continue\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} completed any_new={any_new} streak={self._streak}\")\n            if self._streak >= self._required_streak:\n                verified = True\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable for {self._required_streak} passes; stopping\")\n                break\n\n            if any_new == 0:\n                # no progress - nudge coder(s)\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No new messages this round; nudging coder(s)\")\n                for r in self.env.roles:\n                    if isinstance(r, SimpleCoder):\n                        nudge = Message(content=f\"Nudge: please refine implementation for: {self.idea}\", instruct_content=self.idea, role=\"System\", sent_from=\"Orchestrator\", cause_by=\"Nudge\", send_to={r.profile})\n                        self.env.publish_message(nudge)\n                # allow small pause for LLM backoff\n                await asyncio.sleep(0.02)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' executed rounds={rounds_executed} messages={len(self.env.history)} verified={verified} streak={self._streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "0820bbee-6517-4aba-94df-dc3f148d3dd1", "generation": 3, "timestamp": 1754657447.7607145, "iteration_found": 104, "metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes per the MAST taxonomy.\n\nFocus on:\n- Clear role definitions and responsibilities\n- Robust inter-agent communication patterns and explicit watch/trigger logic\n- Termination conditions (avoid premature termination; stop once verified)\n- Strong verification and validation steps\n- Error handling and retry on LLM/API failures\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 0.5000\n- overall_score: 0.2500\n- combined_score: 0.1000\n- avg_failures_per_task: 12.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: avg_failures_per_task. Consider continuing with similar changes.\n- Metrics showing regression: runs_successfully, overall_score, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.1667, avg_failures_per_task: 5.0000, total_failures: 30.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.2400, avg_failures_per_task: 3.1667, total_failures: 19.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.2400, avg_failures_per_task: 3.1667, total_failures: 19.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 4.2143)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2857), Performs well on avg_failures_per_task (2.5000), Performs well on total_failures (15.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 2 (Score: 4.9844)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2400), Performs well on avg_failures_per_task (3.1667), Performs well on total_failures (19.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 3 (Score: 4.9844)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry and robust error handling\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    retry_backoff: float = 0.5  # base seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"\n        Call LLM with retries and backoff. Treat known error patterns as failures to retry.\n        Returns a string with result or an explicit error message.\n        \"\"\"\n        import asyncio\n        attempt = 0\n        last_error = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # Local fallback\n                    response = \"LLM_NOT_AVAILABLE: fallback response\"\n                else:\n                    response = await self.llm.ask(messages)\n                # Treat structured error responses as failures\n                if isinstance(response, str) and response.startswith(\"Error\"):\n                    last_error = response\n                    raise RuntimeError(response)\n                # Success\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_OK\", self.name, f\"LLM responded (len={len(response)}) on attempt {attempt}\")\n                return response\n            except Exception as e:\n                last_error = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_FAIL\", self.name,\n                                            f\"Attempt {attempt} failed: {last_error}\")\n                if attempt < self.max_retries:\n                    await asyncio.sleep(self.retry_backoff * attempt)\n                else:\n                    # final give up\n                    break\n        # Final failure\n        err_msg = f\"LLM_FAILURE after {self.max_retries} attempts: {last_error}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_GIVEUP\", self.name, err_msg)\n        return err_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea with robust prompting and error handling\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:120]}\")\n\n        prompt = f\"\"\"You are a professional programmer. Write production-ready Python code for the following task.\nTask:\n{idea}\n\nRequirements:\n- Write clean, functional Python code.\n- Include error handling and docstrings.\n- Keep functions small and testable.\n- Include a short usage example in comments.\nReturn only the Python code. Do not include explanatory text.\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        code = await self._llm_call(messages)\n\n        # Basic post-processing: ensure we return a non-empty string\n        if not code or code.startswith(\"LLM_FAILURE\") or code.startswith(\"Error\"):\n            fallback = f\"# ERROR_GENERATING_CODE: {code[:200]}\\n# Please check LLM logs.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_ERROR\", self.name, f\"Falling back to placeholder code\")\n            code = fallback\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} chars\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code, with heuristics and retries\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n\n        truncated_code = (code or \"\")[:4000]\n        prompt = f\"\"\"You are a QA engineer. Write pytest-style tests for the following Python code.\n\nCode:\n{truncated_code}\n\nRequirements:\n- Provide pytest test functions covering typical cases and edge cases.\n- Use clear assertions and include docstrings for tests.\n- If code cannot be tested because it's placeholder or missing, indicate that clearly.\n\nReturn only the pytest code.\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        tests = await self._llm_call(messages)\n\n        # Heuristic validation: ensure tests contain 'assert' or 'pytest'\n        if not tests or (isinstance(tests, str) and \"assert\" not in tests and \"pytest\" not in tests and \"unittest\" not in tests):\n            note = f\"# GENERATED_TESTS_INCOMPLETE: LLM output may be insufficient. Raw: {tests[:200]}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_WARN\", self.name, \"Generated tests may be insufficient\")\n            tests = (tests or \"\") + \"\\n\\n\" + note\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} chars of tests\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests, produce actionable checklist and summary\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n\n        if self.is_human:\n            review = \"Human review: manual check recommended.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Provide a concise actionable review.\n\nCode (truncated):\n{(code or '')[:2000]}\n\nTests (truncated):\n{(tests or '')[:2000]}\n\nProvide:\n- Short summary of major issues (if any).\n- A checklist of fixes or improvements.\n- A single-line readiness verdict: READY or NOT_READY.\n\nReturn as plain text with the verdict on the last line prefixed by VERDICT:\"\"\"\n\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n\n            review = await self._llm_call(messages)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n    max_attempts: int = 3\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"\n        Perform static verification and heuristics for readiness.\n        Returns a structured verification result string.\n        \"\"\"\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n\n        code_ok = False\n        tests_ok = False\n        issues = []\n\n        # Syntax check for code\n        if code and code.strip():\n            try:\n                ast.parse(code)\n                code_ok = True\n            except Exception as e:\n                issues.append(f\"code_syntax_error: {str(e)}\")\n                code_ok = False\n        else:\n            issues.append(\"code_missing_or_empty\")\n\n        # Syntax and heuristic checks for tests\n        if tests and tests.strip():\n            try:\n                ast.parse(tests)\n                # heuristics: look for 'assert' or 'pytest' or 'unittest'\n                lower = tests.lower()\n                if \"assert\" in tests or \"pytest\" in lower or \"unittest\" in lower:\n                    tests_ok = True\n                else:\n                    issues.append(\"tests_lack_asserts_or_framework_usage\")\n                    tests_ok = False\n            except Exception as e:\n                issues.append(f\"tests_syntax_error: {str(e)}\")\n                tests_ok = False\n        else:\n            issues.append(\"tests_missing_or_empty\")\n            tests_ok = False\n\n        verified = code_ok and tests_ok\n        status = {\n            \"code_ok\": code_ok,\n            \"tests_ok\": tests_ok,\n            \"issues\": issues,\n            \"verified\": verified\n        }\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | details: {status}\"\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with explicit responsibilities, watch/trigger logic\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env = kwargs.get('env', None)\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n\n    def should_respond_to(self, message: Message) -> bool:\n        \"\"\"\n        Determine if the role should respond to the message.\n        Default: respond if message.cause_by matches any watched action name OR message is addressed to role.\n        \"\"\"\n        try:\n            if not message:\n                return False\n            # addressed to this role explicitly\n            if getattr(message, \"sent_to\", None):\n                if isinstance(message.sent_to, (list, set)) and (self.name in message.sent_to or self.profile in message.sent_to):\n                    return True\n                if isinstance(message.sent_to, str) and (message.sent_to == self.name or message.sent_to == self.profile):\n                    return True\n            # matches watched action\n            for watched in self.watch_list:\n                if message.cause_by == watched.name:\n                    return True\n            return False\n        except Exception:\n            return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform appropriate action(s) based on message and role responsibilities.\"\"\"\n        if not self.actions:\n            return None\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Act called with message cause_by={getattr(message,'cause_by',None)}\")\n\n        # Try each action (ordered) and produce a single response message per call\n        final_result = None\n        chosen_action = None\n\n        try:\n            for action in self.actions:\n                # Determine if this action should run given the message\n                run_action = False\n                # If no message, allow starter roles (like coder on first round) to run\n                if message is None:\n                    run_action = True\n                else:\n                    run_action = self.should_respond_to(message)\n\n                if not run_action:\n                    # skip this action because message not relevant\n                    continue\n\n                chosen_action = action\n\n                # Determine inputs based on action type\n                if isinstance(action, SimpleWriteCode):\n                    instruct = getattr(message, \"instruct_content\", None) if message else None\n                    # If no instruct content, try to find latest user instruction in env\n                    if not instruct and getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == \"UserInput\" or m.role.lower() == \"human\":\n                                instruct = getattr(m, \"instruct_content\", None) or m.content\n                                break\n                    result = await action.run(instruct or \"\")\n                elif isinstance(action, SimpleWriteTest):\n                    # Find the most recent code message in environment\n                    code_msg = None\n                    if message and message.cause_by == SimpleWriteCode.name and getattr(message, \"content\", None):\n                        code_msg = message\n                    elif getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_msg = m\n                                break\n                    code_text = code_msg.content if code_msg else \"\"\n                    result = await action.run(code_text)\n                elif isinstance(action, SimpleWriteReview):\n                    # Need both code and tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if not code_text and m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                            if not tests_text and m.cause_by == SimpleWriteTest.name:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    result = await action.run(code_text, tests_text)\n                elif isinstance(action, SimpleVerify):\n                    # Collect latest code/tests and run verification\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if not code_text and m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                            if not tests_text and m.cause_by == SimpleWriteTest.name:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    # Try verification possibly multiple times until stable or attempts exhausted\n                    attempt = 0\n                    verification_result = None\n                    while attempt < action.max_attempts:\n                        attempt += 1\n                        verification_result = await action.run(code_text, tests_text)\n                        if isinstance(verification_result, str) and \"VERIFICATION_RESULT: PASS\" in verification_result:\n                            result = verification_result\n                            break\n                        # If fail, try once more if there is a reviewer or tester messages to re-trigger improvements\n                        # but here we just record the latest failure\n                        result = verification_result\n                else:\n                    # Generic action\n                    result = await action.run(message) if message else await action.run()\n\n                final_result = result\n                # After a successful action run, break (roles execute one logical step per call)\n                break\n\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION in {self.name}: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, err)\n            final_result = err\n\n        # Package response as Message\n        response = Message(\n            content=final_result or \"\",\n            role=self.profile,\n            cause_by=chosen_action.name if chosen_action else \"NoAction\",\n            sent_from=self.name\n        )\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed: {response.cause_by}\")\n        return response\n\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with improved message routing\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        # Provide environment reference to role for history lookups\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        # Ensure message has id (pydantic version already has)\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\",\n                          f\"Message from {message.sent_from}: cause_by={message.cause_by} content_preview={(message.content or '')[:120]}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to using explicit watch/trigger rules.\"\"\"\n        relevant_messages: List[Message] = []\n        for msg in self.history:\n            # If message explicitly addressed to role/profile\n            if getattr(msg, \"sent_to\", None):\n                if isinstance(msg.sent_to, (list, set)) and (role.name in msg.sent_to or role.profile in msg.sent_to):\n                    relevant_messages.append(msg)\n                    continue\n                if isinstance(msg.sent_to, str) and (msg.sent_to == role.name or msg.sent_to == role.profile):\n                    relevant_messages.append(msg)\n                    continue\n            # If role watches the cause_by action\n            for watched in role.watch_list:\n                if msg.cause_by == watched.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\n\nclass Team:\n    \"\"\"Team of agents working together with improved orchestration, termination, and validation\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds with robust sequencing and termination rules\"\"\"\n        import asyncio\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n\n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        round_num = 0\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            # Step 1: Coder attempts to produce/iterate code (only on first round or if re-triggered)\n            for role in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                try:\n                    # Coder acts on initial message or explicit trigger addressed to coder\n                    msg_to_coder = initial_msg if round_num == 0 else None\n                    response = await role.act(msg_to_coder)\n                    if response:\n                        self.env.publish_message(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Coder exception: {e}\")\n\n            # Step 2: Tester responds when code available\n            for role in [r for r in self.env.roles if isinstance(r, SimpleTester)]:\n                try:\n                    relevant = self.env.get_messages_for_role(role)\n                    if relevant:\n                        response = await role.act(relevant[-1])\n                        if response:\n                            self.env.publish_message(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Tester exception: {e}\")\n\n            # Step 3: Reviewer provides review when tests are produced\n            for role in [r for r in self.env.roles if isinstance(r, SimpleReviewer)]:\n                try:\n                    relevant = self.env.get_messages_for_role(role)\n                    if relevant:\n                        response = await role.act(relevant[-1])\n                        if response:\n                            self.env.publish_message(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Reviewer exception: {e}\")\n\n            # Step 4: Verifier attempts to verify; if PASS then stop\n            verifier_messages = []\n            for role in [r for r in self.env.roles if isinstance(r, SimpleVerifier)]:\n                try:\n                    relevant = self.env.get_messages_for_role(role)\n                    if relevant:\n                        response = await role.act(relevant[-1])\n                        if response:\n                            self.env.publish_message(response)\n                            verifier_messages.append(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Verifier exception: {e}\")\n\n            # Check for verification pass by scanning verifier messages\n            for msg in reversed(self.env.history):\n                if getattr(msg, \"cause_by\", \"\") == SimpleVerify.name and isinstance(msg.content, str):\n                    if \"VERIFICATION_RESULT: PASS\" in msg.content:\n                        verified = True\n                        break\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed. Verified={verified}\")\n\n            # Termination: stop early only when verification PASS observed AND at least one full cycle has occurred\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                break\n\n            # Small wait to simulate asynchronous progression and give LLM backoff time if needed\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n\n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2400), Performs well on avg_failures_per_task (3.1667), Performs well on total_failures (19.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 4 (Score: 7.1111)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    \n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            code = await self.llm.ask(messages)\n        else:\n            code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} characters of code\")\n        \n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code[:2000]}  # Truncate if too long\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            tests = await self.llm.ask(messages)\n        else:\n            tests = f\"# Tests for the implementation\\n# [Tests would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} characters of tests\")\n        \n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        if self.is_human:\n            # Simulate human review\n            review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n            \n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            \n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review completed: {len(review)} characters\")\n        \n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n        try:\n            ast.parse(code)\n            code_ok = True\n        except Exception as e:\n            code_ok = False\n            code_err = str(e)\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n        except Exception as e:\n            tests_ok = False\n            tests_err = str(e)\n        status = []\n        if code_ok:\n            status.append(\"code_syntax: ok\")\n        else:\n            status.append(f\"code_syntax: fail ({code_err[:120]})\")\n        if tests_ok:\n            status.append(\"tests_syntax: ok\")\n        else:\n            status.append(f\"tests_syntax: fail ({(tests_err if 'tests_err' in locals() else 'empty')[:120]})\")\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        if not self.actions:\n            return None\n        \n        # Execute the first action (simplified)\n        action = self.actions[0]\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Executing action: {action.name}\")\n        \n        # Execute action based on type\n        if isinstance(action, SimpleWriteCode):\n            if message and hasattr(message, 'instruct_content'):\n                result = await action.run(message.instruct_content or message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteTest):\n            if message:\n                result = await action.run(message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteReview):\n            # For review, we need both code and tests\n            if message:\n                # Extract code and tests from previous messages (simplified)\n                result = await action.run(message.content, \"\")\n            else:\n                result = await action.run(\"\", \"\")\n        elif isinstance(action, SimpleVerify):\n            # For verification, try to find latest code and tests from history\n            env = getattr(self, 'env', None)\n            code_msg = None\n            tests_msg = None\n            if env:\n                for msg in reversed(env.history):\n                    if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                        code_msg = msg\n                    if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                        tests_msg = msg\n                    if code_msg and tests_msg:\n                        break\n            result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n        else:\n            result = \"Action completed\"\n        \n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed, message created\")\n        \n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", \n                          f\"Message from {message.sent_from}: {message.content[:100]}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            # Check if this message is from an action the role watches\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        verified = False\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Orchestrated sequence: Coder -> Tester -> Reviewer -> Verifier\n            for role in self.env.roles:\n                if isinstance(role, SimpleCoder):\n                    response = await role.act(initial_msg if round_num == 0 else None)\n                    if response:\n                        self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleTester):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleReviewer):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleVerifier):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n                            if \"VERIFICATION_RESULT: PASS\" in response.content:\n                                verified = True\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                break\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.1667), Performs well on avg_failures_per_task (5.0000), Performs well on total_failures (30.0000), Performs well on successful_runs (6.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 8.0799)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nimport time\nfrom typing import Tuple, Iterable\n\n# Evolution objectives applied:\n# - Explicit role responsibilities and simple single-action contract\n# - Reliable inter-agent routing: send_to normalized, watch_list triggers, delivered tracking\n# - Robust LLM calls with retries, backoff and deterministic fallback\n# - Strong verification with syntax, structural presence, and cross-reference heuristics\n# - Termination only after stable verification (consecutive identical digests)\n# - Error handling and limited retries for role execution\n\nDEFAULT_LLM_RETRIES = 3\nDEFAULT_LLM_BACKOFF = 0.4\nREQUIRED_STABLE_PASSES = 2  # require this many consecutive identical verification digests\n\ndef _normalize_send_to_field(msg: Message) -> Set[str]:\n    s = getattr(msg, \"send_to\", None)\n    if s is None:\n        s = set(getattr(msg, \"sent_to\", set()) or set())\n    # Ensure set type\n    return set(s or set())\n\nclass Action(ABC):\n    \"\"\"Base action with LLM-safe call and a single run(...) contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = DEFAULT_LLM_RETRIES\n    backoff: float = DEFAULT_LLM_BACKOFF\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def ask_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM robustly with retries and exponential backoff. Returns result or explicit error string.\"\"\"\n        last_err = None\n        tracer = getattr(self.context, \"tracer\", None)\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    fallback = \"LLM_UNAVAILABLE: deterministic fallback\"\n                    if tracer:\n                        tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                res = await self.llm.ask(messages)\n                if isinstance(res, str) and (res.strip() == \"\" or res.lower().startswith(\"error\")):\n                    last_err = res\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM responded with error-like text: {res[:200]}\")\n                    await asyncio.sleep(self.backoff * (2 ** (attempt - 1)))\n                    continue\n                return res\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {e}\"\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, last_err[:200])\n                await asyncio.sleep(self.backoff * (2 ** (attempt - 1)))\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err or 'unknown'}\"\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            # deterministic minimal fallback\n            fallback = (\n                \"# fallback placeholder implementation (empty idea)\\n\"\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder that echoes input.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, \"empty idea -> fallback code\")\n            return fallback\n\n        prompt = (\n            \"You are a professional Python developer. Return only Python source code implementing the task.\\n\"\n            \"Include docstrings and basic input validation. Avoid external network calls.\\n\\n\"\n            f\"Task:\\n{idea}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = await self.ask_with_retries(messages)\n\n        # Validate produced code; if invalid, replace with safe fallback\n        try:\n            if not isinstance(code, str) or not code.strip():\n                raise ValueError(\"Empty or non-string code\")\n            ast.parse(code)\n            if tracer:\n                tracer.log(\"ACTION_VALIDATE\", self.name, \"Code parsed successfully\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, f\"Generated code invalid: {e}\")\n            code = (\n                \"def placeholder(input_data=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback implementation.\\\"\\\"\\\"\\n\"\n                \"    return input_data\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, \"No code provided; returning fallback tests\")\n            return (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n\n        truncated = (code or \"\")[:3000]\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module. \"\n            \"Return only test code.\\n\\n\"\n            f\"Module (truncated):\\n{truncated}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = await self.ask_with_retries(messages)\n\n        # Validate tests: require 'assert' or def test_\n        try:\n            if not isinstance(tests, str) or tests.strip() == \"\":\n                raise ValueError(\"Empty tests\")\n            parsed = ast.parse(tests)\n            has_test = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n            if not (has_test or has_assert):\n                raise ValueError(\"No test functions or assert statements detected\")\n            if tracer:\n                tracer.log(\"ACTION_VALIDATE\", self.name, \"Tests validated\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"Tests invalid or insufficient: {e}; using fallback\")\n            tests = (\n                \"def test_placeholder_positive():\\n\"\n                \"    \\\"\\\"\\\"Basic positive fallback test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            return \"HUMAN_REVIEW: Please check edge cases. REVIEW_DECISION: APPROVE\"\n\n        prompt = (\n            \"You are a senior reviewer. Produce a concise review and end with:\\n\"\n            \"REVIEW_DECISION: APPROVE or REVIEW_DECISION: REJECT\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests (truncated):\\n{(tests or '')[:1500]}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        review = await self.ask_with_retries(messages)\n        if not isinstance(review, str) or \"REVIEW_DECISION:\" not in review:\n            # heuristic: if code has 'def' and tests mention 'test_' or 'assert' approve\n            heur_decision = \"REJECT\"\n            if (\"def \" in (code or \"\") or \"class \" in (code or \"\")) and (\"def test_\" in (tests or \"\") or \"assert\" in (tests or \"\")):\n                heur_decision = \"APPROVE\"\n            review = (review or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {heur_decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"No explicit decision; inferred {heur_decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        code_defs_ok = False\n        tests_have_funcs = False\n        cross_ref_ok = False\n\n        # Syntax checks\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            # heuristics for tests\n            tests_have_funcs = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_asserts = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            tests_ok = tests_have_funcs or has_asserts\n            details.append(\"tests_presence_and_syntax: ok\" if tests_ok else \"tests_presence_and_syntax: fail\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n\n        # Structural presence in code\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_defs_ok = any(isinstance(n, (ast.FunctionDef, ast.ClassDef)) for n in parsed_code.body)\n            details.append(\"code_has_defs: ok\" if code_defs_ok else \"code_has_defs: fail\")\n        except Exception:\n            details.append(\"code_has_defs: fail\")\n\n        # Cross-reference: do tests mention code defs?\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_names = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            parsed_tests = ast.parse(tests or \"\")\n            tests_names = {n.id for n in ast.walk(parsed_tests) if isinstance(n, ast.Name)}\n            text_overlap = any(name in (tests or \"\") for name in code_names)\n            cross_ref_ok = bool(code_names) and (not tests_names.isdisjoint(code_names) or text_overlap)\n            details.append(\"cross_reference: ok\" if cross_ref_ok else \"cross_reference: fail\")\n        except Exception:\n            details.append(\"cross_reference: fail (error)\")\n\n        verified = all([code_ok, tests_ok, code_defs_ok, cross_ref_ok])\n        digest = hashlib.sha256(((code or \"\") + \"\\n--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with single responsibility, watch/trigger logic and idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    action: Optional[Action] = None\n    watch_list: Set[str] = set()  # names of actions this role watches\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.action = None\n        self.watch_list = set()\n        self.env = kwargs.get(\"env\", None)\n        self._processed: Set[str] = set()\n\n    def set_action(self, action: Action):\n        self.action = action\n\n    def _watch(self, actions: Iterable[Type[Action]]):\n        self.watch_list = {getattr(a, \"name\", str(a)) for a in actions}\n\n    def should_handle(self, msg: Message) -> bool:\n        \"\"\"Decide whether to handle a message based on explicit addressing or watch_list triggers.\"\"\"\n        if msg is None:\n            return False\n        # avoid self-handling\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        # if already processed\n        if getattr(msg, \"id\", None) in self._processed:\n            return False\n        # explicit target\n        send_to = _normalize_send_to_field(msg)\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the assigned action for this role and return a Message (always).\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.action:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No action configured\")\n            return None\n\n        # if message present but not relevant, skip\n        if message and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message,'id',None)}\")\n            return None\n\n        # Protect against repeated processing\n        msg_id = getattr(message, \"id\", None)\n        if msg_id and msg_id in self._processed:\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Already processed {msg_id}\")\n            return None\n\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Running action {self.action.name} for msg={msg_id}\")\n\n        try:\n            # dispatch inputs explicitly based on action type\n            if isinstance(self.action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await self.action.run(idea or \"\")\n                send_to = {\"SimpleTester\"}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteTest):\n                # prefer message content (code) else latest artifact\n                code_text = getattr(message, \"content\", \"\") if message else \"\"\n                if not code_text and self.env:\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                out = await self.action.run(code_text)\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteReview):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # parse decision to route appropriately\n                decision = \"REVIEW_DECISION: APPROVE\" if \"REVIEW_DECISION: APPROVE\" in (out or \"\") else None\n                if decision:\n                    send_to = {\"SimpleVerifier\"}\n                else:\n                    # if review rejects, route back for changes\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleVerify):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # verification result is broadcast for traceability\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n            else:\n                out = await self.action.run(getattr(message, \"content\", \"\") if message else \"\")\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n        except Exception as e:\n            # contain errors: report and route to coder for recovery\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, f\"{type(e).__name__}: {str(e)[:200]}\")\n            response = Message(content=f\"ROLE_ERROR: {type(e).__name__}: {str(e)[:200]}\", role=self.profile, cause_by=\"RoleException\", sent_from=self.name, send_to={\"SimpleCoder\"})\n\n        # Mark processed for idempotency\n        if msg_id:\n            self._processed.add(msg_id)\n        # Also mark produced message id to avoid self-processing\n        try:\n            self._processed.add(getattr(response, \"id\", \"\"))\n        except Exception:\n            pass\n\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(response,'id',None)} cause_by={response.cause_by} send_to={_normalize_send_to_field(response)}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteCode(context=self.context))\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteTest(context=self.context))\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteReview(is_human=self.is_human, context=self.context))\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleVerify(context=self.context))\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing and delivered tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # per-role delivered message ids\n        self._delivered: Dict[str, Set[str]] = {}\n        # index by cause_by for artifact lookup\n        self._by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role {role.name} ({role.profile}) watching {sorted(list(role.watch_list))}\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to\n        try:\n            message.send_to = _normalize_send_to_field(message)\n        except Exception:\n            message.send_to = set()\n        # ensure id exists\n        try:\n            if not getattr(message, \"id\", None):\n                message.id = str(uuid.uuid4())\n        except Exception:\n            pass\n        self.history.append(message)\n        if getattr(message, \"cause_by\", \"\"):\n            self._by_cause.setdefault(message.cause_by, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_PUBLISH\", \"Environment\", f\"Msg {getattr(message,'id',None)} from {message.sent_from} cause_by={message.cause_by} to={sorted(list(message.send_to))} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to a role that the role should handle.\"\"\"\n        out: List[Message] = []\n        seen = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            if not getattr(msg, \"id\", None):\n                continue\n            if msg.id in seen:\n                continue\n            # avoid sending a role its own messages\n            if getattr(msg, \"sent_from\", None) == role.name:\n                seen.add(msg.id)\n                continue\n            targeted = bool(msg.send_to and (role.profile in msg.send_to or role.name in msg.send_to))\n            watched = getattr(msg, \"cause_by\", None) in role.watch_list\n            if targeted or watched:\n                out.append(msg)\n                seen.add(msg.id)\n        return out\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names.\"\"\"\n        for cname in cause_names:\n            msgs = self._by_cause.get(cname, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Orchestrator with deterministic sequencing, verification stability, nudges and robust error handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self._last_digest: Optional[str] = None\n        self._streak: int = 0\n        self._required_streak: int = REQUIRED_STABLE_PASSES\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds with stability_required={self._required_streak}\")\n\n        # Kickoff: explicit message targeted to coder(s)\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)}\n        initial_msg = Message(\n            content=f\"Project kickoff: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_profiles\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        rounds_executed = 0\n\n        # stable deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(1, n_round + 1):\n            rounds_executed = round_idx\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            new_messages = 0\n\n            for RoleType in order:\n                roles = [r for r in self.env.roles if isinstance(r, RoleType)]\n                for role in roles:\n                    try:\n                        # On first round ensure coders see initial message if not already delivered\n                        incoming = self.env.get_messages_for_role(role)\n                        if isinstance(role, SimpleCoder) and round_idx == 1 and not incoming:\n                            incoming = [initial_msg]\n                            self.env._delivered.setdefault(role.name, set()).add(initial_msg.id)\n                        for msg in incoming:\n                            # execute role; protect against role exceptions\n                            resp = None\n                            try:\n                                resp = await role.act(msg)\n                            except Exception as e:\n                                self.tracer.log(\"ROLE_ACT_EXCEPTION\", role.name, f\"Exception during act: {type(e).__name__}: {e}\")\n                                resp = Message(content=f\"ERROR: role {role.name} crashed: {e}\", role=role.profile, cause_by=\"RoleCrash\", sent_from=role.name)\n                            if resp:\n                                self.env.publish_message(resp)\n                                new_messages += 1\n                                # track verification passes if produced by verifier role\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str) and \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                    # extract digest\n                                    digest = None\n                                    for part in resp.content.split(\"|\"):\n                                        p = part.strip()\n                                        if p.startswith(\"digest=\"):\n                                            digest = p.split(\"=\", 1)[1]\n                                            break\n                                    if digest:\n                                        if digest == self._last_digest:\n                                            self._streak += 1\n                                        else:\n                                            self._last_digest = digest\n                                            self._streak = 1\n                                        self.tracer.log(\"VERIFIER_PASS\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                    else:\n                                        # no digest -> treat as non-stable\n                                        self._streak = 1\n                                        self._last_digest = None\n                                elif isinstance(role, SimpleVerifier):\n                                    # any non-pass resets streak\n                                    self._streak = 0\n                                    self._last_digest = None\n                    except Exception as e:\n                        self.tracer.log(\"ROUND_ERROR\", \"Team\", f\"Error processing role {role.name}: {type(e).__name__}: {e}\")\n                        # continue with next role\n\n            # Termination checks\n            if self._streak >= self._required_streak:\n                verified = True\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable for {self._required_streak} passes; stopping\")\n                break\n\n            if new_messages == 0:\n                # no progress this round; nudge coders but avoid infinite nudging by only doing one nudge per round\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No new messages this round; nudging coder(s)\")\n                for r in self.env.roles:\n                    if isinstance(r, SimpleCoder):\n                        nudge = Message(\n                            content=f\"Nudge: please refine or propose implementation for: {self.idea}\",\n                            instruct_content=self.idea,\n                            role=\"System\",\n                            sent_from=\"Orchestrator\",\n                            cause_by=\"Nudge\",\n                            send_to={r.profile}\n                        )\n                        self.env.publish_message(nudge)\n                        new_messages += 1\n                # allow a small pause for asynchronicity\n                await asyncio.sleep(0.01)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} completed; new_messages={new_messages} history_len={len(self.env.history)}\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' executed rounds={rounds_executed} messages={len(self.env.history)} verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D2 (Score: 3.2125)\n```python\n# -*- coding: utf-8 -*-\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport re\nimport hashlib\nimport random\n\n# Tunable reliability parameters\nLLM_RETRY_ATTEMPTS = 3\nLLM_RETRY_BACKOFF = 0.75  # seconds base backoff\nROLE_ACTION_TIMEOUT = 90  # seconds\nROLE_ACT_RETRIES = 2      # retries for role.act on transient issues\n\ndef _preview(text: Optional[str], n: int = 140) -> str:\n    if not text:\n        return \"\"\n    return text if len(text) <= n else text[:n] + \"...\"\n\nclass Action(ABC):\n    \"\"\"Base action with clear responsibility and robust LLM/API error handling with retries.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _ask_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"LLM call with retries, backoff, and logging; returns string (never raises).\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        for attempt in range(1, LLM_RETRY_ATTEMPTS + 1):\n            if tracer:\n                tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_RETRY_ATTEMPTS}\")\n            try:\n                if not self.llm:\n                    return \"LLM_UNAVAILABLE: fallback response\"\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and (resp.startswith(\"Error\") or \"Error communicating\" in resp):\n                    last_err = resp\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM returned error: {_preview(resp, 120)}\")\n                    # backoff with jitter\n                    await asyncio.sleep(LLM_RETRY_BACKOFF * attempt + random.random() * 0.2)\n                    continue\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, f\"{type(e).__name__}: {_preview(str(e), 160)}\")\n                await asyncio.sleep(LLM_RETRY_BACKOFF * attempt + random.random() * 0.2)\n        # Exhausted retries\n        fail_msg = f\"ERROR: LLM failed after {LLM_RETRY_ATTEMPTS} attempts: {_preview(str(last_err), 160)}\"\n        if tracer:\n            tracer.log(\"LLM_FAIL\", self.name, fail_msg)\n        return fail_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Execute action; return string result (may start with 'ERROR:' on failure).\"\"\"\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate a parseable Python module that implements the idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Idea={_preview(idea, 120)}\")\n        if not idea or not idea.strip():\n            # deterministic fallback\n            code = (\n                \"def placeholder():\\n\"\n                '    \"\"\"Fallback placeholder when no idea provided.\"\"\"\\n'\n                \"    return None\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No idea provided; emitting placeholder\")\n            return code\n\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module implementing the task.\\n\"\n            \"Constraints:\\n\"\n            \"- Return only valid Python source (no backticks, no prose)\\n\"\n            \"- Include docstrings and basic error handling\\n\"\n            \"- Ensure module is parseable by ast.parse\\n\\n\"\n            f\"Task: {idea}\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python developer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        code = await self._ask_llm(messages)\n\n        # Validate parseability; if failed, emit safe fallback\n        try:\n            ast.parse(code)\n            ok = True\n        except Exception as e:\n            ok = False\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"AST parse error: {_preview(str(e), 160)}\")\n            code = (\n                \"def placeholder():\\n\"\n                '    \"\"\"Fallback due to generation error.\"\"\"\\n'\n                \"    return None\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated length={len(code)} parsed_ok={ok}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for the provided code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Code length={len(code or '')}\")\n        if not code or not code.strip():\n            tests = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                '    \"\"\"Placeholder when no code available.\"\"\"\\n'\n                \"    assert True\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No code provided; emitting placeholder tests\")\n            return tests\n\n        # Collect public symbols to guide tests\n        public_symbols: List[str] = []\n        try:\n            tree = ast.parse(code)\n            for n in ast.walk(tree):\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not getattr(n, \"name\", \"\").startswith(\"_\"):\n                    public_symbols.append(n.name)\n        except Exception:\n            public_symbols = []\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the given Python module.\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest and assert statements\\n\"\n            \"- Cover typical and edge cases where reasonable\\n\"\n            \"- Include short docstrings for tests\\n\\n\"\n            f\"Public symbols: {', '.join(public_symbols[:8]) or '(none detected)'}\\n\\n\"\n            f\"Module (truncated to 2000 chars):\\n{(code or '')[:2000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer writing tests.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        tests = await self._ask_llm(messages)\n\n        # Ensure tests parse; fallback if needed\n        try:\n            ast.parse(tests or \"\")\n            ok = True\n        except Exception as e:\n            ok = False\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Tests AST parse error: {_preview(str(e), 160)}\")\n            tests = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                '    \"\"\"Fallback test when generation fails.\"\"\"\\n'\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests length={len(tests)} parsed_ok={ok}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide a concise actionable review with an explicit verdict token.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"APPROVE: Human reviewer suggests adding more edge-case tests but overall OK.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Review the code and tests concisely.\\n\"\n                \"Begin with either 'REQUEST_CHANGE:' or 'APPROVE:' and provide 3-6 bullet points.\\n\\n\"\n                f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n                f\"Tests (truncated):\\n{(tests or '')[:1500]}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior code reviewer.\"},\n                {\"role\": \"user\", \"content\": prompt},\n            ]\n            review = await self._ask_llm(messages)\n\n        # Guarantee a clear decision token\n        up = (review or \"\").upper()\n        if not (up.startswith(\"REQUEST_CHANGE\") or up.startswith(\"APPROVE\")):\n            review = \"APPROVE: Automated default approval.\\n\" + (review or \"\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Deterministic verification: syntax, structural checks, and digest for stability.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        entities: Set[str] = set()\n        has_asserts = False\n        references_ok = False\n\n        # Code syntax and entities\n        try:\n            code_tree = ast.parse(code or \"\")\n            code_ok = True\n            for node in code_tree.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n                    if not getattr(node, \"name\", \"\").startswith(\"_\"):\n                        entities.add(node.name)\n            details.append(\"code_syntax: ok\")\n            details.append(f\"code_entities: {len(entities)}\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail({type(e).__name__}: {_preview(str(e), 120)})\")\n\n        # Tests syntax and asserts\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            has_asserts = bool(re.search(r\"\\bassert\\b\", tests or \"\"))\n            details.append(\"tests_syntax: ok\" if tests_ok else \"tests_syntax: empty\")\n            details.append(\"tests_asserts: ok\" if has_asserts else \"tests_asserts: none\")\n            # references\n            test_names = {n.id for n in ast.walk(tests_tree) if isinstance(n, ast.Name)}\n            references_ok = bool(entities & test_names) if entities else False\n            details.append(f\"tests_reference_count: {len(entities & test_names) if entities else 0}\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail({type(e).__name__}: {_preview(str(e), 120)})\")\n\n        passed = code_ok and tests_ok and has_asserts and references_ok\n        digest_src = (code or \"\").encode(\"utf-8\") + b\"\\n--\\n\" + (tests or \"\").encode(\"utf-8\")\n        digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if passed else 'FAIL'} | \" + \"; \".join(details) + f\" | digest={digest}\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with single primary action, explicit watch list and safe act wrapper.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # list of action names (or explicit triggers) this role watches\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Accept action classes or names; normalize to name strings.\"\"\"\n        names: List[str] = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"name\", a.__name__))\n            else:\n                names.append(str(a))\n        self.watch_list = names\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the role's primary action. Collect required inputs and handle errors.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n        action = self.actions[0]\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Action={action.name} Trigger msg={getattr(message, 'id', None)}\")\n\n        # Collect latest artifacts as needed\n        code_text = \"\"\n        tests_text = \"\"\n        env = getattr(self, \"env\", None)\n        if env:\n            code_msg, tests_msg = env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n            code_text = code_msg.content if code_msg else \"\"\n            tests_text = tests_msg.content if tests_msg else \"\"\n\n        try:\n            if isinstance(action, SimpleWriteCode):\n                idea = (getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\")\n                result = await action.run(idea or \"\")\n            elif isinstance(action, SimpleWriteTest):\n                # Prefer code from trigger message; otherwise use latest code\n                code_src = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(code_src or code_text or \"\")\n            elif isinstance(action, SimpleWriteReview):\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            elif isinstance(action, SimpleVerify):\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            else:\n                # generic\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ROLE_ERROR\", self.name, f\"Exception: {_preview(str(e), 160)}\")\n            result = f\"ERROR: Role {self.name} failed: {type(e).__name__}: {str(e)}\"\n\n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"\"),\n            sent_from=self.name,\n        )\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message id={response.id} cause_by={response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Writes code from idea.\"\"\"\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # React to initial user input or explicit change requests\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\nclass SimpleTester(Role):\n    \"\"\"Generates tests from latest code.\"\"\"\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Reviews code and tests.\"\"\"\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass SimpleVerifier(Role):\n    \"\"\"Verifies artifacts and declares pass/fail.\"\"\"\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest.name, SimpleWriteReview.name])\n\nclass Environment:\n    \"\"\"Environment manages roles, messages, routing, and delivery tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # message.id -> set(role.name) processed\n        self._processed: Dict[str, Set[str]] = {}\n        # attempts per message (for spam guard)\n        self._attempts: Dict[str, int] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # Ensure id and initialize tracking\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        self._attempts.setdefault(message.id, 0)\n        if self.tracer:\n            self.tracer.log(\n                \"ENV_MESSAGE\",\n                \"Environment\",\n                f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} preview={_preview(message.content, 200)}\"\n            )\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"Msg {message.id} processed by {role.name}\")\n\n    def increment_attempt(self, message: Message) -> int:\n        self._attempts[message.id] = self._attempts.get(message.id, 0) + 1\n        return self._attempts[message.id]\n\n    def get_unprocessed_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages matching role.watch_list or addressed to role, and not processed by it.\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            processed = self._processed.get(msg.id, set())\n            if role.name in processed:\n                continue\n            # address-based\n            targets = getattr(msg, \"send_to\", None)\n            targeted = bool(targets and (role.name in targets or role.profile in targets))\n            # watch-based\n            watched = getattr(msg, \"cause_by\", None) in role.watch_list\n            if targeted or watched:\n                out.append(msg)\n        return out\n\n    def find_latest_pair(self, code_cause: str, tests_cause: str):\n        \"\"\"Find latest messages for code and tests causes.\"\"\"\n        code_msg = None\n        tests_msg = None\n        for msg in reversed(self.history):\n            if not code_msg and getattr(msg, \"cause_by\", \"\") == code_cause:\n                code_msg = msg\n            if not tests_msg and getattr(msg, \"cause_by\", \"\") == tests_cause:\n                tests_msg = msg\n            if code_msg and tests_msg:\n                break\n        return code_msg, tests_msg\n\n    def find_latest_content_by_cause(self, cause: str) -> Optional[str]:\n        for msg in reversed(self.history):\n            if getattr(msg, \"cause_by\", \"\") == cause:\n                return msg.content\n        return None\n\nclass Team:\n    \"\"\"Team orchestrator with deterministic pipeline, robust retries, and stable termination.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability\n        self._confirmations = 0\n        self._last_digest: Optional[str] = None\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {_preview(idea, 200)}\")\n\n    async def _safe_role_act(self, role: Role, message: Optional[Message]) -> Optional[Message]:\n        \"\"\"Call role.act with timeout and limited retries; return Message or None.\"\"\"\n        tracer = self.tracer\n        last_err = None\n        for attempt in range(1, ROLE_ACT_RETRIES + 2):\n            try:\n                if tracer:\n                    tracer.log(\"ROLE_ATTEMPT\", role.name, f\"Attempt {attempt} act on msg={getattr(message,'id',None)}\")\n                resp = await asyncio.wait_for(role.act(message), timeout=ROLE_ACTION_TIMEOUT)\n                if resp and getattr(resp, \"content\", None):\n                    return resp\n                last_err = \"empty_response\"\n            except asyncio.TimeoutError:\n                last_err = \"timeout\"\n                if tracer:\n                    tracer.log(\"ROLE_TIMEOUT\", role.name, f\"Timeout attempt {attempt}\")\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {str(e)}\"\n                if tracer:\n                    tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception attempt {attempt}: {_preview(str(e), 160)}\")\n            await asyncio.sleep(0.2 * attempt)\n        # create error message to record failure\n        return Message(\n            content=f\"ERROR: role {role.name} failed after retries: {last_err}\",\n            role=role.profile,\n            cause_by=\"System\",\n            sent_from=role.name\n        )\n\n    @staticmethod\n    def _extract_digest(text: str) -> Optional[str]:\n        if not isinstance(text, str):\n            return None\n        m = re.search(r\"digest=([0-9a-fA-F]{8,64})\", text)\n        return m.group(1) if m else None\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run collaboration for up to n_rounds with explicit stages and stable termination.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n\n        # Kickoff message targeted to coder(s)\n        coder_targets = {r.name for r in self.env.roles if isinstance(r, SimpleCoder)} or {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)}\n        initial_msg = Message(\n            content=f\"Project kickoff: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_targets\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        history_len_prev = len(self.env.history)\n\n        for round_idx in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            progress = False\n\n            # Stage 1: Coder (respond first round or on explicit request_change)\n            for role in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                inbox = []\n                if round_idx == 1:\n                    inbox = [initial_msg]\n                else:\n                    # respond to REQUEST_CHANGE messages (cause_by=\"REQUEST_CHANGE\")\n                    inbox = [m for m in self.env.get_unprocessed_messages_for_role(role) if getattr(m, \"cause_by\", \"\") in role.watch_list]\n                for msg in inbox:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        # direct next to Testers\n                        resp.cause_by = SimpleWriteCode.name\n                        resp.send_to = {SimpleTester.profile}\n                        self.env.publish_message(resp)\n                        progress = True\n\n            # Stage 2: Tester\n            for role in [r for r in self.env.roles if isinstance(r, SimpleTester)]:\n                msgs = self.env.get_unprocessed_messages_for_role(role)\n                for msg in msgs:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        resp.cause_by = SimpleWriteTest.name\n                        # route to reviewer and verifier\n                        resp.send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                        self.env.publish_message(resp)\n                        progress = True\n\n            # Stage 3: Reviewer\n            for role in [r for r in self.env.roles if isinstance(r, SimpleReviewer)]:\n                msgs = self.env.get_unprocessed_messages_for_role(role)\n                for msg in msgs:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        # If requests change, notify coder; else notify verifier\n                        content = resp.content or \"\"\n                        if isinstance(content, str) and content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                            resp.cause_by = \"REQUEST_CHANGE\"\n                            resp.send_to = {SimpleCoder.profile}\n                        else:\n                            resp.cause_by = SimpleWriteReview.name\n                            resp.send_to = {SimpleVerifier.profile}\n                        self.env.publish_message(resp)\n                        progress = True\n\n            # Stage 4: Verifier\n            for role in [r for r in self.env.roles if isinstance(r, SimpleVerifier)]:\n                msgs = self.env.get_unprocessed_messages_for_role(role)\n                for msg in msgs:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        resp.cause_by = SimpleVerify.name\n                        resp.send_to = {r.profile for r in self.env.roles}  # broadcast\n                        self.env.publish_message(resp)\n                        progress = True\n\n                        # Evaluate verification result\n                        if isinstance(resp.content, str) and \"VERIFICATION_RESULT: PASS\" in resp.content:\n                            digest = self._extract_digest(resp.content)\n                            # Confirm by re-running verification directly for stability\n                            try:\n                                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                                verifier_action = role.actions[0] if role.actions else None\n                                if verifier_action:\n                                    confirm = await verifier_action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n                                    if isinstance(confirm, str) and \"VERIFICATION_RESULT: PASS\" in confirm:\n                                        confirm_digest = self._extract_digest(confirm)\n                                        if digest and confirm_digest and digest == confirm_digest:\n                                            self._confirmations += 1\n                                            self._last_digest = digest\n                                            self.tracer.log(\"VERIFY_CONFIRM\", \"Team\", f\"Confirmed PASS digest={digest} confirmations={self._confirmations}\")\n                            except Exception as e:\n                                self.tracer.log(\"VERIFY_EXCEPTION\", \"Team\", f\"Confirmation error: {_preview(str(e), 160)}\")\n\n            # Termination logic:\n            # Stop when at least one confirmation achieved and no progress since then\n            history_len_now = len(self.env.history)\n            if history_len_now == history_len_prev:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            history_len_prev = history_len_now\n\n            if self._confirmations >= 1 and no_progress_rounds >= 1:\n                verified = True\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verified and stable; stopping after round {round_idx}\")\n                break\n\n            # Hang detection\n            if not progress:\n                self.tracer.log(\"ROUND_IDLE\", \"Team\", \"No progress detected this round\")\n            if no_progress_rounds >= 2:\n                self.tracer.log(\"TEAM_HANG_DETECT\", \"Team\", \"No progress for 2 rounds; stopping to avoid livelock\")\n                break\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} complete; progress={progress}\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", f\"Project complete; Verified={verified} Confirmations={self._confirmations}\")\n\n        summary = f\"Project '{self.idea}' completed after {round_idx} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D3 (Score: 3.2125)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport random\nimport time\nimport re\nfrom typing import Tuple, Any\n\n# Shared constants for robustness\nLLM_RETRIES = 3\nLLM_BASE_BACKOFF = 0.5\nROLE_RETRY_LIMIT = 2\nNO_PROGRESS_LIMIT = 2\nVERIFICATION_CONFIRMATIONS_REQUIRED = 2\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call, logging and deterministic fallbacks.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            try:\n                self.llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                self.llm = None\n\n    async def _call_llm(self, messages: List[Dict[str, str]], retries: int = LLM_RETRIES) -> str:\n        \"\"\"Call LLM with retries, exponential backoff and jitter. Return explicit error on failure.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        for attempt in range(1, retries + 1):\n            if tracer:\n                tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{retries}\")\n            try:\n                if not self.llm:\n                    # deterministic fallback\n                    resp = \"LLM_UNAVAILABLE: fallback\"\n                else:\n                    resp = await self.llm.ask(messages)\n                # detect explicit error responses from LLMInterface\n                if isinstance(resp, str) and (resp.strip() == \"\" or resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower()):\n                    last_err = resp\n                    raise RuntimeError(f\"LLM signaled error: {resp}\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Attempt {attempt} success (len={len(resp)})\")\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                # backoff with jitter\n                backoff = LLM_BASE_BACKOFF * (2 ** (attempt - 1))\n                await asyncio.sleep(backoff + random.random() * 0.1)\n        err = f\"LLM_ERROR: Failed after {retries} attempts: {last_err}\"\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, err)\n        return err\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> Any:\n        \"\"\"Perform the action and return a result (string or structured).\"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No idea provided\")\n            return \"# No idea provided. Nothing generated.\"\n\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module implementing the described functionality.\\n\"\n            \"Requirements:\\n\"\n            \"- Valid Python source (parseable by ast.parse)\\n\"\n            \"- Clear docstrings and input validation where appropriate\\n\"\n            \"- Return only the Python source\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python developer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = await self._call_llm(messages)\n        # Validate parseability; if LLM failed or returned invalid code, provide deterministic fallback\n        try:\n            ast.parse(code)\n            parsed = True\n        except Exception:\n            parsed = False\n        if not parsed:\n            fallback = (\n                '\"\"\"Fallback implementation generated due to LLM failure.\"\"\"\\n\\n'\n                \"def placeholder(x):\\n\"\n                '    \"\"\"Placeholder function returning input or raising on None.\"\"\"\\n'\n                \"    if x is None:\\n\"\n                \"        raise ValueError('input cannot be None')\\n\"\n                \"    return x\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using deterministic fallback implementation\")\n            code = fallback\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(code)} parsed={parsed}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No code provided\")\n            return \"# No code provided; tests not generated.\"\n\n        # Extract public symbols heuristically\n        symbols = []\n        try:\n            tree = ast.parse(code)\n            for node in ast.walk(tree):\n                if isinstance(node, ast.FunctionDef) and not node.name.startswith(\"_\"):\n                    symbols.append(node.name)\n                if isinstance(node, ast.ClassDef) and not node.name.startswith(\"_\"):\n                    symbols.append(node.name)\n        except Exception:\n            symbols = []\n\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided module.\\n\"\n            f\"Public symbols: {', '.join(symbols[:10]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n- Use pytest\\n- Include asserts and edge cases\\n- Return only test code\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = await self._call_llm(messages)\n\n        # Validate tests; ensure parseable and contains asserts or test_ functions\n        valid = False\n        try:\n            parsed = ast.parse(tests)\n            if (\"assert \" in tests) or (\"def test_\" in tests):\n                valid = True\n        except Exception:\n            valid = False\n\n        if not valid:\n            fallback = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback tests due to invalid LLM output\")\n            tests = fallback\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests len={len(tests)} valid={valid}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Reviewing (human={self.is_human})\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: manual inspection recommended.\"\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review simulated\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise review and an explicit verdict line at the end: VERDICT: PASS or VERDICT: FAIL\\n\\n\"\n            f\"Code:\\n{(code or '')[:1500]}\\n\\nTests:\\n{(tests or '')[:1500]}\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        review = await self._call_llm(messages)\n        # Ensure verdict exists; if missing, add heuristic verdict\n        if isinstance(review, str):\n            if \"VERDICT:\" not in review:\n                # heuristic: if tests contain assert and code parseable, mark PASS\n                try:\n                    ast.parse(code or \"\")\n                    code_ok = True\n                except Exception:\n                    code_ok = False\n                has_assert = (\"assert \" in (tests or \"\")) or (\"def test_\" in (tests or \"\"))\n                verdict = \"PASS\" if code_ok and has_assert else \"FAIL\"\n                review = review.strip() + f\"\\n\\nVERDICT: {verdict}\"\n        else:\n            review = \"REVIEW_ERROR: invalid review generated\\n\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> Tuple[str, Dict[str, Any]]:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n        has_assert = False\n\n        # Code parse\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_ok = True\n            diagnostics.append(\"code_syntax: ok\")\n            code_symbols = {n.name for n in ast.walk(parsed_code) if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n        except Exception as e:\n            diagnostics.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:120]})\")\n            code_symbols = set()\n\n        # Tests parse and heuristics\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            tests_ok = True\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests)) or (\"def test_\" in (tests or \"\"))\n            diagnostics.append(\"tests_syntax: ok\" if tests_ok else \"tests_syntax: fail\")\n            diagnostics.append(\"tests_asserts: ok\" if has_assert else \"tests_asserts: none\")\n        except Exception as e:\n            diagnostics.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:120]})\")\n            parsed_tests = None\n\n        # Cross-reference: do tests reference code symbols?\n        if parsed_tests and code_symbols:\n            test_names = {n.id for n in ast.walk(parsed_tests) if isinstance(n, ast.Name)}\n            common = code_symbols & test_names\n            referenced = bool(common)\n            diagnostics.append(f\"tests_reference_count: {len(common)}\")\n        else:\n            diagnostics.append(\"tests_reference_count: 0\")\n\n        verified = bool(code_ok and tests_ok and has_assert and referenced)\n        result = \"VERIFICATION_RESULT: \" + (\"PASS\" if verified else \"FAIL\") + \" | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result, {\"verified\": verified}\n\n\nclass Role(ABC):\n    \"\"\"Clear roles with responsibilities, watch logic and idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # action names that trigger this role\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = kwargs.get('env')\n        self._processed: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, msg: Message) -> bool:\n        \"\"\"Decide whether to respond to a message.\"\"\"\n        if msg is None:\n            return False\n        if getattr(msg, \"id\", None) in self._processed:\n            return False\n        # explicit addressing\n        send_to = getattr(msg, \"send_to\", None)\n        if send_to:\n            if isinstance(send_to, (set, list)) and (self.name in send_to or self.profile in send_to or \"*\" in send_to):\n                return True\n        # cause_by watchlist\n        if getattr(msg, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input -> coder\n        if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action with limited retries and error handling.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No action configured\")\n            return None\n\n        action = self.actions[0]\n        # check interest\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message,'id',None)}\")\n            return None\n\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_RETRY_LIMIT:\n            attempts += 1\n            try:\n                # Map action to its inputs\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    # prefer message content else find latest code in env\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    # gather latest code/tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    # route reviewer: if requests change, send to coder\n                    up = str(out or \"\").strip().upper()\n                    if up.startswith(\"REQUEST_CHANGE\"):\n                        recipients = {\"SimpleCoder\"}\n                    else:\n                        recipients = {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    # get latest pair\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    result, meta = await action.run(code_text, tests_text)\n                    out = result\n                    recipients = set()  # broadcast if needed by env\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark processed\n                if message and getattr(message, \"id\", None):\n                    self._processed.add(message.id)\n\n                resp = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=set(recipients)\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced {action.name} send_to={recipients}\")\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:200]}\")\n                # small backoff before retry\n                time.sleep(0.05 * attempts)\n        # exhausted retries\n        err_msg = f\"ROLE_FAILED: {self.name} after {ROLE_RETRY_LIMIT} attempts: {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, err_msg)\n        return Message(content=err_msg, role=self.profile, cause_by=\"RoleFailure\", sent_from=self.name, send_to={\"Team\"})\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch([ ])  # triggered by UserInput/send_to\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch([SimpleWriteTest, SimpleWriteReview])\n\n\nclass Environment:\n    \"\"\"Environment handles message publication, routing and processed state.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure id\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages a role should consider (explicit send_to > watch_list), excluding already processed by that role.\"\"\"\n        relevant: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) in getattr(role, \"_processed\", set()):\n                continue\n            # explicit addressing\n            send_to = getattr(msg, \"send_to\", None)\n            if send_to:\n                if (isinstance(send_to, (set, list)) and (role.name in send_to or role.profile in send_to or \"*\" in send_to)) or (isinstance(send_to, str) and (send_to == role.name or send_to == role.profile)):\n                    relevant.append(msg)\n                    continue\n            # watch_list matching\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n                continue\n        return relevant\n\n\nclass Team:\n    \"\"\"Team orchestrates roles, sequencing, termination and verification confirmations.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self._confirm_count = 0\n        self._confirm_rounds: Set[int] = set()\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; require {VERIFICATION_CONFIRMATIONS_REQUIRED} confirmations\")\n\n        # Initial instruction explicitly targeted to coders\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        for round_idx in range(n_round):\n            round_num = round_idx + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            progress_made = False\n\n            # deterministic orchestration order to reduce races\n            orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    # allow coder to see initial message on first round if not explicitly routed\n                    inbox = self.env.get_messages_for_role(role)\n                    if isinstance(role, SimpleCoder) and round_idx == 0:\n                        # ensure initial message reaches coder\n                        if initial_msg not in inbox:\n                            inbox = [initial_msg] + inbox\n                    for msg in inbox:\n                        try:\n                            resp = await role.act(msg)\n                            # mark processed even if action returns None to avoid reattempt loops\n                            role._processed.add(getattr(msg, \"id\", \"\"))\n                            if resp:\n                                self.env.publish_message(resp)\n                                progress_made = True\n                                # handle verifier confirmations\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    if \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                        self._confirm_count += 1\n                                        self._confirm_rounds.add(round_idx)\n                                        self.tracer.log(\"VERIFY_CONFIRM\", \"Team\", f\"Verifier {role.name} PASS ({self._confirm_count}/{VERIFICATION_CONFIRMATIONS_REQUIRED})\")\n                                        if self._confirm_count >= VERIFICATION_CONFIRMATIONS_REQUIRED:\n                                            verified = True\n                                    elif \"VERIFICATION_RESULT: FAIL\" in resp.content:\n                                        self._confirm_count = 0\n                                        self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Verifier {role.name} reported FAIL; confirmations reset\")\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during role.act: {e}\")\n\n            # progress/no-progress detection\n            if len(self.env.history) == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} completed (progress={progress_made})\")\n\n            # termination: require confirmations and at least one round after confirmations to ensure stability\n            if verified and round_num >= 1:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification confirmed; stopping after {self._confirm_count} confirmations\")\n                break\n\n            if no_progress_rounds >= NO_PROGRESS_LIMIT:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating early\")\n                break\n\n            # small cooperative yielding\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        summary = f\"Project '{self.idea}' finished after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D4 (Score: 9.5833)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"LLM_FALLBACK: deterministic response\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nfrom typing import Tuple\n\ndef _preview(text: Optional[str], n: int = 120) -> str:\n    if not text:\n        return \"\"\n    return text[:n] + (\"...\" if len(text) > n else \"\")\n\nclass Action(ABC):\n    \"\"\"Base Action with robust LLM calls and clear responsibilities.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    backoff_base: float = 0.25\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def safe_ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries, exponential backoff, and logging. Return a stable fallback on failure.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            fallback = \"LLM_UNAVAILABLE_FALLBACK\"\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n            return fallback\n\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and (resp.startswith(\"Error\") or resp.startswith(\"Error communicating\")):\n                    last_err = resp\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM error response: {resp[:200]}\")\n                    await asyncio.sleep(self.backoff_base * (2 ** (attempt - 1)))\n                    continue\n                return resp\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {str(e)}\"\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, last_err[:200])\n                await asyncio.sleep(self.backoff_base * (2 ** (attempt - 1)))\n        failure = f\"LLM_CALL_FAILED after {self.max_retries} attempts: {last_err}\"\n        if tracer:\n            tracer.log(\"LLM_ABORT\", self.name, failure)\n        return failure\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        raise NotImplementedError()\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produces Python code implementing the given idea, with fallback and syntax validation.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea={_preview(idea,200)}\")\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module that implements the requested functionality.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Constraints:\\n\"\n            \"- Return only valid Python source code (no markdown or backticks).\\n\"\n            \"- Include docstrings, basic input validation, and error handling.\\n\"\n            \"- Ensure at least one function or class is defined.\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = await self.safe_ask(messages)\n        # Validate and fallback if necessary\n        parsed_ok = False\n        try:\n            ast.parse(code or \"\")\n            parsed_ok = True\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"Generated code failed to parse: {e}\")\n        if not parsed_ok:\n            # Deterministic fallback minimal module\n            code = (\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder implementation.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback placeholder code\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"produced_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generates pytest tests for the provided module, with basic heuristics and fallback.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        truncated = (code or \"\")[:3000]\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided Python module.\\n\\n\"\n            f\"Module (truncated):\\n{truncated}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Provide pytest-compatible tests only.\\n\"\n            \"- Cover typical cases and at least one edge case.\\n\"\n            \"- Include docstrings and clear asserts.\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = await self.safe_ask(messages)\n        # Heuristic validation\n        if not tests or (\"assert\" not in tests and \"pytest\" not in tests and \"unittest\" not in tests):\n            fallback = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            tests = fallback\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback tests\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Reviews code and tests and provides an explicit decision line (APPROVE/REQUEST_CHANGE).\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: APPROVE\\nREVIEW_DECISION: APPROVE\"\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review provided\")\n            return review\n        prompt = (\n            \"You are a senior code reviewer. Provide a concise review and end with a decisive line:\\n\"\n            \"REVIEW_DECISION: APPROVE or REVIEW_DECISION: REQUEST_CHANGE\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:2000]}\\n\\nTests (truncated):\\n{(tests or '')[:2000]}\\n\\n\"\n            \"Focus on correctness, missing tests, and actionable improvements. Keep concise.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        review = await self.safe_ask(messages)\n        if not review or \"REVIEW_DECISION:\" not in review:\n            # Heuristic decision\n            decision = \"APPROVE\" if (\"assert\" in (tests or \"\")) and ((\"def \" in (code or \"\")) or (\"class \" in (code or \"\"))) else \"REQUEST_CHANGE\"\n            review = (review or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"No explicit decision from LLM, inferred {decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Performs deterministic verification of code/tests and returns standardized result with digest.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        code_entities: Set[str] = set()\n\n        # Syntax checks\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:120]})\")\n            parsed_code = None\n\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            tests_ok = True\n            details.append(\"tests_syntax: ok\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:120]})\")\n            parsed_tests = None\n\n        # Semantic checks\n        if parsed_code:\n            for node in parsed_code.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n                    code_entities.add(node.name)\n            details.append(f\"code_entities: {len(code_entities)}\")\n\n        tests_has_assert = False\n        tests_references = set()\n        if parsed_tests:\n            for node in ast.walk(parsed_tests):\n                if isinstance(node, ast.Assert):\n                    tests_has_assert = True\n                if isinstance(node, ast.Name):\n                    tests_references.add(node.id)\n            details.append(f\"tests_asserts: {tests_has_assert}\")\n            inter = code_entities & tests_references\n            details.append(f\"tests_refs_code: {len(inter)}\")\n\n        # Decide PASS/FAIL\n        passed = all([code_ok, tests_ok, bool(code_entities), tests_has_assert, len(code_entities & tests_references) > 0])\n        # Stable digest for verification uniqueness\n        digest_src = (code or \"\").encode(\"utf-8\") + b\"\\n--\\n\" + (tests or \"\").encode(\"utf-8\")\n        digest = hashlib.sha256(digest_src).hexdigest()[:12]\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if passed else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base Role: single responsibility, explicit watch list, idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    action: Optional[Action] = None\n    watch_list: List[str] = []  # list of action names or triggers\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.action = None\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        self._processed: Set[str] = set()\n\n    def set_action(self, action: Action):\n        self.action = action\n\n    def _watch(self, actions: List[Type[Action]]):\n        # Normalize to action.name strings\n        names = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            else:\n                names.append(str(a))\n        self.watch_list = names\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action if message matches watch rules. Ensures idempotency and safe error handling.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.action:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No action configured\")\n            return None\n\n        # Evaluate if this role should act on this message\n        msg_id = getattr(message, \"id\", None)\n        # Skip if already processed this message\n        if msg_id and msg_id in self._processed:\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Already processed message {msg_id}\")\n            return None\n\n        # If message exists and not targeted to this role and not in watch_list, skip\n        if message:\n            send_to = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n            targeted = False\n            if send_to:\n                try:\n                    if isinstance(send_to, (set, list)):\n                        targeted = (self.name in send_to or self.profile in send_to)\n                    else:\n                        targeted = (send_to == self.name or send_to == self.profile)\n                except Exception:\n                    targeted = False\n            watches = getattr(message, \"cause_by\", None) in self.watch_list\n            # If neither targeted nor watched, skip (unless watch_list empty -> proactive)\n            if not targeted and not watches and self.watch_list:\n                if tracer:\n                    tracer.log(\"ROLE_SKIP\", self.name, f\"Not a target/watched message cause_by={getattr(message,'cause_by',None)}\")\n                return None\n\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Executing {self.action.name} for message {msg_id} preview={_preview(getattr(message,'content',None) or '',120)}\")\n\n        try:\n            # Determine inputs for action type\n            if isinstance(self.action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                result = await self.action.run(idea)\n            elif isinstance(self.action, SimpleWriteTest):\n                # Prefer code from message, else fetch latest code in env\n                code = getattr(message, \"content\", \"\") if message and message.cause_by == SimpleWriteCode.name else \"\"\n                if not code and self.env:\n                    code = self.env.find_latest_by_cause(SimpleWriteCode.name) or \"\"\n                result = await self.action.run(code)\n            elif isinstance(self.action, SimpleWriteReview):\n                # Collect latest code and tests\n                code = self.env.find_latest_by_cause(SimpleWriteCode.name) or \"\"\n                tests = self.env.find_latest_by_cause(SimpleWriteTest.name) or \"\"\n                result = await self.action.run(code, tests)\n            elif isinstance(self.action, SimpleVerify):\n                code = self.env.find_latest_by_cause(SimpleWriteCode.name) or \"\"\n                tests = self.env.find_latest_by_cause(SimpleWriteTest.name) or \"\"\n                result = await self.action.run(code, tests)\n            else:\n                result = await self.action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            err = f\"ROLE_ACTION_ERROR: {type(e).__name__}: {str(e)}\"\n            if tracer:\n                tracer.log(\"ROLE_ERROR\", self.name, err[:200])\n            # Mark processed to avoid retry storms\n            if msg_id:\n                self._processed.add(msg_id)\n            return Message(content=err, role=self.profile, cause_by=\"Error\", sent_from=self.name)\n\n        # Build outgoing message\n        out_msg = Message(\n            content=result,\n            role=self.profile,\n            cause_by=self.action.name if self.action else \"\",\n            sent_from=self.name\n        )\n        # Mark processed\n        if msg_id:\n            self._processed.add(msg_id)\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message id={getattr(out_msg,'id',None)} cause_by={out_msg.cause_by}\")\n        return out_msg\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteCode(context=self.context))\n        # Coder is triggered by user input or explicit 'REQUEST_CHANGE'\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteTest(context=self.context))\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteReview(is_human=self.is_human, context=self.context))\n        self._watch([SimpleWriteTest.name])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleVerify(context=self.context))\n        self._watch([SimpleWriteTest.name, SimpleWriteReview.name])\n\nclass Environment:\n    \"\"\"Holds roles and messages; provides routing and artifact retrieval helpers.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track which roles have seen which message ids to avoid duplicate delivery\n        self.delivered: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # Ensure send_to is a set for consistency\n        send_to = getattr(message, \"send_to\", None)\n        if send_to is None:\n            try:\n                message.send_to = set()\n            except Exception:\n                pass\n        self.history.append(message)\n        self.delivered.setdefault(message.id, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Published msg {message.id} from {message.sent_from} cause_by={message.cause_by} preview={_preview(message.content,200)} send_to={sorted(list(getattr(message,'send_to',set()))[:10])}\")\n\n    def find_latest_by_cause(self, cause_by: str) -> Optional[str]:\n        \"\"\"Return content of the latest message with matching cause_by.\"\"\"\n        for msg in reversed(self.history):\n            if msg.cause_by == cause_by:\n                return msg.content\n        return None\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"\n        Determine messages a role should process:\n        - messages explicitly addressed to role.profile or role.name\n        - messages where cause_by matches role.watch_list\n        Excludes messages already delivered to that role.\n        \"\"\"\n        out: List[Message] = []\n        seen = self.delivered.get(role.name, set())\n        for msg in self.history:\n            if msg.id in seen:\n                continue\n            targeted = False\n            targets = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None) or set()\n            if targets:\n                try:\n                    if role.name in targets or role.profile in targets:\n                        targeted = True\n                except Exception:\n                    targeted = False\n            watched = (getattr(msg, \"cause_by\", None) in role.watch_list)\n            # If message is proactive (no watch_list), coder should still be able to act (handled via initial targeting)\n            if targeted or watched:\n                out.append(msg)\n                seen.add(msg.id)\n        if out:\n            self.delivered[role.name] = seen\n        return out\n\nclass Team:\n    \"\"\"Orchestrates the multi-agent workflow with deterministic pipeline and robust termination.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.idea = \"\"\n        self.order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        # termination stability: require same digest for consecutive confirms\n        self._last_digest: Optional[str] = None\n        self._streak = 0\n        self._required_streak = 2  # require two stable verifications\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        # kept for compatibility\n        pass\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {_preview(idea,200)}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # Kickoff message targeted to coders (by profile)\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)}\n        initial = Message(\n            content=f\"Project kickoff: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_profiles\n        )\n        self.env.publish_message(initial)\n\n        verified = False\n        rounds = 0\n\n        for rnd in range(1, n_round + 1):\n            rounds = rnd\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnd}/{n_round}\")\n            any_activity = False\n\n            # Deterministic processing order\n            for role_type in self.order:\n                roles_of_type = [r for r in self.env.roles if isinstance(r, role_type)]\n                for role in roles_of_type:\n                    msgs = self.env.get_messages_for_role(role)\n                    if not msgs:\n                        continue\n                    for msg in msgs:\n                        # don't let role process its own message\n                        if getattr(msg, \"sent_from\", None) == role.name:\n                            continue\n                        try:\n                            response = await role.act(msg)\n                        except Exception as e:\n                            self.tracer.log(\"TEAM_ROLE_EXCEPTION\", \"Team\", f\"Role {role.name} crashed: {type(e).__name__}: {e}\")\n                            response = Message(content=f\"ERROR: {role.name} crashed: {e}\", role=role.profile, cause_by=\"exception\", sent_from=role.name)\n                        if response:\n                            # Provide routing hints if none present\n                            if not getattr(response, \"send_to\", None):\n                                # by default, route next stage based on pipeline\n                                if isinstance(role, SimpleCoder):\n                                    response.send_to = {SimpleTester.profile}\n                                elif isinstance(role, SimpleTester):\n                                    response.send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                                elif isinstance(role, SimpleReviewer):\n                                    # If reviewer requests change, target coder\n                                    if isinstance(response.content, str) and response.content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                                        response.send_to = {SimpleCoder.profile}\n                                        response.cause_by = \"REQUEST_CHANGE\"\n                                    else:\n                                        response.send_to = {SimpleVerifier.profile}\n                                elif isinstance(role, SimpleVerifier):\n                                    response.send_to = {r.profile for r in self.env.roles}\n                            self.env.publish_message(response)\n                            any_activity = True\n                            # parse verification results for termination logic\n                            if isinstance(role, SimpleVerifier) and isinstance(response.content, str):\n                                if \"VERIFICATION_RESULT: PASS\" in response.content:\n                                    # try to extract digest\n                                    digest = None\n                                    for part in (response.content or \"\").split(\"|\"):\n                                        p = part.strip()\n                                        if p.startswith(\"digest=\"):\n                                            digest = p.split(\"=\",1)[1]\n                                            break\n                                    if digest:\n                                        if digest == self._last_digest:\n                                            self._streak += 1\n                                        else:\n                                            self._last_digest = digest\n                                            self._streak = 1\n                                        self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                        if self._streak >= self._required_streak:\n                                            verified = True\n                                    else:\n                                        # If no digest, require explicit reviewer approval to stop\n                                        self._streak = 0\n                                        self._last_digest = None\n                                        self.tracer.log(\"VERIFIER\", \"Team\", \"Pass without digest - not stable\")\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnd} completed any_activity={any_activity} verified={verified}\")\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self._required_streak} rounds; stopping early\")\n                break\n            if not any_activity:\n                # Deadlock detection: nudge coder(s)\n                self.tracer.log(\"TEAM_DEADLOCK\", \"Team\", \"No activity this round; nudging coder(s)\")\n                for r in self.env.roles:\n                    if isinstance(r, SimpleCoder):\n                        nudge = Message(content=f\"Nudge: please propose initial code for '{_preview(self.idea,120)}'\", role=\"System\", sent_from=\"Orchestrator\", cause_by=\"Nudge\", send_to={r.profile})\n                        self.env.publish_message(nudge)\n                # small sleep to allow async LLM to settle if applicable\n                await asyncio.sleep(0.05)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", f\"Completed after {rounds} rounds; verified={verified} history_len={len(self.env.history)}\")\n        self.tracer.log(\"SUMMARY\", \"Team\", f\"Project '{self.idea}' ended rounds={rounds} verified={verified} messages={len(self.env.history)}\")\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 4.2143, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (2.500)\n\n\n### Inspiration 2 (Score: 9.5833, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"LLM_FALLBACK: deterministic response\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nfrom typing import Tuple\n\ndef _preview(text: Optional[str], n: int = 120) -> str:\n    if not text:\n        return \"\"\n    return text[:n] + (\"...\" if len(text) > n else \"\")\n\nclass Action(ABC):\n    \"\"\"Base Action with robust LLM calls and clear responsibilities.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    backoff_base: float = 0.25\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def safe_ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries, exponential backoff, and logging. Return a stable fallback on failure.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            fallback = \"LLM_UNAVAILABLE_FALLBACK\"\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n            return fallback\n\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and (resp.startswith(\"Error\") or resp.startswith(\"Error communicating\")):\n                    last_err = resp\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM error response: {resp[:200]}\")\n                    await asyncio.sleep(self.backoff_base * (2 ** (attempt - 1)))\n                    continue\n                return resp\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {str(e)}\"\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, last_err[:200])\n                await asyncio.sleep(self.backoff_base * (2 ** (attempt - 1)))\n        failure = f\"LLM_CALL_FAILED after {self.max_retries} attempts: {last_err}\"\n        if tracer:\n            tracer.log(\"LLM_ABORT\", self.name, failure)\n        return failure\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        raise NotImplementedError()\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produces Python code implementing the given idea, with fallback and syntax validation.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea={_preview(idea,200)}\")\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module that implements the requested functionality.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Constraints:\\n\"\n            \"- Return only valid Python source code (no markdown or backticks).\\n\"\n            \"- Include docstrings, basic input validation, and error handling.\\n\"\n            \"- Ensure at least one function or class is defined.\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = await self.safe_ask(messages)\n        # Validate and fallback if necessary\n        parsed_ok = False\n        try:\n            ast.parse(code or \"\")\n            parsed_ok = True\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"Generated code failed to parse: {e}\")\n        if not parsed_ok:\n            # Deterministic fallback minimal module\n            code = (\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder implementation.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback placeholder code\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"produced_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generates pytest tests for the provided module, with basic heuristics and fallback.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        truncated = (code or \"\")[:3000]\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided Python module.\\n\\n\"\n            f\"Module (truncated):\\n{truncated}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Provide pytest-compatible tests only.\\n\"\n            \"- Cover typical cases and at least one edge case.\\n\"\n            \"- Include docstrings and clear asserts.\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = await self.safe_ask(messages)\n        # Heuristic validation\n        if not tests or (\"assert\" not in tests and \"pytest\" not in tests and \"unittest\" not in tests):\n            fallback = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            tests = fallback\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback tests\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Reviews code and tests and provides an explicit decision line (APPROVE/REQUEST_CHANGE).\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: APPROVE\\nREVIEW_DECISION: APPROVE\"\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review provided\")\n            return review\n        prompt = (\n            \"You are a senior code reviewer. Provide a concise review and end with a decisive line:\\n\"\n            \"REVIEW_DECISION: APPROVE or REVIEW_DECISION: REQUEST_CHANGE\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:2000]}\\n\\nTests (truncated):\\n{(tests or '')[:2000]}\\n\\n\"\n            \"Focus on correctness, missing tests, and actionable improvements. Keep concise.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        review = await self.safe_ask(messages)\n        if not review or \"REVIEW_DECISION:\" not in review:\n            # Heuristic decision\n            decision = \"APPROVE\" if (\"assert\" in (tests or \"\")) and ((\"def \" in (code or \"\")) or (\"class \" in (code or \"\"))) else \"REQUEST_CHANGE\"\n            review = (review or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"No explicit decision from LLM, inferred {decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Performs deterministic verification of code/tests and returns standardized result with digest.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        code_entities: Set[str] = set()\n\n        # Syntax checks\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:120]})\")\n            parsed_code = None\n\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            tests_ok = True\n            details.append(\"tests_syntax: ok\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:120]})\")\n            parsed_tests = None\n\n        # Semantic checks\n        if parsed_code:\n            for node in parsed_code.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n                    code_entities.add(node.name)\n            details.append(f\"code_entities: {len(code_entities)}\")\n\n        tests_has_assert = False\n        tests_references = set()\n        if parsed_tests:\n            for node in ast.walk(parsed_tests):\n                if isinstance(node, ast.Assert):\n                    tests_has_assert = True\n                if isinstance(node, ast.Name):\n                    tests_references.add(node.id)\n            details.append(f\"tests_asserts: {tests_has_assert}\")\n            inter = code_entities & tests_references\n            details.append(f\"tests_refs_code: {len(inter)}\")\n\n        # Decide PASS/FAIL\n        passed = all([code_ok, tests_ok, bool(code_entities), tests_has_assert, len(code_entities & tests_references) > 0])\n        # Stable digest for verification uniqueness\n        digest_src = (code or \"\").encode(\"utf-8\") + b\"\\n--\\n\" + (tests or \"\").encode(\"utf-8\")\n        digest = hashlib.sha256(digest_src).hexdigest()[:12]\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if passed else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base Role: single responsibility, explicit watch list, idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    action: Optional[Action] = None\n    watch_list: List[str] = []  # list of action names or triggers\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.action = None\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        self._processed: Set[str] = set()\n\n    def set_action(self, action: Action):\n        self.action = action\n\n    def _watch(self, actions: List[Type[Action]]):\n        # Normalize to action.name strings\n        names = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            else:\n                names.append(str(a))\n        self.watch_list = names\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action if message matches watch rules. Ensures idempotency and safe error handling.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.action:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No action configured\")\n            return None\n\n        # Evaluate if this role should act on this message\n        msg_id = getattr(message, \"id\", None)\n        # Skip if already processed this message\n        if msg_id and msg_id in self._processed:\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Already processed message {msg_id}\")\n            return None\n\n        # If message exists and not targeted to this role and not in watch_list, skip\n        if message:\n            send_to = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n            targeted = False\n            if send_to:\n                try:\n                    if isinstance(send_to, (set, list)):\n                        targeted = (self.name in send_to or self.profile in send_to)\n                    else:\n                        targeted = (send_to == self.name or send_to == self.profile)\n                except Exception:\n                    targeted = False\n            watches = getattr(message, \"cause_by\", None) in self.watch_list\n            # If neither targeted nor watched, skip (unless watch_list empty -> proactive)\n            if not targeted and not watches and self.watch_list:\n                if tracer:\n                    tracer.log(\"ROLE_SKIP\", self.name, f\"Not a target/watched message cause_by={getattr(message,'cause_by',None)}\")\n                return None\n\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Executing {self.action.name} for message {msg_id} preview={_preview(getattr(message,'content',None) or '',120)}\")\n\n        try:\n            # Determine inputs for action type\n            if isinstance(self.action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                result = await self.action.run(idea)\n            elif isinstance(self.action, SimpleWriteTest):\n                # Prefer code from message, else fetch latest code in env\n                code = getattr(message, \"content\", \"\") if message and message.cause_by == SimpleWriteCode.name else \"\"\n                if not code and self.env:\n                    code = self.env.find_latest_by_cause(SimpleWriteCode.name) or \"\"\n                result = await self.action.run(code)\n            elif isinstance(self.action, SimpleWriteReview):\n                # Collect latest code and tests\n                code = self.env.find_latest_by_cause(SimpleWriteCode.name) or \"\"\n                tests = self.env.find_latest_by_cause(SimpleWriteTest.name) or \"\"\n                result = await self.action.run(code, tests)\n            elif isinstance(self.action, SimpleVerify):\n                code = self.env.find_latest_by_cause(SimpleWriteCode.name) or \"\"\n                tests = self.env.find_latest_by_cause(SimpleWriteTest.name) or \"\"\n                result = await self.action.run(code, tests)\n            else:\n                result = await self.action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            err = f\"ROLE_ACTION_ERROR: {type(e).__name__}: {str(e)}\"\n            if tracer:\n                tracer.log(\"ROLE_ERROR\", self.name, err[:200])\n            # Mark processed to avoid retry storms\n            if msg_id:\n                self._processed.add(msg_id)\n            return Message(content=err, role=self.profile, cause_by=\"Error\", sent_from=self.name)\n\n        # Build outgoing message\n        out_msg = Message(\n            content=result,\n            role=self.profile,\n            cause_by=self.action.name if self.action else \"\",\n            sent_from=self.name\n        )\n        # Mark processed\n        if msg_id:\n            self._processed.add(msg_id)\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message id={getattr(out_msg,'id',None)} cause_by={out_msg.cause_by}\")\n        return out_msg\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteCode(context=self.context))\n        # Coder is triggered by user input or explicit 'REQUEST_CHANGE'\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteTest(context=self.context))\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteReview(is_human=self.is_human, context=self.context))\n        self._watch([SimpleWriteTest.name])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleVerify(context=self.context))\n        self._watch([SimpleWriteTest.name, SimpleWriteReview.name])\n\nclass Environment:\n    \"\"\"Holds roles and messages; provides routing and artifact retrieval helpers.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track which roles have seen which message ids to avoid duplicate delivery\n        self.delivered: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # Ensure send_to is a set for consistency\n        send_to = getattr(message, \"send_to\", None)\n        if send_to is None:\n            try:\n                message.send_to = set()\n            except Exception:\n                pass\n        self.history.append(message)\n        self.delivered.setdefault(message.id, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Published msg {message.id} from {message.sent_from} cause_by={message.cause_by} preview={_preview(message.content,200)} send_to={sorted(list(getattr(message,'send_to',set()))[:10])}\")\n\n    def find_latest_by_cause(self, cause_by: str) -> Optional[str]:\n        \"\"\"Return content of the latest message with matching cause_by.\"\"\"\n        for msg in reversed(self.history):\n            if msg.cause_by == cause_by:\n                return msg.content\n        return None\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"\n        Determine messages a role should process:\n        - messages explicitly addressed to role.profile or role.name\n        - messages where cause_by matches role.watch_list\n        Excludes messages already delivered to that role.\n        \"\"\"\n        out: List[Message] = []\n        seen = self.delivered.get(role.name, set())\n        for msg in self.history:\n            if msg.id in seen:\n                continue\n            targeted = False\n            targets = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None) or set()\n            if targets:\n                try:\n                    if role.name in targets or role.profile in targets:\n                        targeted = True\n                except Exception:\n                    targeted = False\n            watched = (getattr(msg, \"cause_by\", None) in role.watch_list)\n            # If message is proactive (no watch_list), coder should still be able to act (handled via initial targeting)\n            if targeted or watched:\n                out.append(msg)\n                seen.add(msg.id)\n        if out:\n            self.delivered[role.name] = seen\n        return out\n\nclass Team:\n    \"\"\"Orchestrates the multi-agent workflow with deterministic pipeline and robust termination.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.idea = \"\"\n        self.order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        # termination stability: require same digest for consecutive confirms\n        self._last_digest: Optional[str] = None\n        self._streak = 0\n        self._required_streak = 2  # require two stable verifications\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        # kept for compatibility\n        pass\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {_preview(idea,200)}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # Kickoff message targeted to coders (by profile)\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)}\n        initial = Message(\n            content=f\"Project kickoff: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_profiles\n        )\n        self.env.publish_message(initial)\n\n        verified = False\n        rounds = 0\n\n        for rnd in range(1, n_round + 1):\n            rounds = rnd\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnd}/{n_round}\")\n            any_activity = False\n\n            # Deterministic processing order\n            for role_type in self.order:\n                roles_of_type = [r for r in self.env.roles if isinstance(r, role_type)]\n                for role in roles_of_type:\n                    msgs = self.env.get_messages_for_role(role)\n                    if not msgs:\n                        continue\n                    for msg in msgs:\n                        # don't let role process its own message\n                        if getattr(msg, \"sent_from\", None) == role.name:\n                            continue\n                        try:\n                            response = await role.act(msg)\n                        except Exception as e:\n                            self.tracer.log(\"TEAM_ROLE_EXCEPTION\", \"Team\", f\"Role {role.name} crashed: {type(e).__name__}: {e}\")\n                            response = Message(content=f\"ERROR: {role.name} crashed: {e}\", role=role.profile, cause_by=\"exception\", sent_from=role.name)\n                        if response:\n                            # Provide routing hints if none present\n                            if not getattr(response, \"send_to\", None):\n                                # by default, route next stage based on pipeline\n                                if isinstance(role, SimpleCoder):\n                                    response.send_to = {SimpleTester.profile}\n                                elif isinstance(role, SimpleTester):\n                                    response.send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                                elif isinstance(role, SimpleReviewer):\n                                    # If reviewer requests change, target coder\n                                    if isinstance(response.content, str) and response.content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                                        response.send_to = {SimpleCoder.profile}\n                                        response.cause_by = \"REQUEST_CHANGE\"\n                                    else:\n                                        response.send_to = {SimpleVerifier.profile}\n                                elif isinstance(role, SimpleVerifier):\n                                    response.send_to = {r.profile for r in self.env.roles}\n                            self.env.publish_message(response)\n                            any_activity = True\n                            # parse verification results for termination logic\n                            if isinstance(role, SimpleVerifier) and isinstance(response.content, str):\n                                if \"VERIFICATION_RESULT: PASS\" in response.content:\n                                    # try to extract digest\n                                    digest = None\n                                    for part in (response.content or \"\").split(\"|\"):\n                                        p = part.strip()\n                                        if p.startswith(\"digest=\"):\n                                            digest = p.split(\"=\",1)[1]\n                                            break\n                                    if digest:\n                                        if digest == self._last_digest:\n                                            self._streak += 1\n                                        else:\n                                            self._last_digest = digest\n                                            self._streak = 1\n                                        self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                        if self._streak >= self._required_streak:\n                                            verified = True\n                                    else:\n                                        # If no digest, require explicit reviewer approval to stop\n                                        self._streak = 0\n                                        self._last_digest = None\n                                        self.tracer.log(\"VERIFIER\", \"Team\", \"Pass without digest - not stable\")\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnd} completed any_activity={any_activity} verified={verified}\")\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self._required_streak} rounds; stopping early\")\n                break\n            if not any_activity:\n                # Deadlock detection: nudge coder(s)\n                self.tracer.log(\"TEAM_DEADLOCK\", \"Team\", \"No activity this round; nudging coder(s)\")\n                for r in self.env.roles:\n                    if isinstance(r, SimpleCoder):\n                        nudge = Message(content=f\"Nudge: please propose initial code for '{_preview(self.idea,120)}'\", role=\"System\", sent_from=\"Orchestrator\", cause_by=\"Nudge\", send_to={r.profile})\n                        self.env.publish_message(nudge)\n                # small sleep to allow async LLM to settle if applicable\n                await asyncio.sleep(0.05)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", f\"Completed after {rounds} rounds; verified={verified} history_len={len(self.env.history)}\")\n        self.tracer.log(\"SUMMARY\", \"Team\", f\"Project '{self.idea}' ended rounds={rounds} verified={verified} messages={len(self.env.history)}\")\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (14.000)\n\n\n### Inspiration 3 (Score: 4.6667, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\n# ========== Utility helpers for robust payload handling ==========\n\ndef _strip_code_fences(text: str) -> str:\n    \"\"\"Remove common Markdown code fences to reduce noise.\"\"\"\n    if not text:\n        return \"\"\n    t = text.strip()\n    # Remove triple backticks blocks\n    if \"\n```\nUnique approach: Modification: Full rewrite, Alternative runs_successfully approach, Alternative combined_score approach, Excellent avg_failures_per_task (14.000)\n\n\n### Inspiration 4 (Score: 8.0799, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nimport time\nfrom typing import Tuple, Iterable\n\n# Evolution objectives applied:\n# - Explicit role responsibilities and simple single-action contract\n# - Reliable inter-agent routing: send_to normalized, watch_list triggers, delivered tracking\n# - Robust LLM calls with retries, backoff and deterministic fallback\n# - Strong verification with syntax, structural presence, and cross-reference heuristics\n# - Termination only after stable verification (consecutive identical digests)\n# - Error handling and limited retries for role execution\n\nDEFAULT_LLM_RETRIES = 3\nDEFAULT_LLM_BACKOFF = 0.4\nREQUIRED_STABLE_PASSES = 2  # require this many consecutive identical verification digests\n\ndef _normalize_send_to_field(msg: Message) -> Set[str]:\n    s = getattr(msg, \"send_to\", None)\n    if s is None:\n        s = set(getattr(msg, \"sent_to\", set()) or set())\n    # Ensure set type\n    return set(s or set())\n\nclass Action(ABC):\n    \"\"\"Base action with LLM-safe call and a single run(...) contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = DEFAULT_LLM_RETRIES\n    backoff: float = DEFAULT_LLM_BACKOFF\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def ask_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM robustly with retries and exponential backoff. Returns result or explicit error string.\"\"\"\n        last_err = None\n        tracer = getattr(self.context, \"tracer\", None)\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    fallback = \"LLM_UNAVAILABLE: deterministic fallback\"\n                    if tracer:\n                        tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                res = await self.llm.ask(messages)\n                if isinstance(res, str) and (res.strip() == \"\" or res.lower().startswith(\"error\")):\n                    last_err = res\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM responded with error-like text: {res[:200]}\")\n                    await asyncio.sleep(self.backoff * (2 ** (attempt - 1)))\n                    continue\n                return res\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {e}\"\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, last_err[:200])\n                await asyncio.sleep(self.backoff * (2 ** (attempt - 1)))\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err or 'unknown'}\"\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            # deterministic minimal fallback\n            fallback = (\n                \"# fallback placeholder implementation (empty idea)\\n\"\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder that echoes input.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, \"empty idea -> fallback code\")\n            return fallback\n\n        prompt = (\n            \"You are a professional Python developer. Return only Python source code implementing the task.\\n\"\n            \"Include docstrings and basic input validation. Avoid external network calls.\\n\\n\"\n            f\"Task:\\n{idea}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = await self.ask_with_retries(messages)\n\n        # Validate produced code; if invalid, replace with safe fallback\n        try:\n            if not isinstance(code, str) or not code.strip():\n                raise ValueError(\"Empty or non-string code\")\n            ast.parse(code)\n            if tracer:\n                tracer.log(\"ACTION_VALIDATE\", self.name, \"Code parsed successfully\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, f\"Generated code invalid: {e}\")\n            code = (\n                \"def placeholder(input_data=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback implementation.\\\"\\\"\\\"\\n\"\n                \"    return input_data\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, \"No code provided; returning fallback tests\")\n            return (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n\n        truncated = (code or \"\")[:3000]\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module. \"\n            \"Return only test code.\\n\\n\"\n            f\"Module (truncated):\\n{truncated}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = await self.ask_with_retries(messages)\n\n        # Validate tests: require 'assert' or def test_\n        try:\n            if not isinstance(tests, str) or tests.strip() == \"\":\n                raise ValueError(\"Empty tests\")\n            parsed = ast.parse(tests)\n            has_test = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n            if not (has_test or has_assert):\n                raise ValueError(\"No test functions or assert statements detected\")\n            if tracer:\n                tracer.log(\"ACTION_VALIDATE\", self.name, \"Tests validated\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"Tests invalid or insufficient: {e}; using fallback\")\n            tests = (\n                \"def test_placeholder_positive():\\n\"\n                \"    \\\"\\\"\\\"Basic positive fallback test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            return \"HUMAN_REVIEW: Please check edge cases. REVIEW_DECISION: APPROVE\"\n\n        prompt = (\n            \"You are a senior reviewer. Produce a concise review and end with:\\n\"\n            \"REVIEW_DECISION: APPROVE or REVIEW_DECISION: REJECT\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests (truncated):\\n{(tests or '')[:1500]}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        review = await self.ask_with_retries(messages)\n        if not isinstance(review, str) or \"REVIEW_DECISION:\" not in review:\n            # heuristic: if code has 'def' and tests mention 'test_' or 'assert' approve\n            heur_decision = \"REJECT\"\n            if (\"def \" in (code or \"\") or \"class \" in (code or \"\")) and (\"def test_\" in (tests or \"\") or \"assert\" in (tests or \"\")):\n                heur_decision = \"APPROVE\"\n            review = (review or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {heur_decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"No explicit decision; inferred {heur_decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        code_defs_ok = False\n        tests_have_funcs = False\n        cross_ref_ok = False\n\n        # Syntax checks\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            # heuristics for tests\n            tests_have_funcs = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_asserts = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            tests_ok = tests_have_funcs or has_asserts\n            details.append(\"tests_presence_and_syntax: ok\" if tests_ok else \"tests_presence_and_syntax: fail\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n\n        # Structural presence in code\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_defs_ok = any(isinstance(n, (ast.FunctionDef, ast.ClassDef)) for n in parsed_code.body)\n            details.append(\"code_has_defs: ok\" if code_defs_ok else \"code_has_defs: fail\")\n        except Exception:\n            details.append(\"code_has_defs: fail\")\n\n        # Cross-reference: do tests mention code defs?\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_names = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            parsed_tests = ast.parse(tests or \"\")\n            tests_names = {n.id for n in ast.walk(parsed_tests) if isinstance(n, ast.Name)}\n            text_overlap = any(name in (tests or \"\") for name in code_names)\n            cross_ref_ok = bool(code_names) and (not tests_names.isdisjoint(code_names) or text_overlap)\n            details.append(\"cross_reference: ok\" if cross_ref_ok else \"cross_reference: fail\")\n        except Exception:\n            details.append(\"cross_reference: fail (error)\")\n\n        verified = all([code_ok, tests_ok, code_defs_ok, cross_ref_ok])\n        digest = hashlib.sha256(((code or \"\") + \"\\n--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with single responsibility, watch/trigger logic and idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    action: Optional[Action] = None\n    watch_list: Set[str] = set()  # names of actions this role watches\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.action = None\n        self.watch_list = set()\n        self.env = kwargs.get(\"env\", None)\n        self._processed: Set[str] = set()\n\n    def set_action(self, action: Action):\n        self.action = action\n\n    def _watch(self, actions: Iterable[Type[Action]]):\n        self.watch_list = {getattr(a, \"name\", str(a)) for a in actions}\n\n    def should_handle(self, msg: Message) -> bool:\n        \"\"\"Decide whether to handle a message based on explicit addressing or watch_list triggers.\"\"\"\n        if msg is None:\n            return False\n        # avoid self-handling\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        # if already processed\n        if getattr(msg, \"id\", None) in self._processed:\n            return False\n        # explicit target\n        send_to = _normalize_send_to_field(msg)\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the assigned action for this role and return a Message (always).\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.action:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No action configured\")\n            return None\n\n        # if message present but not relevant, skip\n        if message and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message,'id',None)}\")\n            return None\n\n        # Protect against repeated processing\n        msg_id = getattr(message, \"id\", None)\n        if msg_id and msg_id in self._processed:\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Already processed {msg_id}\")\n            return None\n\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Running action {self.action.name} for msg={msg_id}\")\n\n        try:\n            # dispatch inputs explicitly based on action type\n            if isinstance(self.action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await self.action.run(idea or \"\")\n                send_to = {\"SimpleTester\"}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteTest):\n                # prefer message content (code) else latest artifact\n                code_text = getattr(message, \"content\", \"\") if message else \"\"\n                if not code_text and self.env:\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                out = await self.action.run(code_text)\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteReview):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # parse decision to route appropriately\n                decision = \"REVIEW_DECISION: APPROVE\" if \"REVIEW_DECISION: APPROVE\" in (out or \"\") else None\n                if decision:\n                    send_to = {\"SimpleVerifier\"}\n                else:\n                    # if review rejects, route back for changes\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleVerify):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # verification result is broadcast for traceability\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n            else:\n                out = await self.action.run(getattr(message, \"content\", \"\") if message else \"\")\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n        except Exception as e:\n            # contain errors: report and route to coder for recovery\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, f\"{type(e).__name__}: {str(e)[:200]}\")\n            response = Message(content=f\"ROLE_ERROR: {type(e).__name__}: {str(e)[:200]}\", role=self.profile, cause_by=\"RoleException\", sent_from=self.name, send_to={\"SimpleCoder\"})\n\n        # Mark processed for idempotency\n        if msg_id:\n            self._processed.add(msg_id)\n        # Also mark produced message id to avoid self-processing\n        try:\n            self._processed.add(getattr(response, \"id\", \"\"))\n        except Exception:\n            pass\n\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(response,'id',None)} cause_by={response.cause_by} send_to={_normalize_send_to_field(response)}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteCode(context=self.context))\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteTest(context=self.context))\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteReview(is_human=self.is_human, context=self.context))\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleVerify(context=self.context))\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing and delivered tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # per-role delivered message ids\n        self._delivered: Dict[str, Set[str]] = {}\n        # index by cause_by for artifact lookup\n        self._by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role {role.name} ({role.profile}) watching {sorted(list(role.watch_list))}\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to\n        try:\n            message.send_to = _normalize_send_to_field(message)\n        except Exception:\n            message.send_to = set()\n        # ensure id exists\n        try:\n            if not getattr(message, \"id\", None):\n                message.id = str(uuid.uuid4())\n        except Exception:\n            pass\n        self.history.append(message)\n        if getattr(message, \"cause_by\", \"\"):\n            self._by_cause.setdefault(message.cause_by, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_PUBLISH\", \"Environment\", f\"Msg {getattr(message,'id',None)} from {message.sent_from} cause_by={message.cause_by} to={sorted(list(message.send_to))} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to a role that the role should handle.\"\"\"\n        out: List[Message] = []\n        seen = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            if not getattr(msg, \"id\", None):\n                continue\n            if msg.id in seen:\n                continue\n            # avoid sending a role its own messages\n            if getattr(msg, \"sent_from\", None) == role.name:\n                seen.add(msg.id)\n                continue\n            targeted = bool(msg.send_to and (role.profile in msg.send_to or role.name in msg.send_to))\n            watched = getattr(msg, \"cause_by\", None) in role.watch_list\n            if targeted or watched:\n                out.append(msg)\n                seen.add(msg.id)\n        return out\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names.\"\"\"\n        for cname in cause_names:\n            msgs = self._by_cause.get(cname, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Orchestrator with deterministic sequencing, verification stability, nudges and robust error handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self._last_digest: Optional[str] = None\n        self._streak: int = 0\n        self._required_streak: int = REQUIRED_STABLE_PASSES\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds with stability_required={self._required_streak}\")\n\n        # Kickoff: explicit message targeted to coder(s)\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)}\n        initial_msg = Message(\n            content=f\"Project kickoff: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_profiles\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        rounds_executed = 0\n\n        # stable deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(1, n_round + 1):\n            rounds_executed = round_idx\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            new_messages = 0\n\n            for RoleType in order:\n                roles = [r for r in self.env.roles if isinstance(r, RoleType)]\n                for role in roles:\n                    try:\n                        # On first round ensure coders see initial message if not already delivered\n                        incoming = self.env.get_messages_for_role(role)\n                        if isinstance(role, SimpleCoder) and round_idx == 1 and not incoming:\n                            incoming = [initial_msg]\n                            self.env._delivered.setdefault(role.name, set()).add(initial_msg.id)\n                        for msg in incoming:\n                            # execute role; protect against role exceptions\n                            resp = None\n                            try:\n                                resp = await role.act(msg)\n                            except Exception as e:\n                                self.tracer.log(\"ROLE_ACT_EXCEPTION\", role.name, f\"Exception during act: {type(e).__name__}: {e}\")\n                                resp = Message(content=f\"ERROR: role {role.name} crashed: {e}\", role=role.profile, cause_by=\"RoleCrash\", sent_from=role.name)\n                            if resp:\n                                self.env.publish_message(resp)\n                                new_messages += 1\n                                # track verification passes if produced by verifier role\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str) and \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                    # extract digest\n                                    digest = None\n                                    for part in resp.content.split(\"|\"):\n                                        p = part.strip()\n                                        if p.startswith(\"digest=\"):\n                                            digest = p.split(\"=\", 1)[1]\n                                            break\n                                    if digest:\n                                        if digest == self._last_digest:\n                                            self._streak += 1\n                                        else:\n                                            self._last_digest = digest\n                                            self._streak = 1\n                                        self.tracer.log(\"VERIFIER_PASS\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                    else:\n                                        # no digest -> treat as non-stable\n                                        self._streak = 1\n                                        self._last_digest = None\n                                elif isinstance(role, SimpleVerifier):\n                                    # any non-pass resets streak\n                                    self._streak = 0\n                                    self._last_digest = None\n                    except Exception as e:\n                        self.tracer.log(\"ROUND_ERROR\", \"Team\", f\"Error processing role {role.name}: {type(e).__name__}: {e}\")\n                        # continue with next role\n\n            # Termination checks\n            if self._streak >= self._required_streak:\n                verified = True\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable for {self._required_streak} passes; stopping\")\n                break\n\n            if new_messages == 0:\n                # no progress this round; nudge coders but avoid infinite nudging by only doing one nudge per round\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No new messages this round; nudging coder(s)\")\n                for r in self.env.roles:\n                    if isinstance(r, SimpleCoder):\n                        nudge = Message(\n                            content=f\"Nudge: please refine or propose implementation for: {self.idea}\",\n                            instruct_content=self.idea,\n                            role=\"System\",\n                            sent_from=\"Orchestrator\",\n                            cause_by=\"Nudge\",\n                            send_to={r.profile}\n                        )\n                        self.env.publish_message(nudge)\n                        new_messages += 1\n                # allow a small pause for asynchronicity\n                await asyncio.sleep(0.01)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} completed; new_messages={new_messages} history_len={len(self.env.history)}\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' executed rounds={rounds_executed} messages={len(self.env.history)} verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (5.833)\n\n\n### Inspiration 5 (Score: 4.9844, Type: Migrant)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry and robust error handling\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    retry_backoff: float = 0.5  # base seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"\n        Call LLM with retries and backoff. Treat known error patterns as failures to retry.\n        Returns a string with result or an explicit error message.\n        \"\"\"\n        import asyncio\n        attempt = 0\n        last_error = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # Local fallback\n                    response = \"LLM_NOT_AVAILABLE: fallback response\"\n                else:\n                    response = await self.llm.ask(messages)\n                # Treat structured error responses as failures\n                if isinstance(response, str) and response.startswith(\"Error\"):\n                    last_error = response\n                    raise RuntimeError(response)\n                # Success\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_OK\", self.name, f\"LLM responded (len={len(response)}) on attempt {attempt}\")\n                return response\n            except Exception as e:\n                last_error = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_FAIL\", self.name,\n                                            f\"Attempt {attempt} failed: {last_error}\")\n                if attempt < self.max_retries:\n                    await asyncio.sleep(self.retry_backoff * attempt)\n                else:\n                    # final give up\n                    break\n        # Final failure\n        err_msg = f\"LLM_FAILURE after {self.max_retries} attempts: {last_error}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_GIVEUP\", self.name, err_msg)\n        return err_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea with robust prompting and error handling\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:120]}\")\n\n        prompt = f\"\"\"You are a professional programmer. Write production-ready Python code for the following task.\nTask:\n{idea}\n\nRequirements:\n- Write clean, functional Python code.\n- Include error handling and docstrings.\n- Keep functions small and testable.\n- Include a short usage example in comments.\nReturn only the Python code. Do not include explanatory text.\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        code = await self._llm_call(messages)\n\n        # Basic post-processing: ensure we return a non-empty string\n        if not code or code.startswith(\"LLM_FAILURE\") or code.startswith(\"Error\"):\n            fallback = f\"# ERROR_GENERATING_CODE: {code[:200]}\\n# Please check LLM logs.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_ERROR\", self.name, f\"Falling back to placeholder code\")\n            code = fallback\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} chars\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code, with heuristics and retries\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n\n        truncated_code = (code or \"\")[:4000]\n        prompt = f\"\"\"You are a QA engineer. Write pytest-style tests for the following Python code.\n\nCode:\n{truncated_code}\n\nRequirements:\n- Provide pytest test functions covering typical cases and edge cases.\n- Use clear assertions and include docstrings for tests.\n- If code cannot be tested because it's placeholder or missing, indicate that clearly.\n\nReturn only the pytest code.\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        tests = await self._llm_call(messages)\n\n        # Heuristic validation: ensure tests contain 'assert' or 'pytest'\n        if not tests or (isinstance(tests, str) and \"assert\" not in tests and \"pytest\" not in tests and \"unittest\" not in tests):\n            note = f\"# GENERATED_TESTS_INCOMPLETE: LLM output may be insufficient. Raw: {tests[:200]}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_WARN\", self.name, \"Generated tests may be insufficient\")\n            tests = (tests or \"\") + \"\\n\\n\" + note\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} chars of tests\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests, produce actionable checklist and summary\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n\n        if self.is_human:\n            review = \"Human review: manual check recommended.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Provide a concise actionable review.\n\nCode (truncated):\n{(code or '')[:2000]}\n\nTests (truncated):\n{(tests or '')[:2000]}\n\nProvide:\n- Short summary of major issues (if any).\n- A checklist of fixes or improvements.\n- A single-line readiness verdict: READY or NOT_READY.\n\nReturn as plain text with the verdict on the last line prefixed by VERDICT:\"\"\"\n\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n\n            review = await self._llm_call(messages)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n    max_attempts: int = 3\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"\n        Perform static verification and heuristics for readiness.\n        Returns a structured verification result string.\n        \"\"\"\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n\n        code_ok = False\n        tests_ok = False\n        issues = []\n\n        # Syntax check for code\n        if code and code.strip():\n            try:\n                ast.parse(code)\n                code_ok = True\n            except Exception as e:\n                issues.append(f\"code_syntax_error: {str(e)}\")\n                code_ok = False\n        else:\n            issues.append(\"code_missing_or_empty\")\n\n        # Syntax and heuristic checks for tests\n        if tests and tests.strip():\n            try:\n                ast.parse(tests)\n                # heuristics: look for 'assert' or 'pytest' or 'unittest'\n                lower = tests.lower()\n                if \"assert\" in tests or \"pytest\" in lower or \"unittest\" in lower:\n                    tests_ok = True\n                else:\n                    issues.append(\"tests_lack_asserts_or_framework_usage\")\n                    tests_ok = False\n            except Exception as e:\n                issues.append(f\"tests_syntax_error: {str(e)}\")\n                tests_ok = False\n        else:\n            issues.append(\"tests_missing_or_empty\")\n            tests_ok = False\n\n        verified = code_ok and tests_ok\n        status = {\n            \"code_ok\": code_ok,\n            \"tests_ok\": tests_ok,\n            \"issues\": issues,\n            \"verified\": verified\n        }\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | details: {status}\"\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with explicit responsibilities, watch/trigger logic\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env = kwargs.get('env', None)\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n\n    def should_respond_to(self, message: Message) -> bool:\n        \"\"\"\n        Determine if the role should respond to the message.\n        Default: respond if message.cause_by matches any watched action name OR message is addressed to role.\n        \"\"\"\n        try:\n            if not message:\n                return False\n            # addressed to this role explicitly\n            if getattr(message, \"sent_to\", None):\n                if isinstance(message.sent_to, (list, set)) and (self.name in message.sent_to or self.profile in message.sent_to):\n                    return True\n                if isinstance(message.sent_to, str) and (message.sent_to == self.name or message.sent_to == self.profile):\n                    return True\n            # matches watched action\n            for watched in self.watch_list:\n                if message.cause_by == watched.name:\n                    return True\n            return False\n        except Exception:\n            return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform appropriate action(s) based on message and role responsibilities.\"\"\"\n        if not self.actions:\n            return None\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Act called with message cause_by={getattr(message,'cause_by',None)}\")\n\n        # Try each action (ordered) and produce a single response message per call\n        final_result = None\n        chosen_action = None\n\n        try:\n            for action in self.actions:\n                # Determine if this action should run given the message\n                run_action = False\n                # If no message, allow starter roles (like coder on first round) to run\n                if message is None:\n                    run_action = True\n                else:\n                    run_action = self.should_respond_to(message)\n\n                if not run_action:\n                    # skip this action because message not relevant\n                    continue\n\n                chosen_action = action\n\n                # Determine inputs based on action type\n                if isinstance(action, SimpleWriteCode):\n                    instruct = getattr(message, \"instruct_content\", None) if message else None\n                    # If no instruct content, try to find latest user instruction in env\n                    if not instruct and getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == \"UserInput\" or m.role.lower() == \"human\":\n                                instruct = getattr(m, \"instruct_content\", None) or m.content\n                                break\n                    result = await action.run(instruct or \"\")\n                elif isinstance(action, SimpleWriteTest):\n                    # Find the most recent code message in environment\n                    code_msg = None\n                    if message and message.cause_by == SimpleWriteCode.name and getattr(message, \"content\", None):\n                        code_msg = message\n                    elif getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_msg = m\n                                break\n                    code_text = code_msg.content if code_msg else \"\"\n                    result = await action.run(code_text)\n                elif isinstance(action, SimpleWriteReview):\n                    # Need both code and tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if not code_text and m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                            if not tests_text and m.cause_by == SimpleWriteTest.name:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    result = await action.run(code_text, tests_text)\n                elif isinstance(action, SimpleVerify):\n                    # Collect latest code/tests and run verification\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if not code_text and m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                            if not tests_text and m.cause_by == SimpleWriteTest.name:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    # Try verification possibly multiple times until stable or attempts exhausted\n                    attempt = 0\n                    verification_result = None\n                    while attempt < action.max_attempts:\n                        attempt += 1\n                        verification_result = await action.run(code_text, tests_text)\n                        if isinstance(verification_result, str) and \"VERIFICATION_RESULT: PASS\" in verification_result:\n                            result = verification_result\n                            break\n                        # If fail, try once more if there is a reviewer or tester messages to re-trigger improvements\n                        # but here we just record the latest failure\n                        result = verification_result\n                else:\n                    # Generic action\n                    result = await action.run(message) if message else await action.run()\n\n                final_result = result\n                # After a successful action run, break (roles execute one logical step per call)\n                break\n\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION in {self.name}: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, err)\n            final_result = err\n\n        # Package response as Message\n        response = Message(\n            content=final_result or \"\",\n            role=self.profile,\n            cause_by=chosen_action.name if chosen_action else \"NoAction\",\n            sent_from=self.name\n        )\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed: {response.cause_by}\")\n        return response\n\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with improved message routing\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        # Provide environment reference to role for history lookups\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        # Ensure message has id (pydantic version already has)\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\",\n                          f\"Message from {message.sent_from}: cause_by={message.cause_by} content_preview={(message.content or '')[:120]}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to using explicit watch/trigger rules.\"\"\"\n        relevant_messages: List[Message] = []\n        for msg in self.history:\n            # If message explicitly addressed to role/profile\n            if getattr(msg, \"sent_to\", None):\n                if isinstance(msg.sent_to, (list, set)) and (role.name in msg.sent_to or role.profile in msg.sent_to):\n                    relevant_messages.append(msg)\n                    continue\n                if isinstance(msg.sent_to, str) and (msg.sent_to == role.name or msg.sent_to == role.profile):\n                    relevant_messages.append(msg)\n                    continue\n            # If role watches the cause_by action\n            for watched in role.watch_list:\n                if msg.cause_by == watched.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\n\nclass Team:\n    \"\"\"Team of agents working together with improved orchestration, termination, and validation\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds with robust sequencing and termination rules\"\"\"\n        import asyncio\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n\n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        round_num = 0\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            # Step 1: Coder attempts to produce/iterate code (only on first round or if re-triggered)\n            for role in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                try:\n                    # Coder acts on initial message or explicit trigger addressed to coder\n                    msg_to_coder = initial_msg if round_num == 0 else None\n                    response = await role.act(msg_to_coder)\n                    if response:\n                        self.env.publish_message(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Coder exception: {e}\")\n\n            # Step 2: Tester responds when code available\n            for role in [r for r in self.env.roles if isinstance(r, SimpleTester)]:\n                try:\n                    relevant = self.env.get_messages_for_role(role)\n                    if relevant:\n                        response = await role.act(relevant[-1])\n                        if response:\n                            self.env.publish_message(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Tester exception: {e}\")\n\n            # Step 3: Reviewer provides review when tests are produced\n            for role in [r for r in self.env.roles if isinstance(r, SimpleReviewer)]:\n                try:\n                    relevant = self.env.get_messages_for_role(role)\n                    if relevant:\n                        response = await role.act(relevant[-1])\n                        if response:\n                            self.env.publish_message(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Reviewer exception: {e}\")\n\n            # Step 4: Verifier attempts to verify; if PASS then stop\n            verifier_messages = []\n            for role in [r for r in self.env.roles if isinstance(r, SimpleVerifier)]:\n                try:\n                    relevant = self.env.get_messages_for_role(role)\n                    if relevant:\n                        response = await role.act(relevant[-1])\n                        if response:\n                            self.env.publish_message(response)\n                            verifier_messages.append(response)\n                except Exception as e:\n                    self.tracer.log(\"ROUND_ERROR\", role.name, f\"Verifier exception: {e}\")\n\n            # Check for verification pass by scanning verifier messages\n            for msg in reversed(self.env.history):\n                if getattr(msg, \"cause_by\", \"\") == SimpleVerify.name and isinstance(msg.content, str):\n                    if \"VERIFICATION_RESULT: PASS\" in msg.content:\n                        verified = True\n                        break\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed. Verified={verified}\")\n\n            # Termination: stop early only when verification PASS observed AND at least one full cycle has occurred\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                break\n\n            # Small wait to simulate asynchronous progression and give LLM backoff time if needed\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n\n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (3.167)\n\n\n\n# Current Program\n```python\n# -*- coding: utf-8 -*-\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport re\nimport hashlib\nimport random\n\n# Tunable reliability parameters\nLLM_RETRY_ATTEMPTS = 3\nLLM_RETRY_BACKOFF = 0.75  # seconds base backoff\nROLE_ACTION_TIMEOUT = 90  # seconds\nROLE_ACT_RETRIES = 2      # retries for role.act on transient issues\n\ndef _preview(text: Optional[str], n: int = 140) -> str:\n    if not text:\n        return \"\"\n    return text if len(text) <= n else text[:n] + \"...\"\n\nclass Action(ABC):\n    \"\"\"Base action with clear responsibility and robust LLM/API error handling with retries.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _ask_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"LLM call with retries, backoff, and logging; returns string (never raises).\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        for attempt in range(1, LLM_RETRY_ATTEMPTS + 1):\n            if tracer:\n                tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_RETRY_ATTEMPTS}\")\n            try:\n                if not self.llm:\n                    return \"LLM_UNAVAILABLE: fallback response\"\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and (resp.startswith(\"Error\") or \"Error communicating\" in resp):\n                    last_err = resp\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM returned error: {_preview(resp, 120)}\")\n                    # backoff with jitter\n                    await asyncio.sleep(LLM_RETRY_BACKOFF * attempt + random.random() * 0.2)\n                    continue\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, f\"{type(e).__name__}: {_preview(str(e), 160)}\")\n                await asyncio.sleep(LLM_RETRY_BACKOFF * attempt + random.random() * 0.2)\n        # Exhausted retries\n        fail_msg = f\"ERROR: LLM failed after {LLM_RETRY_ATTEMPTS} attempts: {_preview(str(last_err), 160)}\"\n        if tracer:\n            tracer.log(\"LLM_FAIL\", self.name, fail_msg)\n        return fail_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Execute action; return string result (may start with 'ERROR:' on failure).\"\"\"\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate a parseable Python module that implements the idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Idea={_preview(idea, 120)}\")\n        if not idea or not idea.strip():\n            # deterministic fallback\n            code = (\n                \"def placeholder():\\n\"\n                '    \"\"\"Fallback placeholder when no idea provided.\"\"\"\\n'\n                \"    return None\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No idea provided; emitting placeholder\")\n            return code\n\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module implementing the task.\\n\"\n            \"Constraints:\\n\"\n            \"- Return only valid Python source (no backticks, no prose)\\n\"\n            \"- Include docstrings and basic error handling\\n\"\n            \"- Ensure module is parseable by ast.parse\\n\\n\"\n            f\"Task: {idea}\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python developer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        code = await self._ask_llm(messages)\n\n        # Validate parseability; if failed, emit safe fallback\n        try:\n            ast.parse(code)\n            ok = True\n        except Exception as e:\n            ok = False\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"AST parse error: {_preview(str(e), 160)}\")\n            code = (\n                \"def placeholder():\\n\"\n                '    \"\"\"Fallback due to generation error.\"\"\"\\n'\n                \"    return None\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated length={len(code)} parsed_ok={ok}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for the provided code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Code length={len(code or '')}\")\n        if not code or not code.strip():\n            tests = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                '    \"\"\"Placeholder when no code available.\"\"\"\\n'\n                \"    assert True\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No code provided; emitting placeholder tests\")\n            return tests\n\n        # Collect public symbols to guide tests\n        public_symbols: List[str] = []\n        try:\n            tree = ast.parse(code)\n            for n in ast.walk(tree):\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not getattr(n, \"name\", \"\").startswith(\"_\"):\n                    public_symbols.append(n.name)\n        except Exception:\n            public_symbols = []\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the given Python module.\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest and assert statements\\n\"\n            \"- Cover typical and edge cases where reasonable\\n\"\n            \"- Include short docstrings for tests\\n\\n\"\n            f\"Public symbols: {', '.join(public_symbols[:8]) or '(none detected)'}\\n\\n\"\n            f\"Module (truncated to 2000 chars):\\n{(code or '')[:2000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer writing tests.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        tests = await self._ask_llm(messages)\n\n        # Ensure tests parse; fallback if needed\n        try:\n            ast.parse(tests or \"\")\n            ok = True\n        except Exception as e:\n            ok = False\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Tests AST parse error: {_preview(str(e), 160)}\")\n            tests = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                '    \"\"\"Fallback test when generation fails.\"\"\"\\n'\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests length={len(tests)} parsed_ok={ok}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide a concise actionable review with an explicit verdict token.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"APPROVE: Human reviewer suggests adding more edge-case tests but overall OK.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Review the code and tests concisely.\\n\"\n                \"Begin with either 'REQUEST_CHANGE:' or 'APPROVE:' and provide 3-6 bullet points.\\n\\n\"\n                f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n                f\"Tests (truncated):\\n{(tests or '')[:1500]}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior code reviewer.\"},\n                {\"role\": \"user\", \"content\": prompt},\n            ]\n            review = await self._ask_llm(messages)\n\n        # Guarantee a clear decision token\n        up = (review or \"\").upper()\n        if not (up.startswith(\"REQUEST_CHANGE\") or up.startswith(\"APPROVE\")):\n            review = \"APPROVE: Automated default approval.\\n\" + (review or \"\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Deterministic verification: syntax, structural checks, and digest for stability.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        entities: Set[str] = set()\n        has_asserts = False\n        references_ok = False\n\n        # Code syntax and entities\n        try:\n            code_tree = ast.parse(code or \"\")\n            code_ok = True\n            for node in code_tree.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)):\n                    if not getattr(node, \"name\", \"\").startswith(\"_\"):\n                        entities.add(node.name)\n            details.append(\"code_syntax: ok\")\n            details.append(f\"code_entities: {len(entities)}\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail({type(e).__name__}: {_preview(str(e), 120)})\")\n\n        # Tests syntax and asserts\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            has_asserts = bool(re.search(r\"\\bassert\\b\", tests or \"\"))\n            details.append(\"tests_syntax: ok\" if tests_ok else \"tests_syntax: empty\")\n            details.append(\"tests_asserts: ok\" if has_asserts else \"tests_asserts: none\")\n            # references\n            test_names = {n.id for n in ast.walk(tests_tree) if isinstance(n, ast.Name)}\n            references_ok = bool(entities & test_names) if entities else False\n            details.append(f\"tests_reference_count: {len(entities & test_names) if entities else 0}\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail({type(e).__name__}: {_preview(str(e), 120)})\")\n\n        passed = code_ok and tests_ok and has_asserts and references_ok\n        digest_src = (code or \"\").encode(\"utf-8\") + b\"\\n--\\n\" + (tests or \"\").encode(\"utf-8\")\n        digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if passed else 'FAIL'} | \" + \"; \".join(details) + f\" | digest={digest}\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with single primary action, explicit watch list and safe act wrapper.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # list of action names (or explicit triggers) this role watches\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Accept action classes or names; normalize to name strings.\"\"\"\n        names: List[str] = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"name\", a.__name__))\n            else:\n                names.append(str(a))\n        self.watch_list = names\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the role's primary action. Collect required inputs and handle errors.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n        action = self.actions[0]\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Action={action.name} Trigger msg={getattr(message, 'id', None)}\")\n\n        # Collect latest artifacts as needed\n        code_text = \"\"\n        tests_text = \"\"\n        env = getattr(self, \"env\", None)\n        if env:\n            code_msg, tests_msg = env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n            code_text = code_msg.content if code_msg else \"\"\n            tests_text = tests_msg.content if tests_msg else \"\"\n\n        try:\n            if isinstance(action, SimpleWriteCode):\n                idea = (getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\")\n                result = await action.run(idea or \"\")\n            elif isinstance(action, SimpleWriteTest):\n                # Prefer code from trigger message; otherwise use latest code\n                code_src = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(code_src or code_text or \"\")\n            elif isinstance(action, SimpleWriteReview):\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            elif isinstance(action, SimpleVerify):\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            else:\n                # generic\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ROLE_ERROR\", self.name, f\"Exception: {_preview(str(e), 160)}\")\n            result = f\"ERROR: Role {self.name} failed: {type(e).__name__}: {str(e)}\"\n\n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"\"),\n            sent_from=self.name,\n        )\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message id={response.id} cause_by={response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Writes code from idea.\"\"\"\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # React to initial user input or explicit change requests\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\nclass SimpleTester(Role):\n    \"\"\"Generates tests from latest code.\"\"\"\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Reviews code and tests.\"\"\"\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass SimpleVerifier(Role):\n    \"\"\"Verifies artifacts and declares pass/fail.\"\"\"\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest.name, SimpleWriteReview.name])\n\nclass Environment:\n    \"\"\"Environment manages roles, messages, routing, and delivery tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # message.id -> set(role.name) processed\n        self._processed: Dict[str, Set[str]] = {}\n        # attempts per message (for spam guard)\n        self._attempts: Dict[str, int] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # Ensure id and initialize tracking\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        self._attempts.setdefault(message.id, 0)\n        if self.tracer:\n            self.tracer.log(\n                \"ENV_MESSAGE\",\n                \"Environment\",\n                f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} preview={_preview(message.content, 200)}\"\n            )\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"Msg {message.id} processed by {role.name}\")\n\n    def increment_attempt(self, message: Message) -> int:\n        self._attempts[message.id] = self._attempts.get(message.id, 0) + 1\n        return self._attempts[message.id]\n\n    def get_unprocessed_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages matching role.watch_list or addressed to role, and not processed by it.\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            processed = self._processed.get(msg.id, set())\n            if role.name in processed:\n                continue\n            # address-based\n            targets = getattr(msg, \"send_to\", None)\n            targeted = bool(targets and (role.name in targets or role.profile in targets))\n            # watch-based\n            watched = getattr(msg, \"cause_by\", None) in role.watch_list\n            if targeted or watched:\n                out.append(msg)\n        return out\n\n    def find_latest_pair(self, code_cause: str, tests_cause: str):\n        \"\"\"Find latest messages for code and tests causes.\"\"\"\n        code_msg = None\n        tests_msg = None\n        for msg in reversed(self.history):\n            if not code_msg and getattr(msg, \"cause_by\", \"\") == code_cause:\n                code_msg = msg\n            if not tests_msg and getattr(msg, \"cause_by\", \"\") == tests_cause:\n                tests_msg = msg\n            if code_msg and tests_msg:\n                break\n        return code_msg, tests_msg\n\n    def find_latest_content_by_cause(self, cause: str) -> Optional[str]:\n        for msg in reversed(self.history):\n            if getattr(msg, \"cause_by\", \"\") == cause:\n                return msg.content\n        return None\n\nclass Team:\n    \"\"\"Team orchestrator with deterministic pipeline, robust retries, and stable termination.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability\n        self._confirmations = 0\n        self._last_digest: Optional[str] = None\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {_preview(idea, 200)}\")\n\n    async def _safe_role_act(self, role: Role, message: Optional[Message]) -> Optional[Message]:\n        \"\"\"Call role.act with timeout and limited retries; return Message or None.\"\"\"\n        tracer = self.tracer\n        last_err = None\n        for attempt in range(1, ROLE_ACT_RETRIES + 2):\n            try:\n                if tracer:\n                    tracer.log(\"ROLE_ATTEMPT\", role.name, f\"Attempt {attempt} act on msg={getattr(message,'id',None)}\")\n                resp = await asyncio.wait_for(role.act(message), timeout=ROLE_ACTION_TIMEOUT)\n                if resp and getattr(resp, \"content\", None):\n                    return resp\n                last_err = \"empty_response\"\n            except asyncio.TimeoutError:\n                last_err = \"timeout\"\n                if tracer:\n                    tracer.log(\"ROLE_TIMEOUT\", role.name, f\"Timeout attempt {attempt}\")\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {str(e)}\"\n                if tracer:\n                    tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception attempt {attempt}: {_preview(str(e), 160)}\")\n            await asyncio.sleep(0.2 * attempt)\n        # create error message to record failure\n        return Message(\n            content=f\"ERROR: role {role.name} failed after retries: {last_err}\",\n            role=role.profile,\n            cause_by=\"System\",\n            sent_from=role.name\n        )\n\n    @staticmethod\n    def _extract_digest(text: str) -> Optional[str]:\n        if not isinstance(text, str):\n            return None\n        m = re.search(r\"digest=([0-9a-fA-F]{8,64})\", text)\n        return m.group(1) if m else None\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run collaboration for up to n_rounds with explicit stages and stable termination.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n\n        # Kickoff message targeted to coder(s)\n        coder_targets = {r.name for r in self.env.roles if isinstance(r, SimpleCoder)} or {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)}\n        initial_msg = Message(\n            content=f\"Project kickoff: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_targets\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        history_len_prev = len(self.env.history)\n\n        for round_idx in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            progress = False\n\n            # Stage 1: Coder (respond first round or on explicit request_change)\n            for role in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                inbox = []\n                if round_idx == 1:\n                    inbox = [initial_msg]\n                else:\n                    # respond to REQUEST_CHANGE messages (cause_by=\"REQUEST_CHANGE\")\n                    inbox = [m for m in self.env.get_unprocessed_messages_for_role(role) if getattr(m, \"cause_by\", \"\") in role.watch_list]\n                for msg in inbox:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        # direct next to Testers\n                        resp.cause_by = SimpleWriteCode.name\n                        resp.send_to = {SimpleTester.profile}\n                        self.env.publish_message(resp)\n                        progress = True\n\n            # Stage 2: Tester\n            for role in [r for r in self.env.roles if isinstance(r, SimpleTester)]:\n                msgs = self.env.get_unprocessed_messages_for_role(role)\n                for msg in msgs:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        resp.cause_by = SimpleWriteTest.name\n                        # route to reviewer and verifier\n                        resp.send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                        self.env.publish_message(resp)\n                        progress = True\n\n            # Stage 3: Reviewer\n            for role in [r for r in self.env.roles if isinstance(r, SimpleReviewer)]:\n                msgs = self.env.get_unprocessed_messages_for_role(role)\n                for msg in msgs:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        # If requests change, notify coder; else notify verifier\n                        content = resp.content or \"\"\n                        if isinstance(content, str) and content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                            resp.cause_by = \"REQUEST_CHANGE\"\n                            resp.send_to = {SimpleCoder.profile}\n                        else:\n                            resp.cause_by = SimpleWriteReview.name\n                            resp.send_to = {SimpleVerifier.profile}\n                        self.env.publish_message(resp)\n                        progress = True\n\n            # Stage 4: Verifier\n            for role in [r for r in self.env.roles if isinstance(r, SimpleVerifier)]:\n                msgs = self.env.get_unprocessed_messages_for_role(role)\n                for msg in msgs:\n                    self.env.increment_attempt(msg)\n                    resp = await self._safe_role_act(role, msg)\n                    self.env.mark_processed(msg, role)\n                    if resp:\n                        resp.cause_by = SimpleVerify.name\n                        resp.send_to = {r.profile for r in self.env.roles}  # broadcast\n                        self.env.publish_message(resp)\n                        progress = True\n\n                        # Evaluate verification result\n                        if isinstance(resp.content, str) and \"VERIFICATION_RESULT: PASS\" in resp.content:\n                            digest = self._extract_digest(resp.content)\n                            # Confirm by re-running verification directly for stability\n                            try:\n                                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                                verifier_action = role.actions[0] if role.actions else None\n                                if verifier_action:\n                                    confirm = await verifier_action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n                                    if isinstance(confirm, str) and \"VERIFICATION_RESULT: PASS\" in confirm:\n                                        confirm_digest = self._extract_digest(confirm)\n                                        if digest and confirm_digest and digest == confirm_digest:\n                                            self._confirmations += 1\n                                            self._last_digest = digest\n                                            self.tracer.log(\"VERIFY_CONFIRM\", \"Team\", f\"Confirmed PASS digest={digest} confirmations={self._confirmations}\")\n                            except Exception as e:\n                                self.tracer.log(\"VERIFY_EXCEPTION\", \"Team\", f\"Confirmation error: {_preview(str(e), 160)}\")\n\n            # Termination logic:\n            # Stop when at least one confirmation achieved and no progress since then\n            history_len_now = len(self.env.history)\n            if history_len_now == history_len_prev:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            history_len_prev = history_len_now\n\n            if self._confirmations >= 1 and no_progress_rounds >= 1:\n                verified = True\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verified and stable; stopping after round {round_idx}\")\n                break\n\n            # Hang detection\n            if not progress:\n                self.tracer.log(\"ROUND_IDLE\", \"Team\", \"No progress detected this round\")\n            if no_progress_rounds >= 2:\n                self.tracer.log(\"TEAM_HANG_DETECT\", \"Team\", \"No progress for 2 rounds; stopping to avoid livelock\")\n                break\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} complete; progress={progress}\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", f\"Project complete; Verified={verified} Confirmations={self._confirmations}\")\n\n        summary = f\"Project '{self.idea}' completed after {round_idx} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# -*- coding: utf-8 -*-\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nimport random\nimport time\nfrom typing import Tuple, Iterable\n\n# Goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing and delivered tracking\n# - Deterministic orchestration and idempotent processing\n# - Strong verification & validation\n# - Error handling and retries for LLM/API failures\n# - Stable termination requiring consecutive verification confirmations\n\nLLM_MAX_RETRIES = 3\nLLM_BASE_BACKOFF = 0.5\nROLE_ACT_TIMEOUT = 30.0\nROLE_ACT_RETRIES = 2\nREQUIRED_STABLE_PASSES = 2\n\ndef _preview(text: Optional[str], n: int = 120) -> str:\n    if not text:\n        return \"\"\n    return text if len(text) <= n else text[:n] + \"...\"\n\ndef _normalize_send_to_field(msg: Message) -> Set[str]:\n    s = getattr(msg, \"send_to\", None)\n    if s is None:\n        try:\n            s = set(getattr(msg, \"sent_to\", set()) or set())\n        except Exception:\n            s = set()\n    # ensure set\n    return set(s or set())\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call and deterministic fallback.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = LLM_MAX_RETRIES\n    backoff: float = LLM_BASE_BACKOFF\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    fallback = \"LLM_UNAVAILABLE: deterministic fallback\"\n                    if tracer:\n                        tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and (resp.strip() == \"\" or resp.lower().startswith(\"error\")):\n                    last_err = resp\n                    if tracer:\n                        tracer.log(\"LLM_ERROR\", self.name, f\"LLM returned error-like response: {_preview(resp,200)}\")\n                    await asyncio.sleep(self.backoff * (2 ** (attempt - 1)) + random.random() * 0.1)\n                    continue\n                return resp\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {e}\"\n                if tracer:\n                    tracer.log(\"LLM_EXCEPTION\", self.name, _preview(last_err, 200))\n                await asyncio.sleep(self.backoff * (2 ** (attempt - 1)) + random.random() * 0.1)\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err or 'unknown'}\"\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_preview={_preview(idea,120)}\")\n        if not idea or not idea.strip():\n            fallback = (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback implementation.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Empty idea -> placeholder\")\n            return fallback\n\n        prompt = (\n            \"You are a professional Python developer. Return only valid Python source code that implements the task. \"\n            \"Include docstrings and basic input validation. Keep functions small and testable.\\n\\n\"\n            f\"Task:\\n{idea}\\n\"\n        )\n        messages = [{\"role\":\"system\",\"content\":\"You are an expert Python programmer.\"},\n                    {\"role\":\"user\",\"content\":prompt}]\n        code = await self.ask_with_retry(messages)\n\n        # validate parseability\n        try:\n            ast.parse(code or \"\")\n            parsed_ok = True\n        except Exception as e:\n            parsed_ok = False\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, f\"Parse error: {_preview(str(e),160)}\")\n            code = (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback: returns provided value.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)} parsed_ok={parsed_ok}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            fallback = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No code -> placeholder test\")\n            return fallback\n\n        truncated = (code or \"\")[:3000]\n        # collect top-level symbols to guide tests\n        symbols = []\n        try:\n            tree = ast.parse(code)\n            for node in tree.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)) and not node.name.startswith(\"_\"):\n                    symbols.append(node.name)\n        except Exception:\n            symbols = []\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module. Return only the test source.\\n\\n\"\n            f\"Public symbols: {', '.join(symbols[:8]) or '(none detected)'}\\n\\nModule (truncated):\\n{truncated}\\n\"\n        )\n        messages = [{\"role\":\"system\",\"content\":\"You are an expert QA engineer.\"},\n                    {\"role\":\"user\",\"content\":prompt}]\n        tests = await self.ask_with_retry(messages)\n\n        # validate tests parse and presence of asserts or test_ functions\n        valid = False\n        try:\n            parsed = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n            valid = bool(has_test_fn or has_assert)\n        except Exception:\n            valid = False\n\n        if not valid:\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, \"Generated tests invalid or insufficient; using fallback\")\n            tests = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)} valid={valid}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: Manual check recommended. REVIEW_DECISION: REQUEST_CHANGE\"\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review simulated\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise review and end with REVIEW_DECISION: APPROVE or REVIEW_DECISION: REQUEST_CHANGE.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:2000]}\\n\\nTests (truncated):\\n{(tests or '')[:2000]}\"\n        )\n        messages = [{\"role\":\"system\",\"content\":\"You are a senior software engineer.\"},\n                    {\"role\":\"user\",\"content\":prompt}]\n        review = await self.ask_with_retry(messages)\n\n        # ensure a decision token exists\n        if not isinstance(review, str) or \"REVIEW_DECISION:\" not in review:\n            # heuristic decision\n            decision = \"REQUEST_CHANGE\"\n            try:\n                ast.parse(code or \"\")\n                if (\"assert\" in (tests or \"\")) or (\"def test_\" in (tests or \"\")):\n                    decision = \"APPROVE\"\n            except Exception:\n                decision = \"REQUEST_CHANGE\"\n            review = (review or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"No explicit decision from LLM, inferred {decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        entities: Set[str] = set()\n        tests_have_asserts = False\n        cross_ref_ok = False\n\n        # code syntax and entities\n        try:\n            code_tree = ast.parse(code or \"\")\n            code_ok = True\n            for node in code_tree.body:\n                if isinstance(node, (ast.FunctionDef, ast.ClassDef)) and not getattr(node, \"name\", \"\").startswith(\"_\"):\n                    entities.add(node.name)\n            details.append(\"code_syntax: ok\")\n            details.append(f\"code_entities: {len(entities)}\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {_preview(str(e),120)})\")\n\n        # tests syntax and asserts\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            tests_ok = True if tests and tests.strip() else False\n            tests_have_asserts = any(isinstance(n, ast.Assert) for n in ast.walk(tests_tree))\n            details.append(\"tests_syntax: ok\" if tests_ok else \"tests_syntax: empty\")\n            details.append(\"tests_asserts: ok\" if tests_have_asserts else \"tests_asserts: none\")\n            # cross reference\n            test_names = {n.id for n in ast.walk(tests_tree) if isinstance(n, ast.Name)}\n            cross_ref_ok = bool(entities and not entities.isdisjoint(test_names))\n            details.append(f\"tests_reference_count: {len(entities & test_names) if entities else 0}\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {_preview(str(e),120)})\")\n\n        passed = code_ok and tests_ok and tests_have_asserts and cross_ref_ok\n        digest_src = (code or \"\").encode(\"utf-8\") + b\"\\n--\\n\" + (tests or \"\").encode(\"utf-8\")\n        digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if passed else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with single responsibility, watch list and idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    action: Optional[Action] = None\n    watch_list: Set[str] = set()\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.action = None\n        self.watch_list = set()\n        self.env = kwargs.get(\"env\", None)\n        self._processed: Set[str] = set()\n\n    def set_action(self, action: Action):\n        self.action = action\n\n    def _watch(self, actions: Iterable[Type[Action]]):\n        self.watch_list = {getattr(a, \"name\", str(a)) for a in actions}\n\n    def should_handle(self, msg: Message) -> bool:\n        if msg is None:\n            return False\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed:\n            return False\n        send_to = _normalize_send_to_field(msg)\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.action:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No action configured\")\n            return None\n\n        if message and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message,'id',None)}\")\n            return None\n\n        msg_id = getattr(message, \"id\", None)\n        if msg_id and msg_id in self._processed:\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Already processed {msg_id}\")\n            return None\n\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Running {self.action.name} for msg={msg_id}\")\n\n        try:\n            # dispatch by action type with explicit input gathering\n            if isinstance(self.action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await self.action.run(idea or \"\")\n                send_to = {SimpleTester.profile}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteTest):\n                code_text = (message.content if message and message.cause_by == SimpleWriteCode.name else \"\") or \"\"\n                if not code_text and self.env:\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                out = await self.action.run(code_text)\n                send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleWriteReview):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # route based on review decision\n                decision = \"REQUEST_CHANGE\" if \"REQUEST_CHANGE\" in (out or \"\").upper() else \"APPROVE\"\n                if decision == \"REQUEST_CHANGE\":\n                    send_to = {SimpleCoder.profile}\n                else:\n                    send_to = {SimpleVerifier.profile}\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=send_to)\n\n            elif isinstance(self.action, SimpleVerify):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await self.action.run(code_text, tests_text)\n                # broadcast verification result for traceability\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n            else:\n                out = await self.action.run(getattr(message, \"content\", \"\") if message else \"\")\n                response = Message(content=out, role=self.profile, cause_by=self.action.name, sent_from=self.name, send_to=set())\n\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {type(e).__name__}: {str(e)[:200]}\"\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(content=err, role=self.profile, cause_by=\"RoleException\", sent_from=self.name, send_to={SimpleCoder.profile})\n\n        # mark processed to maintain idempotency\n        if msg_id:\n            self._processed.add(msg_id)\n        try:\n            self._processed.add(getattr(response, \"id\", \"\"))\n        except Exception:\n            pass\n\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(response,'id',None)} cause_by={response.cause_by} send_to={sorted(list(_normalize_send_to_field(response)))}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteCode(context=self.context))\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteTest(context=self.context))\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleWriteReview(is_human=self.is_human, context=self.context))\n        self._watch([SimpleWriteTest.name])\n\nclass SimpleVerifier(Role):\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_action(SimpleVerify(context=self.context))\n        self._watch([SimpleWriteTest.name, SimpleWriteReview.name, SimpleWriteCode.name])\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing and delivered tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered map: role.name -> set(msg.id)\n        self._delivered: Dict[str, Set[str]] = {}\n        # index by cause_by for artifact lookup\n        self._by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role {role.name} ({role.profile}) watching {sorted(list(role.watch_list))}\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to set\n        try:\n            message.send_to = _normalize_send_to_field(message)\n        except Exception:\n            message.send_to = set()\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if getattr(message, \"cause_by\", \"\"):\n            self._by_cause.setdefault(message.cause_by, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_PUBLISH\", \"Environment\", f\"Msg {getattr(message,'id',None)} from {message.sent_from} cause_by={message.cause_by} to={sorted(list(message.send_to))} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to a role that the role should handle.\"\"\"\n        out: List[Message] = []\n        seen = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            if not getattr(msg, \"id\", None):\n                continue\n            if msg.id in seen:\n                continue\n            # avoid self messages\n            if getattr(msg, \"sent_from\", None) == role.name:\n                seen.add(msg.id)\n                continue\n            targeted = bool(msg.send_to and (role.profile in msg.send_to or role.name in msg.send_to))\n            watched = getattr(msg, \"cause_by\", None) in role.watch_list\n            if targeted or watched:\n                out.append(msg)\n                seen.add(msg.id)\n        return out\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names.\"\"\"\n        for cname in cause_names:\n            msgs = self._by_cause.get(cname, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Orchestrator with deterministic sequencing, verification stability, nudges and robust error handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self._last_digest: Optional[str] = None\n        self._streak: int = 0\n        self._required_streak: int = REQUIRED_STABLE_PASSES\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {_preview(idea,200)}\")\n\n    async def _safe_act(self, role: Role, message: Optional[Message]) -> Optional[Message]:\n        \"\"\"Call role.act with timeout and limited retries.\"\"\"\n        last_err = None\n        for attempt in range(1, ROLE_ACT_RETRIES + 2):\n            try:\n                self.tracer.log(\"ROLE_ATTEMPT\", role.name, f\"Attempt {attempt} act on msg={getattr(message,'id',None)}\")\n                resp = await asyncio.wait_for(role.act(message), timeout=ROLE_ACT_TIMEOUT)\n                if resp and getattr(resp, \"content\", None) is not None:\n                    return resp\n                last_err = \"empty_response\"\n            except asyncio.TimeoutError:\n                last_err = \"timeout\"\n                self.tracer.log(\"ROLE_TIMEOUT\", role.name, f\"Timeout on attempt {attempt}\")\n            except Exception as e:\n                last_err = f\"{type(e).__name__}: {e}\"\n                self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception attempt {attempt}: {_preview(str(e),160)}\")\n            await asyncio.sleep(0.1 * attempt)\n        # failure message\n        return Message(content=f\"ERROR: role {role.name} failed after retries: {last_err}\", role=role.profile, cause_by=\"System\", sent_from=role.name, send_to={r.profile for r in self.env.roles})\n\n    @staticmethod\n    def _extract_digest(text: str) -> Optional[str]:\n        if not isinstance(text, str):\n            return None\n        for part in text.split(\"|\"):\n            p = part.strip()\n            if p.startswith(\"digest=\"):\n                return p.split(\"=\",1)[1]\n        return None\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds with required_streak={self._required_streak}\")\n\n        # Kickoff: targeted to coder profiles\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial = Message(content=f\"Project kickoff: {self.idea}\", instruct_content=self.idea, role=\"Human\", sent_from=\"User\", cause_by=\"UserInput\", send_to=coder_profiles)\n        self.env.publish_message(initial)\n\n        verified = False\n        rounds_executed = 0\n\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(1, n_round + 1):\n            rounds_executed = round_idx\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            any_new = 0\n\n            for RoleType in order:\n                roles = [r for r in self.env.roles if isinstance(r, RoleType)]\n                for role in roles:\n                    try:\n                        incoming = self.env.get_messages_for_role(role)\n                        # ensure coders get initial on first round\n                        if isinstance(role, SimpleCoder) and round_idx == 1:\n                            if initial.id not in {m.id for m in incoming}:\n                                incoming = [initial] + incoming\n                                self.env._delivered.setdefault(role.name, set()).add(initial.id)\n                        for msg in incoming:\n                            resp = await self._safe_act(role, msg)\n                            # delivered already updated by get_messages_for_role; mark processing here for trace\n                            if resp:\n                                # enrich routing if absent\n                                if not getattr(resp, \"send_to\", None):\n                                    if isinstance(role, SimpleCoder):\n                                        resp.send_to = {SimpleTester.profile}\n                                    elif isinstance(role, SimpleTester):\n                                        resp.send_to = {SimpleReviewer.profile, SimpleVerifier.profile}\n                                    elif isinstance(role, SimpleReviewer):\n                                        if isinstance(resp.content, str) and resp.content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                                            resp.send_to = {SimpleCoder.profile}\n                                            resp.cause_by = \"REQUEST_CHANGE\"\n                                        else:\n                                            resp.send_to = {SimpleVerifier.profile}\n                                    elif isinstance(role, SimpleVerifier):\n                                        resp.send_to = {r.profile for r in self.env.roles}\n                                self.env.publish_message(resp)\n                                any_new += 1\n\n                                # handle verifier result to update streak\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    if \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                        digest = self._extract_digest(resp.content)\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._streak = 1\n                                            self.tracer.log(\"VERIFIER_PASS\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                        else:\n                                            self._streak = 0\n                                            self._last_digest = None\n                                    else:\n                                        # reset on fail\n                                        self._streak = 0\n                                        self._last_digest = None\n                    except Exception as e:\n                        self.tracer.log(\"ROUND_ERROR\", \"Team\", f\"Error processing role {role.name}: {type(e).__name__}: {_preview(str(e),160)}\")\n                        continue\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} completed any_new={any_new} streak={self._streak}\")\n            if self._streak >= self._required_streak:\n                verified = True\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable for {self._required_streak} passes; stopping\")\n                break\n\n            if any_new == 0:\n                # no progress - nudge coder(s)\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No new messages this round; nudging coder(s)\")\n                for r in self.env.roles:\n                    if isinstance(r, SimpleCoder):\n                        nudge = Message(content=f\"Nudge: please refine implementation for: {self.idea}\", instruct_content=self.idea, role=\"System\", sent_from=\"Orchestrator\", cause_by=\"Nudge\", send_to={r.profile})\n                        self.env.publish_message(nudge)\n                # allow small pause for LLM backoff\n                await asyncio.sleep(0.02)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' executed rounds={rounds_executed} messages={len(self.env.history)} verified={verified} streak={self._streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}