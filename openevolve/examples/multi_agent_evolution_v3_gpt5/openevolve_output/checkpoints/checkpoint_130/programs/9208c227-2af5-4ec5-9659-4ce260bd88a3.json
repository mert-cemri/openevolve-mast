{"id": "9208c227-2af5-4ec5-9659-4ce260bd88a3", "code": "# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport random\nfrom typing import Tuple\n\n# Goals implemented:\n# - Clear roles and responsibilities\n# - Explicit triggers and routing (send_to)\n# - Deterministic orchestration with per-role processed tracking\n# - Robust LLM retry + fallback\n# - Strong verification and confirmation + stable termination (consecutive passes)\n# - Error handling and retry across role actions\n\nDEFAULT_VERIFICATION_STREAK = 2\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.8  # seconds\nMAX_MESSAGE_ATTEMPTS = 6\n\nclass Action(ABC):\n    \"\"\"Base action with LLM retry, backoff, validation and fallback semantics.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = LLM_MAX_RETRIES\n    backoff_base: float = LLM_BACKOFF_BASE\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def call_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries and exponential backoff. Returns string result or an explicit error token.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # Deterministic fallback to avoid hard failure\n                    fallback = \"LLM_UNAVAILABLE: deterministic fallback\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # jittered backoff\n                await asyncio.sleep(self.backoff_base * (2 ** (attempt - 1)) + random.uniform(0, 0.25))\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce a validated Python module from idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            # clear signal for empty idea\n            fallback = \"# WARNING: Empty idea provided. No code generated.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_WARN\", self.name, \"Empty idea\")\n            return fallback\n\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module implementing the described task. \"\n            \"Return only valid Python source code, no markdown fences or explanations. Include docstrings and input validation.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self.call_llm(messages)\n        # If LLM failed, return explicit failure so downstream can react\n        if isinstance(resp, str) and resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n            fallback = f\"# CODE_GEN_ERROR: {resp}\\n# Please retry or provide a human-coded fallback.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; returning error sentinel\")\n            return fallback\n\n        # Try to sanitize common code fences\n        code = self._strip_code_fences(resp)\n        # Validate syntax\n        try:\n            ast.parse(code)\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATE\", self.name, \"Code syntax ok\")\n            return code\n        except Exception as e:\n            # attempt small fix: wrap into function if possible\n            try:\n                wrapper = \"def _generated_wrapper():\\n\"\n                for line in code.splitlines():\n                    wrapper += \"    \" + line + \"\\n\"\n                ast.parse(wrapper)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_FIX\", self.name, \"Applied safe wrapper to fix syntax\")\n                return wrapper\n            except Exception:\n                err = f\"# CODE_PARSE_ERROR: {str(e)[:160]}\\n# Raw Output:\\n{code}\"\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_ERROR\", self.name, f\"Code parse failed: {str(e)[:200]}\")\n                return err\n\n    def _strip_code_fences(self, text: Optional[str]) -> str:\n        if not text:\n            return \"\"\n        t = text.strip()\n        # remove triple backticks\n        if t.startswith(\"", "language": "python", "parent_id": "c47600ac-67dc-4535-b148-8e5c8e3c7393", "generation": 3, "timestamp": 1754656352.3713884, "iteration_found": 62, "metrics": {"runs_successfully": 0.0, "combined_score": 0.0, "avg_failures_per_task": 14.0, "error": "unterminated string literal (detected at line 286) (tmpjbe629cm.py, line 286)"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "overall_score": 0.5, "combined_score": 0.35294117647058826, "avg_failures_per_task": 1.8333333333333333, "total_failures": 11.0, "successful_runs": 6.0}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes per the MAST taxonomy.\n\nFocus on:\n- Clear role definitions and responsibilities\n- Robust inter-agent communication patterns and explicit watch/trigger logic\n- Termination conditions (avoid premature termination; stop once verified)\n- Strong verification and validation steps\n- Error handling and retry on LLM/API failures\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 1.0000\n- overall_score: 0.5000\n- combined_score: 0.3529\n- avg_failures_per_task: 1.8333\n- total_failures: 11.0000\n- successful_runs: 6.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: combined_score. Consider continuing with similar changes.\n- Metrics showing regression: avg_failures_per_task. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.2222, avg_failures_per_task: 3.5000, total_failures: 21.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.2609, avg_failures_per_task: 2.8333, total_failures: 17.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 3.4477)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.3529), Performs well on avg_failures_per_task (1.8333), Performs well on total_failures (11.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 2 (Score: 4.5990)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class with error handling and retry support.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 2\n    \n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        self.max_retries = kwargs.get('max_retries', 2)\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n    \n    async def safe_ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Ask the LLM with retry and exponential backoff. Returns result or error string.\"\"\"\n        attempt = 0\n        last_err = None\n        while attempt <= self.max_retries:\n            attempt += 1\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"LLM_ASK\", self.name, f\"Attempt {attempt}/{self.max_retries+1}\")\n            try:\n                if not self.llm:\n                    return \"LLM_UNAVAILABLE: Using fallback response.\"\n                res = await self.llm.ask(messages)\n                # treat responses starting with \"Error:\" or \"Error communicating\" as failures\n                if isinstance(res, str) and (res.startswith(\"Error:\") or res.startswith(\"Error communicating\")):\n                    last_err = res\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_ERROR\", self.name, f\"LLM returned error text: {res[:200]}\")\n                    # fall through to retry\n                else:\n                    return res\n            except Exception as e:\n                last_err = f\"Exception: {e}\"\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_EXCEPTION\", self.name, str(e))\n            # simple backoff\n            if attempt <= self.max_retries:\n                # we don't want to import time in evolve block; just log retry\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_RETRY\", self.name, f\"Retrying LLM ask (attempt {attempt + 1})\")\n        # all attempts failed\n        return last_err or \"LLM_UNKNOWN_ERROR\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        raise NotImplementedError()\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea, with validation and retries\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for idea (len={len(idea or '')})\")\n        \n        if not idea or not idea.strip():\n            warning = \"# WARNING: Empty idea provided. No code generated.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_WARN\", self.name, \"Empty idea; returning warning code\")\n            return warning\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        code = await self.safe_ask(messages)\n        # Basic validation: ensure non-empty and syntactically parseable (best-effort)\n        import ast\n        try:\n            if not code or not isinstance(code, str) or code.strip() == \"\":\n                raise ValueError(\"Empty code returned\")\n            ast.parse(code)\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATE\", self.name, \"Code parsed successfully\")\n        except Exception as e:\n            # Return explicit error result so downstream roles can detect and trigger retries\n            err = f\"# CODE_GENERATION_ERROR: {str(e)}\\n# Raw Output:\\n{(code or '')}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_ERROR\", self.name, f\"Validation failed: {e}\")\n            return err\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code length={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code, validate presence of test functions\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        if not code or not code.strip():\n            msg = \"# WARNING: No code to test. Generated placeholder tests.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_WARN\", self.name, \"No code provided for tests\")\n            return msg\n        \n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code[:2000]}\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        tests = await self.safe_ask(messages)\n        \n        # Basic validation: ensure at least one function called test_\n        import ast\n        try:\n            if not tests or not isinstance(tests, str) or tests.strip() == \"\":\n                raise ValueError(\"Empty tests returned\")\n            parsed = ast.parse(tests)\n            has_test = any(\n                isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in parsed.body\n            )\n            if not has_test:\n                raise ValueError(\"No pytest-style test functions found (test_ prefix)\")\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATE\", self.name, \"Tests parsed and contain test_ functions\")\n        except Exception as e:\n            err = f\"# TEST_GENERATION_ERROR: {str(e)}\\n# Raw Output:\\n{(tests or '')}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_ERROR\", self.name, f\"Validation failed: {e}\")\n            return err\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests length={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests and provide actionable items\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code/tests (human={self.is_human})\")\n        \n        if self.is_human:\n            review = \"Human review: Please verify edge cases and error handling; consider input validation.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_HUMAN_REVIEW\", self.name, \"Simulated human review provided\")\n            return review\n        \n        prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode (first 1500 chars):\n{code[:1500]}\n\nTests (first 1500 chars):\n{tests[:1500]}\n\nFocus on:\n1. Code quality and best practices\n2. Test coverage and missing edge cases\n3. Potential bugs or issues\n4. Concrete suggestions for improvement\n\nProvide a concise, actionable review.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        review = await self.safe_ask(messages)\n        if not review or not isinstance(review, str):\n            review = \"REVIEW_ERROR: No review generated.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_ERROR\", self.name, \"No review returned from LLM\")\n        else:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_END\", self.name, f\"Review generated len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n        details = []\n        code_ok = False\n        tests_ok = False\n        # Syntax checks\n        try:\n            if not code or not code.strip():\n                raise ValueError(\"Empty code\")\n            ast.parse(code)\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({str(e)[:120]})\")\n        try:\n            if not tests or not tests.strip():\n                raise ValueError(\"Empty tests\")\n            parsed_tests = ast.parse(tests)\n            # heuristic: presence of at least one test_ function\n            has_tests = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in parsed_tests.body)\n            if has_tests:\n                tests_ok = True\n                details.append(\"tests_syntax_and_presence: ok\")\n            else:\n                details.append(\"tests_syntax_and_presence: fail (no test_ functions found)\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({str(e)[:120]})\")\n        # Coverage heuristics: ensure functions in code are referenced by tests (simple name match)\n        coverage_ok = False\n        if code_ok and tests_ok:\n            try:\n                parsed_code = ast.parse(code)\n                func_names = {n.name for n in parsed_code.body if isinstance(n, ast.FunctionDef)}\n                # look for function names in test source\n                tests_text = tests\n                matched = [fn for fn in func_names if fn and fn in tests_text]\n                if func_names and matched:\n                    coverage_ok = True\n                    details.append(f\"coverage_hint: ok (matched functions: {matched[:5]})\")\n                else:\n                    details.append(\"coverage_hint: fail (no clear function usage in tests)\")\n            except Exception as e:\n                details.append(f\"coverage_check_error: {str(e)[:120]}\")\n        verified = code_ok and tests_ok and coverage_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(details)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    triggers_on: List[str] = []  # cause_by values this role listens for\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.triggers_on = kwargs.get('triggers_on', [])\n        # reference to env may be injected by Team.hire\n        self.env = None\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for (by action class)\"\"\"\n        self.watch_list = actions\n        # also set triggers_on strings for quick matching\n        self.triggers_on = [a.name for a in actions]\n    \n    def can_respond_to(self, msg: Message) -> bool:\n        \"\"\"Determine whether this role should respond to the message.\"\"\"\n        # If triggers_on empty, role acts proactively (e.g., coder on initial human input)\n        if not self.triggers_on:\n            return False\n        return msg.cause_by in self.triggers_on\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the role's primary action in a guarded manner.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Attempting action: {action.name} on message id={(getattr(message,'id',None))}\")\n        try:\n            # Map action type to expected inputs explicitly\n            if isinstance(action, SimpleWriteCode):\n                # coder expects instruction content if available, else full message content\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\")\n                result = await action.run(idea)\n            elif isinstance(action, SimpleWriteTest):\n                # tester expects code in message.content\n                code = message.content if message else \"\"\n                result = await action.run(code)\n            elif isinstance(action, SimpleWriteReview):\n                # reviewer needs both code and tests. Get most recent code/tests from env\n                code_msg, tests_msg = None, None\n                if self.env:\n                    for msg in reversed(self.env.history):\n                        if not code_msg and msg.cause_by == SimpleWriteCode.name:\n                            code_msg = msg\n                        if not tests_msg and msg.cause_by == SimpleWriteTest.name:\n                            tests_msg = msg\n                        if code_msg and tests_msg:\n                            break\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                result = await action.run(code_text, tests_text)\n            elif isinstance(action, SimpleVerify):\n                # verifier obtains latest code/tests similar to reviewer\n                code_msg, tests_msg = None, None\n                if self.env:\n                    for msg in reversed(self.env.history):\n                        if not code_msg and msg.cause_by == SimpleWriteCode.name:\n                            code_msg = msg\n                        if not tests_msg and msg.cause_by == SimpleWriteTest.name:\n                            tests_msg = msg\n                        if code_msg and tests_msg:\n                            break\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                result = await action.run(code_text, tests_text)\n            else:\n                result = await action.run(message) if message else await action.run()\n        except Exception as e:\n            # Catch any unexpected errors, create a failure message describing it\n            err_text = f\"ROLE_EXCEPTION: {self.name} failed with exception {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err_text)\n            result = err_text\n        # Build a Message for the environment describing the result\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message caused by {response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # coder listens to direct user input\n        self._watch([])  # proactive; will be invoked explicitly on initial input\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with explicit delivery and cursors.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # per-role cursor to track which messages have been seen/consumed\n        self.role_cursors: Dict[str, int] = {}\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        # initialize cursor to 0 for this role (no messages consumed yet)\n        self.role_cursors[role.name] = 0\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", \n                          f\"Message [{message.cause_by}] from {message.sent_from}: {message.content[:200]}\")\n    \n    def get_pending_messages_for_role(self, role: Role) -> List[tuple]:\n        \"\"\"Return list of (index, Message) that the role has not yet consumed and that match its triggers.\"\"\"\n        results = []\n        cursor = self.role_cursors.get(role.name, 0)\n        for idx in range(cursor, len(self.history)):\n            msg = self.history[idx]\n            # role can respond if msg.cause_by matches role's triggers\n            if role.triggers_on and msg.cause_by in role.triggers_on:\n                results.append((idx, msg))\n        return results\n    \n    def mark_consumed(self, role: Role, up_to_index: int):\n        \"\"\"Mark messages up to up_to_index (inclusive) as consumed for this role.\"\"\"\n        prev = self.role_cursors.get(role.name, 0)\n        new_cursor = max(prev, up_to_index + 1)\n        self.role_cursors[role.name] = new_cursor\n        if self.tracer:\n            self.tracer.log(\"ENV_CURSOR\", \"Environment\", f\"Role {role.name} cursor advanced to {new_cursor}\")\n\nclass Team:\n    \"\"\"Team of agents working together with improved orchestration, termination and verification logic.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # order of execution for each round\n        self.role_order = []\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team and wire environment references\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n        # stable execution order: coder, tester, reviewer, verifier (by class)\n        # maintain roles in the order they were added if present\n        name_to_role = {r.__class__.__name__: r for r in self.env.roles}\n        ordered = []\n        for cname in (\"SimpleCoder\", \"SimpleTester\", \"SimpleReviewer\", \"SimpleVerifier\"):\n            r = name_to_role.get(cname)\n            if r:\n                ordered.append(r)\n        # fallback to any roles not listed\n        for r in self.env.roles:\n            if r not in ordered:\n                ordered.append(r)\n        self.role_order = ordered\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds with robust termination rules.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        verified = False\n        last_verification_index = -1\n        stable_verification_rounds = 0\n        max_stable_rounds_required = 1  # require verification to remain true across a round to stop\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            round_actions = []\n            # Special handling: on first round, explicitly invoke coder with the initial message\n            for role in self.role_order:\n                # For proactive coder (listens to user input), feed initial_msg on first round\n                if isinstance(role, SimpleCoder) and round_num == 0:\n                    if self.tracer:\n                        self.tracer.log(\"ORCH\", \"Team\", f\"Invoking coder {role.name} with initial idea\")\n                    response = await role.act(initial_msg)\n                    if response:\n                        self.env.publish_message(response)\n                        round_actions.append((role, response))\n                        # mark that coder has consumed initial input\n                        self.env.mark_consumed(role, len(self.env.history)-1)\n                    continue\n                # For other roles and later rounds, gather pending messages\n                pending = self.env.get_pending_messages_for_role(role)\n                if not pending:\n                    if self.tracer:\n                        self.tracer.log(\"ORCH\", \"Team\", f\"No pending messages for {role.name}\")\n                    continue\n                # Process each pending message in order\n                for idx, msg in pending:\n                    if self.tracer:\n                        self.tracer.log(\"ORCH\", \"Team\", f\"{role.name} responding to message idx={idx} cause_by={msg.cause_by}\")\n                    response = await role.act(msg)\n                    # Mark consumed up to this message for this role\n                    self.env.mark_consumed(role, idx)\n                    if response:\n                        self.env.publish_message(response)\n                        round_actions.append((role, response))\n                        # If verifier produced a pass, capture it\n                        if isinstance(role, SimpleVerifier) and isinstance(response.content, str) and \"VERIFICATION_RESULT: PASS\" in response.content:\n                            verified = True\n                            last_verification_index = len(self.env.history) - 1\n            # Post-round analysis: determine termination criteria\n            # If verification happened this round and is still the most recent verification result, count as stable\n            if verified:\n                # ensure that no new code/test messages after verification (to ensure stability)\n                newest_code_or_test_idx = -1\n                for i, msg in enumerate(self.env.history):\n                    if msg.cause_by in (SimpleWriteCode.name, SimpleWriteTest.name):\n                        newest_code_or_test_idx = max(newest_code_or_test_idx, i)\n                if newest_code_or_test_idx <= last_verification_index:\n                    stable_verification_rounds += 1\n                else:\n                    stable_verification_rounds = 0\n                    # If new code/tests appeared after verification, require re-verification\n                    verified = False\n                self.tracer.log(\"VER_STATUS\", \"Team\", f\"verified={verified} stable_rounds={stable_verification_rounds}\")\n            else:\n                stable_verification_rounds = 0\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed with {len(round_actions)} actions\")\n            # Terminate if verification stable for required number of rounds\n            if verified and stable_verification_rounds > max_stable_rounds_required:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification stable; stopping early\")\n                break\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2609), Performs well on avg_failures_per_task (2.8333), Performs well on total_failures (17.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 3 (Score: 5.3704)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class with clear responsibilities and LLM retry wrapper\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 2\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with exponential backoff and simple error detection.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}\")\n                if not self.llm:\n                    # Local fallback\n                    return \"LLM not available: fallback response.\"\n                resp = await self.llm.ask(messages)\n                # Detect common error patterns returned by LLMInterface\n                if isinstance(resp, str) and (resp.startswith(\"Error\") or \"Error communicating\" in resp):\n                    last_err = resp\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {resp[:200]}\")\n                    # retry\n                    continue\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_EXCEPTION\", self.name, f\"Attempt {attempt} exception: {last_err}\")\n        # All retries exhausted\n        return f\"LLM_FAILURE: {last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        raise NotImplementedError()\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for idea (len={len(idea)})\")\n        prompt = (\n            \"You are a professional Python programmer. Produce clean, well-commented, \"\n            \"production-ready Python code for the task described.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Correct syntax\\n\"\n            \"2. Defensive error handling\\n\"\n            \"3. Clear docstrings/comments\\n\"\n            \"4. No surrounding backticks or explanation, only the code\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code size={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing tests for code (len={len(code)})\")\n        snippet = (code or \"\")[:3000]\n        prompt = (\n            \"You are an experienced QA engineer. Write pytest-style tests for the provided Python code.\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Cover normal and edge cases\\n\"\n            \"2. Include negative tests when appropriate\\n\"\n            \"3. Use clear docstrings for each test\\n\"\n            \"4. Return only the test code\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests size={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests and return concise actionable feedback\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing artifacts (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review simulated: consider more input validation and docstrings.\"\n        else:\n            snippet_code = (code or \"\")[:2000]\n            snippet_tests = (tests or \"\")[:2000]\n            prompt = (\n                \"You are a senior engineer performing a concise code + test review.\\n\\n\"\n                f\"Code:\\n{snippet_code}\\n\\nTests:\\n{snippet_tests}\\n\\n\"\n                \"Focus on:\\n\"\n                \"1. Correctness and likely runtime issues\\n\"\n                \"2. Test coverage gaps\\n\"\n                \"3. Practical suggestions (1-3 items)\\n\"\n                \"Return a short review.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            review = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        issues: List[str] = []\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Starting verification\")\n\n        # Basic non-empty checks\n        if not (code and code.strip()):\n            issues.append(\"code_empty\")\n        if not (tests and tests.strip()):\n            issues.append(\"tests_empty\")\n\n        # Syntax checks\n        code_ok = False\n        tests_ok = False\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:200]}\")\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = True\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:200]}\")\n\n        # Cross-reference: ensure tests mention at least one function/class name from code\n        try:\n            code_ast = ast.parse(code or \"\")\n            def_names = {n.name for n in ast.walk(code_ast) if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            tests_ast = ast.parse(tests or \"\")\n            tests_identifiers = {n.id for n in ast.walk(tests_ast) if isinstance(n, ast.Name)}\n            if def_names and def_names.isdisjoint(tests_identifiers):\n                issues.append(\"tests_may_not_reference_code_defs\")\n        except Exception:\n            # already captured syntax errors above, ignore here\n            pass\n\n        verified = (code_ok and tests_ok and not any(i.startswith(\"tests_may_not_reference\") for i in issues))\n        status = {\n            \"verified\": verified,\n            \"issues\": issues,\n            \"code_ok\": code_ok,\n            \"tests_ok\": tests_ok\n        }\n        result_lines = [f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'}\"]\n        if issues:\n            result_lines.append(\"ISSUES: \" + \"; \".join(issues))\n        result = \" | \".join(result_lines)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with explicit watch/trigger logic and idempotency\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        # track processed message ids to avoid reprocessing\n        self._processed_message_ids: Set[str] = set()\n        # env reference will be attached by Team.hire\n        self.env = getattr(self, 'env', None)\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n\n    def _should_respond_to(self, message: Message) -> bool:\n        \"\"\"Decide if this role should respond to the given message\"\"\"\n        if message is None:\n            return False\n        # If message explicitly targeted this role by name/profile\n        if getattr(message, \"send_to\", None):\n            targets = set(message.send_to)\n            if self.name in targets or self.profile in targets:\n                return True\n        # If role watches the causing action type\n        for watched in self.watch_list:\n            if getattr(message, \"cause_by\", \"\") == watched.name:\n                return True\n        # Also ignore messages we've already processed\n        if getattr(message, \"id\", None) in self._processed_message_ids:\n            return False\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action for this role based on the message.\n        Returns a Message or None.\n        This base implementation supports single-action roles.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Preparing to execute {action.name}\")\n\n        # If message provided but role decides it should not respond, skip\n        if message and not self._should_respond_to(message):\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message, 'id', '')}\")\n            return None\n\n        try:\n            # Dispatch to appropriate behavior by action name\n            if action.name == SimpleWriteCode.name:\n                idea = (message.instruct_content or message.content) if message else \"\"\n                out = await action.run(idea)\n                # Create message routing to Tester\n                send_to = {\"SimpleTester\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # Prefer to act on the latest code artifact visible\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                code_text = code_msg.content if code_msg else \"\"\n                out = await action.run(code_text)\n                # Route to Reviewer and Verifier\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # Gather latest code and tests\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                tests_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteTest.name])\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Route review to Verifier and Coder for improvements\n                send_to = {\"SimpleVerifier\", \"SimpleCoder\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # Gather latest code and tests\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                tests_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteTest.name])\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Verification messages are broadcast for team decision\n                send_to = set()  # broadcast\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                out = \"Action executed (noop)\"\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=set()\n                )\n        except Exception as e:\n            # Robust error handling: log and create a failure message\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, f\"Exception during act: {str(e)}\")\n            response = Message(\n                content=f\"ERROR: {str(e)}\",\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to=set()\n            )\n\n        # Mark the input message as processed to avoid reprocessing\n        if message and getattr(message, \"id\", None):\n            self._processed_message_ids.add(message.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message {getattr(response, 'id', '')[:8]} cause_by={response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder initiates on UserInput\n        self._watch([ ])  # empty; will respond to messages explicitly targeted\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watches code-writing actions\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Watches tests to provide review\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        # Watches tests (and reviews implicitly)\n        self._watch([SimpleWriteTest, SimpleWriteReview])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with improved routing\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # quick index of messages by cause_by for artifact lookup\n        self._index_by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        # attach env on the role instance\n        setattr(role, 'env', self)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment and index it\"\"\"\n        # Ensure message has an id (pydantic variant already does)\n        if not getattr(message, \"id\", None):\n            message.id = str(uuid.uuid4())\n        self.history.append(message)\n        # index by cause_by\n        cb = getattr(message, \"cause_by\", \"\")\n        if cb:\n            self._index_by_cause.setdefault(cb, []).append(message)\n        if self.tracer:\n            snippet = (message.content or \"\")[:200].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {message.sent_from} cause_by={cb} send_to={getattr(message, 'send_to', set())} content={snippet}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages: List[Message] = []\n        for msg in self.history:\n            # skip messages the role already processed\n            if getattr(msg, \"id\", None) in getattr(role, \"_processed_message_ids\", set()):\n                continue\n            # explicit routing takes precedence\n            if getattr(msg, \"send_to\", None):\n                if role.name in msg.send_to or role.profile in msg.send_to:\n                    relevant_messages.append(msg)\n                    continue\n            # otherwise use watch_list matching cause_by\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\n    def get_latest_artifact(self, cause_names: List[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names\"\"\"\n        for name in cause_names:\n            msgs = self._index_by_cause.get(name, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together with robust orchestration and termination logic\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # track verification stability: require N consecutive PASS to accept\n        self._consecutive_verification_passes = 0\n        self._verification_threshold = 2  # require two consecutive passes to avoid fluke\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds with clear orchestration, retries, and termination checks\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # Initial message with the idea targeted at the coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"Alice\", \"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verified_overall = False\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            new_messages_this_round = 0\n\n            # Iterate over a fixed, orchestrated order to reduce race conditions:\n            orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    # get messages that role should handle\n                    incoming = self.env.get_messages_for_role(role)\n                    if not incoming:\n                        # allow coder to be triggered on first round by initial message\n                        if RoleClass is SimpleCoder and round_num == 1:\n                            incoming = [initial_msg]\n                    # Process each incoming message (deterministic order: newest first)\n                    for msg in incoming:\n                        # Attempt action with limited retries\n                        attempts = 0\n                        max_attempts = 2\n                        while attempts < max_attempts:\n                            try:\n                                attempts += 1\n                                response = await role.act(msg)\n                                if response:\n                                    self.env.publish_message(response)\n                                    new_messages_this_round += 1\n                                    # If verifier produced a PASS, update counters\n                                    if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (response.content or \"\"):\n                                        self._consecutive_verification_passes += 1\n                                        self.tracer.log(\"VERIFIER_PASS\", \"Team\", f\"Consecutive passes={self._consecutive_verification_passes}\")\n                                    elif isinstance(role, SimpleVerifier):\n                                        # reset if fail\n                                        self._consecutive_verification_passes = 0\n                                break  # success or handled, break retry loop\n                            except Exception as e:\n                                # Log and decide to retry\n                                self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Attempt {attempts} failed: {str(e)}\")\n                                if attempts >= max_attempts:\n                                    # produce an error message into environment\n                                    err_msg = Message(\n                                        content=f\"ERROR: role {role.name} failed after {attempts} attempts: {str(e)}\",\n                                        role=role.profile,\n                                        cause_by=\"RoleRunError\",\n                                        sent_from=role.name,\n                                        send_to=set()\n                                    )\n                                    self.env.publish_message(err_msg)\n                                    new_messages_this_round += 1\n                                else:\n                                    # small implicit backoff - next loop iteration will retry\n                                    continue\n\n            # After all roles, determine termination conditions\n            if self._consecutive_verification_passes >= self._verification_threshold:\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable for {self._verification_threshold} rounds, stopping\")\n                verified_overall = True\n                break\n\n            if new_messages_this_round == 0:\n                # no progress made this round; stop to avoid infinite loop\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No new messages produced this round; stopping early\")\n                break\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} completed with {new_messages_this_round} new messages\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' ended. Rounds executed={round_num}. Messages exchanged={len(self.env.history)}. Verified={verified_overall}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2222), Performs well on avg_failures_per_task (3.5000), Performs well on total_failures (21.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 4 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport random\nfrom typing import Callable, Tuple\n\nRETRY_ATTEMPTS = 3\nRETRY_BACKOFF_BASE = 0.5  # seconds\nMAX_MESSAGE_ATTEMPTS = 5\n\nclass Action(ABC):\n    \"\"\"Base action class with retry and error handling for LLM/API calls.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries and exponential backoff. Returns response or raises.\"\"\"\n        if not self.llm:\n            # No LLM configured; return sentinel to allow caller to fallback\n            return \"LLM_NOT_AVAILABLE\"\n        last_err = None\n        for attempt in range(1, RETRY_ATTEMPTS + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}\")\n                resp = await self.llm.ask(messages)\n                # Basic failure detection: LLMInterface returns string starting with \"Error\"\n                if isinstance(resp, str) and resp.startswith(\"Error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff with jitter\n                await asyncio.sleep(RETRY_BACKOFF_BASE * (2 ** (attempt - 1)) + random.random() * 0.1)\n        # All retries failed\n        raise RuntimeError(f\"LLM call failed after {RETRY_ATTEMPTS} attempts: {last_err}\")\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce a compilable code artifact from a short instruction.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"idea={(idea or '')[:120]}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a single Python module that implements the described functionality. \"\n            \"Keep functions small and documented. Ensure code is parseable by ast.parse and does not include extraneous text.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n1. Clean, functional Python code\\n2. Proper error handling\\n3. Docstrings and comments\\n4. Production-ready\\n\\n\"\n            \"Provide only the Python code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python developer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = None\n        try:\n            resp = await self._llm_call_with_retries(messages)\n            if resp == \"LLM_NOT_AVAILABLE\":\n                raise RuntimeError(\"LLM not available\")\n            code = resp\n        except Exception as e:\n            # Fallback minimal code to keep pipeline moving\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, f\"LLM failure: {str(e)[:200]}\")\n            code = (\n                f\"# Fallback implementation for: {idea}\\n\\n\"\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n\n        # Validate that generated code parses\n        parsed_ok = False\n        try:\n            import ast\n            ast.parse(code or \"\")\n            parsed_ok = True\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"AST parse failed: {str(e)[:200]}\")\n            # Attempt a minimal corrective step: wrap in a safe function if possible\n            try:\n                corrective = \"def _safe_wrapper():\\n\"\n                for line in (code or \"\").splitlines():\n                    corrective += \"    \" + line + \"\\n\"\n                corrective += \"\\n\"\n                import ast as _ast\n                _ast.parse(corrective)\n                code = corrective\n                parsed_ok = True\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_VALIDATION_FIX\", self.name, \"Applied simple wrapper to fix parse issues\")\n            except Exception:\n                parsed_ok = False\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"len={len(code or '')}; parsed_ok={parsed_ok}\")\n        return code or \"\"\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produce pytest-style tests targeting functions present in the code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        # Extract function names to direct tests\n        func_names = []\n        try:\n            import ast\n            mod = ast.parse(code or \"\")\n            func_names = [n.name for n in ast.walk(mod) if isinstance(n, ast.FunctionDef)]\n        except Exception:\n            func_names = []\n\n        prompt = (\n            \"You are a QA engineer that writes pytest tests. Produce pytest tests for the given module. \"\n            \"If function names are available, write at least one positive and one negative test per function. \"\n            \"Include docstrings for each test. Provide only the Python test code.\"\n        )\n        if func_names:\n            prompt += f\"\\nTarget functions: {', '.join(func_names[:8])}\"\n        prompt += \"\\n\\nCode:\\n\" + (code[:2000] if code else \"(empty)\")\n\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer who writes pytest tests.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = None\n        try:\n            resp = await self._llm_call_with_retries(messages)\n            if resp == \"LLM_NOT_AVAILABLE\":\n                raise RuntimeError(\"LLM not available\")\n            tests = resp\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, f\"LLM failure: {str(e)[:200]}\")\n            tests = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder_exists():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n\n        # Validate tests parse\n        tests_ok = False\n        try:\n            import ast\n            ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n        except Exception as e:\n            tests_ok = False\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Tests AST parse failed: {str(e)[:200]}\")\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"len={len(tests or '')}; parsed_ok={tests_ok}\")\n        return tests or \"\"\n\nclass SimpleWriteReview(Action):\n    \"\"\"Produce concise, actionable review of code and tests.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Basic sanity checks performed. Consider adding edge-case tests and clearer error handling.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Provide a concise actionable review focused on code quality, test completeness, \"\n                \"and likely bugs. Provide a short prioritized list of suggestions.\\n\\n\"\n                f\"Code:\\n{code[:1500]}\\n\\nTests:\\n{tests[:1500]}\"\n            )\n            messages = [{\"role\": \"system\", \"content\": \"You are a senior code reviewer.\"},\n                        {\"role\": \"user\", \"content\": prompt}]\n            try:\n                resp = await self._llm_call_with_retries(messages)\n                if resp == \"LLM_NOT_AVAILABLE\":\n                    raise RuntimeError(\"LLM not available\")\n                review = resp\n            except Exception as e:\n                review = \"Automated review fallback: Unable to contact reviewer LLM. Please perform a manual review.\"\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_FALLBACK\", self.name, f\"LLM failure: {str(e)[:200]}\")\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Verify syntactic and basic semantic alignment between code and tests.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"\")\n        diagnostics = []\n        code_ok = False\n        tests_ok = False\n        try:\n            import ast\n            code_ast = ast.parse(code or \"\")\n            defs = [n for n in code_ast.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))]\n            if defs:\n                code_ok = True\n                diagnostics.append(f\"code_defs:{len(defs)}\")\n            else:\n                diagnostics.append(\"code_defs:none\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:180]}\")\n\n        try:\n            import ast\n            tests_ast = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            if tests_ok and code_ok:\n                test_names = {n.id for n in ast.walk(tests_ast) if isinstance(n, ast.Name)}\n                code_names = {n.name for n in ast.walk(code_ast) if isinstance(n, ast.FunctionDef)}\n                referenced = code_names & test_names\n                diagnostics.append(f\"tests_refs:{len(referenced)}\")\n                if not referenced:\n                    diagnostics.append(\"tests_refs:none\")\n            else:\n                diagnostics.append(\"tests_parse:empty_or_invalid\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:180]}\")\n\n        verified = code_ok and tests_ok and any(\"tests_refs\" in d and not d.endswith(\":0\") for d in diagnostics) == False or (code_ok and tests_ok)\n        # The above line ensures we require both parseable code and tests; we keep it lenient but informative.\n        result = f\"VERIFICATION_RESULT: {'PASS' if (code_ok and tests_ok) else 'FAIL'} | \" + \"; \".join(diagnostics)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with explicit responsibilities and inbox semantics.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # list of action names to watch\n    env: Optional[\"Environment\"] = None  # assigned at hire\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, action_types: List[Type[Action]]):\n        self.watch_list = [t.name for t in action_types]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"action={action.name}; msg_id={(message.id if message else 'None')}\")\n        try:\n            # Clear responsibility mapping here\n            if isinstance(action, SimpleWriteCode):\n                prompt = (message.instruct_content if (message and getattr(message, \"instruct_content\", None)) else (message.content if message else \"\"))\n                result = await action.run(prompt or \"\")\n            elif isinstance(action, SimpleWriteTest):\n                code_text = message.content if message else \"\"\n                result = await action.run(code_text)\n            elif isinstance(action, SimpleWriteReview):\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            elif isinstance(action, SimpleVerify):\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            else:\n                result = \"Action completed\"\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, f\"exception: {str(e)[:200]}\")\n            result = f\"ERROR: {str(e)}\"\n\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n\n        # Mark processed to avoid duplicate processing by same role\n        if message and self.env:\n            self.env.mark_processed(message, self)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"created_msg_id={getattr(response, 'id', 'N/A')}; len={len(result)}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Tracks messages, processing state, and attempts to reduce race conditions.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        self._processed: Dict[str, Set[str]] = {}  # message.id -> set(role.name)\n        self._attempts: Dict[str, int] = {}       # message.id -> attempts count\n\n    def add_role(self, role: Role):\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"{role.name}:{role.profile}\")\n\n    def publish_message(self, message: Message):\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        self._attempts.setdefault(message.id, 0)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"from={message.sent_from}; cause_by={message.cause_by}; snippet={(message.content or '')[:140]}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"msg={message.id}; by={role.name}\")\n\n    def increment_attempt(self, message: Message) -> int:\n        self._attempts[message.id] = self._attempts.get(message.id, 0) + 1\n        return self._attempts[message.id]\n\n    def get_unprocessed_messages_for_role(self, role: Role) -> List[Message]:\n        results = []\n        for msg in self.history:\n            if msg.cause_by in role.watch_list:\n                processed = self._processed.get(msg.id, set())\n                if role.name not in processed:\n                    results.append(msg)\n        return results\n\n    def find_latest_pair(self, code_cause: str, tests_cause: str) -> Tuple[Optional[Message], Optional[Message]]:\n        code_msg = None\n        tests_msg = None\n        for msg in reversed(self.history):\n            if not code_msg and msg.cause_by == code_cause:\n                code_msg = msg\n            if not tests_msg and msg.cause_by == tests_cause:\n                tests_msg = msg\n            if code_msg and tests_msg:\n                break\n        return code_msg, tests_msg\n\nclass Team:\n    \"\"\"Team orchestrator with clear pipeline, explicit watch/trigger logic, and robust termination.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self.pipeline: List[Type[Role]] = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"idea={idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"up_to_rounds={n_round}\")\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        last_verified_round = -1\n        last_history_len = len(self.env.history)\n\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"round={round_num}\")\n            for role_type in self.pipeline:\n                for role in [r for r in self.env.roles if isinstance(r, role_type)]:\n                    # Determine inbox for this role\n                    if isinstance(role, SimpleCoder) and round_num == 1:\n                        inbox = [initial_msg]\n                    else:\n                        inbox = self.env.get_unprocessed_messages_for_role(role)\n\n                    for msg in inbox:\n                        attempts = self.env.increment_attempt(msg)\n                        if attempts > MAX_MESSAGE_ATTEMPTS:\n                            if self.tracer:\n                                self.tracer.log(\"ENV_SKIP\", \"Environment\", f\"skip msg={msg.id} for role={role.name} after_attempts={attempts}\")\n                            self.env.mark_processed(msg, role)\n                            continue\n\n                        response = await role.act(msg)\n                        if response:\n                            self.env.publish_message(response)\n                            # If verifier produced PASS, do confirmation\n                            if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (response.content or \"\"):\n                                # Run a confirmation verification locally to avoid transient success\n                                try:\n                                    verifier_action = role.actions[0]\n                                    code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                                    confirm = await verifier_action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n                                    if isinstance(confirm, str) and \"VERIFICATION_RESULT: PASS\" in confirm:\n                                        verified = True\n                                        last_verified_round = round_num\n                                        self.tracer.log(\"VERIFIED_CONFIRMED\", \"Team\", f\"round={round_num}\")\n                                    else:\n                                        self.tracer.log(\"VERIFIED_REJECTED\", \"Team\", f\"round={round_num}; confirm={confirm[:200]}\")\n                                except Exception as e:\n                                    if self.tracer:\n                                        self.tracer.log(\"VERIFIED_ERROR\", \"Team\", f\"confirm exception: {str(e)[:200]}\")\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"round={round_num}\")\n            # Check for stable verification: require verification and no new messages after one extra round\n            if verified:\n                # If history length hasn't changed since verification, we can stop\n                if len(self.env.history) == last_history_len:\n                    self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"stable verified at round={round_num}\")\n                    break\n                else:\n                    # record current history length and allow one more round\n                    last_history_len = len(self.env.history)\n            else:\n                last_history_len = len(self.env.history)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 4.6667)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\nimport asyncio\nimport time\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\n# Improved multi-agent logic with clearer roles, robust communication,\n# explicit watch/trigger logic, verification, and retry/error handling.\n\n# Safe deterministic fallbacks used when LLM is unavailable or returns errors\n_DEFAULT_CODE = (\n    \"def solve(input_data):\\n\"\n    \"    '''Safe fallback implementation: returns the input unchanged.'''\\n\"\n    \"    return input_data\\n\"\n)\n_DEFAULT_TESTS = (\n    \"def test_solve_basic():\\n\"\n    \"    try:\\n\"\n    \"        # attempt to import solve if present\\n\"\n    \"        from __main__ import solve\\n\"\n    \"    except Exception:\\n\"\n    \"        assert True\\n\"\n    \"        return\\n\"\n    \"    assert solve(1) == 1\\n\"\n    \"    assert solve('a') == 'a'\\n\"\n)\n\ndef _strip_code_fences(text: Optional[str]) -> str:\n    \"\"\"Strip common markdown code fences and leading/trailing whitespace.\"\"\"\n    if not text:\n        return \"\"\n    t = text.strip()\n    # remove typical fences and leading language markers\n    if t.startswith(\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to combined_score\n\n\n### Program D2 (Score: 4.6667)\n```python\n# python\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nfrom typing import Dict, Set\n\nclass Action(ABC):\n    \"\"\"Base action with clear responsibilities, LLM retry logic, and graceful failure reporting.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    retry_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _call_llm_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries, logging, and backoff. Returns a string (or structured error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # Deterministic fallback to avoid raising\n                    return \"LLM_UNAVAILABLE_FALLBACK\"\n                resp = await self.llm.ask(messages)\n                # LLMInterface returns strings; treat strings starting with \"Error\" as failures\n                if isinstance(resp, str) and resp.startswith(\"Error\"):\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = e\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {str(e)}\")\n                # Exponential backoff\n                await asyncio.sleep(self.retry_backoff * attempt)\n        # After retries, return structured error so downstream can handle without exception\n        err_msg = f\"ERROR: LLM failed after {self.max_retries} attempts: {str(last_err)}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FAIL\", self.name, err_msg)\n        return err_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce a code artifact from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating code for idea: {idea[:120]}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a single Python module that implements the described functionality.\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, functional Python code\\n\"\n            \"- Proper error handling\\n\"\n            \"- Docstrings/comments\\n\"\n            \"- Parsable by ast.parse\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Return only the Python code, no wrappers or explanation.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        # Quick static validation: try parse; if LLM returned an error string starting with \"ERROR:\", fallback to minimal code\n        parsed_ok = False\n        if isinstance(result, str) and not result.startswith(\"ERROR:\") and result.strip():\n            try:\n                ast.parse(result)\n                parsed_ok = True\n            except Exception as e:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_VALIDATION\", self.name, f\"AST parse failed: {str(e)}\")\n        if not parsed_ok:\n            # Fallback minimal safe module\n            fallback = (\n                f\"# Fallback implementation for idea: {idea}\\n\"\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback implementation\")\n            return fallback\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code length={len(result)}\")\n        return result\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produce pytest-style tests targeting the provided code artifact.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating tests for code ({len(code) if code else 0} chars)\")\n        truncated = (code or \"\")[:2000]\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided module.\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest\\n\"\n            \"- Cover edge cases and error conditions where possible\\n\"\n            \"- Include docstrings for each test\\n\"\n            \"- Reference functions found in the module when possible\\n\\n\"\n            f\"Code:\\n{truncated}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        # Validate tests parse\n        tests_ok = False\n        if isinstance(result, str) and not result.startswith(\"ERROR:\") and result.strip():\n            try:\n                ast.parse(result)\n                tests_ok = True\n            except Exception as e:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_VALIDATION\", self.name, f\"Tests AST parse failed: {str(e)}\")\n        if not tests_ok:\n            fallback = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback tests\")\n            return fallback\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests length={len(result)}\")\n        return result\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests, return actionable message or request changes.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing artifacts (human={self.is_human})\")\n        if self.is_human:\n            # Simulated human review\n            review = \"APPROVE: Human review passed with minor suggestions: add more edge-case tests.\"\n        else:\n            prompt = (\n                \"You are a senior code reviewer. Provide a concise review of the code and tests.\\n\\n\"\n                \"Deliverable:\\n\"\n                \"- If issues that must be fixed exist, start response with 'REQUEST_CHANGE:' followed by required fixes.\\n\"\n                \"- Otherwise start with 'APPROVE:' and a brief rationale.\\n\\n\"\n                f\"Code:\\n{(code or '')[:1500]}\\n\\nTests:\\n{(tests or '')[:1500]}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            result = await self._call_llm_with_retries(messages)\n            if isinstance(result, str) and result.startswith(\"ERROR:\"):\n                # Fallback to conservative request change\n                review = \"REQUEST_CHANGE: Automated reviewer unavailable; please perform manual review.\"\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Reviewer LLM unavailable\")\n            else:\n                review = result\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Deterministic verification combining static checks and heuristics.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Performing verification checks\")\n        diagnostics = []\n        code_ok = False\n        tests_ok = False\n\n        # Code parse and basic heuristics\n        try:\n            code_ast = ast.parse(code or \"\")\n            defs = [n for n in code_ast.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))]\n            if defs:\n                code_ok = True\n                diagnostics.append(f\"code_defs:{len(defs)}\")\n            else:\n                diagnostics.append(\"code_defs:0\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n\n        # Tests parse and heuristics\n        try:\n            tests_ast = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            if tests_ok and code_ok:\n                # Check whether tests reference code functions\n                code_names = {n.name for n in ast.walk(code_ast) if isinstance(n, ast.FunctionDef)}\n                test_names = {n.id for n in ast.walk(tests_ast) if isinstance(n, ast.Name)}\n                referenced = code_names & test_names\n                diagnostics.append(f\"tests_refs:{len(referenced)}\")\n                if not referenced:\n                    diagnostics.append(\"tests_refs:0_match\")\n            else:\n                diagnostics.append(\"tests_parse_or_empty\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        verified = code_ok and tests_ok and not any(\"parse_error\" in d for d in diagnostics)\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(diagnostics)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"Base role with explicit responsibilities, watch/trigger logic, failure tracking, and clear outputs.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: Set[str] = set()  # names of causes to listen for\n    responsibility: str = \"Undefined\"\n    max_failures_before_escalation: int = 2\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = set()\n        self.responsibility = kwargs.get(\"responsibility\", self.responsibility)\n        self.failure_count = 0\n        # env will be assigned by Team.hire\n        self.env: Optional[Environment] = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[str]):\n        \"\"\"Provide action names or cause strings that this role responds to.\"\"\"\n        self.watch_list = set(actions)\n\n    def should_act_on(self, message: Optional[Message]) -> bool:\n        \"\"\"Decide whether to act on a given message.\"\"\"\n        if message is None:\n            return False\n        # Direct addressing\n        send_to = getattr(message, \"send_to\", None)\n        if send_to and (self.profile in send_to or self.name in send_to):\n            return True\n        # Cause-based matching\n        if getattr(message, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action for the role with error handling and failure accounting.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Invoking {action.name} for message_id={(getattr(message,'id',None))}\")\n        try:\n            # Map inputs per action type\n            if isinstance(action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or (message.content if message else \"\")\n                result = await action.run(idea or \"\")\n            elif isinstance(action, SimpleWriteTest):\n                code_src = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(code_src)\n            elif isinstance(action, SimpleWriteReview):\n                # Attempt to collect latest code & tests\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name) if self.env else (None, None)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            elif isinstance(action, SimpleVerify):\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name) if self.env else (None, None)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            else:\n                # Generic\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, f\"Unhandled exception: {str(e)}\")\n            result = f\"ERROR: Role {self.name} exception: {str(e)}\"\n\n        # Account failure vs success\n        if isinstance(result, str) and result.startswith(\"ERROR:\"):\n            self.failure_count += 1\n        else:\n            self.failure_count = 0\n\n        # Build message\n        out_msg = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name,\n            sent_from=self.name,\n            send_to=set()\n        )\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message {getattr(out_msg,'id',None)} cause_by={out_msg.cause_by}\")\n\n        # Escalate if repeated failures (log only; escalation policy can be extended)\n        if self.failure_count > self.max_failures_before_escalation and self.context and self.context.tracer:\n            self.context.tracer.log(\"ESCALATION\", self.name, f\"Failure count {self.failure_count} exceeded threshold\")\n\n        return out_msg\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    responsibility = \"Turn idea into initial code artifact\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder listens to explicit user input or change requests\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    responsibility = \"Produce tests for the latest code artifact\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    responsibility = \"Review code and tests and request changes or approve\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    responsibility = \"Deterministically verify artifacts and declare pass/fail\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest.name, SimpleWriteCode.name])\n\n\nclass Environment:\n    \"\"\"Environment manages messages, processing state, and routing logic.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track which roles processed which message ids\n        self._processed: Dict[str, Set[str]] = {}\n        # attempts to avoid livelock\n        self._attempts: Dict[str, int] = {}\n\n    def add_role(self, role: Role):\n        self.roles.append(role)\n        role.env = self\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure message has id\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        self._attempts.setdefault(message.id, 0)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message {getattr(message,'id','')} from {message.sent_from}: {str(message.content)[:150]} | cause_by={message.cause_by}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"Message {message.id} processed by {role.name}\")\n\n    def increment_attempt(self, message: Message) -> int:\n        self._attempts[message.id] = self._attempts.get(message.id, 0) + 1\n        return self._attempts[message.id]\n\n    def get_unprocessed_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages matching role.watch_list or direct addressing that haven't been processed by role.\"\"\"\n        results: List[Message] = []\n        for msg in self.history:\n            # skip messages already processed by this role\n            processed = self._processed.get(msg.id, set())\n            if role.name in processed:\n                continue\n            # direct addressing\n            send_to = getattr(msg, \"send_to\", None)\n            if send_to and (role.profile in send_to or role.name in send_to):\n                results.append(msg)\n                continue\n            # cause matching\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                results.append(msg)\n        return results\n\n    def find_latest_pair(self, code_cause: str, tests_cause: str):\n        \"\"\"Find the latest code and test messages (best-effort).\"\"\"\n        code_msg = None\n        tests_msg = None\n        for msg in reversed(self.history):\n            if not code_msg and getattr(msg, \"cause_by\", None) == code_cause:\n                code_msg = msg\n            if not tests_msg and getattr(msg, \"cause_by\", None) == tests_cause:\n                tests_msg = msg\n            if code_msg and tests_msg:\n                break\n        return code_msg, tests_msg\n\n\nclass Team:\n    \"\"\"Orchestrates the multi-agent pipeline with explicit termination, verification confirmation, and stagnation detection.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # pipeline order enforces clear responsibilities\n        self.pipeline = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        self.max_rounds_without_progress = 3\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # initial user message broadcast to all roles\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=set([r.profile for r in self.env.roles]) if self.env.roles else set()\n        )\n        # publish initial message (roles will be added after hire in the usual flow; ensure send_to can be empty safely)\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        rounds_since_progress = 0\n        last_history_len = len(self.env.history)\n\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            progress_this_round = False\n\n            # For each pipeline stage, process roles deterministically\n            for role_cls in self.pipeline:\n                for role in [r for r in self.env.roles if isinstance(r, role_cls)]:\n                    # Gather unprocessed messages for this role (or allow coder to act on initial)\n                    inbox = self.env.get_unprocessed_messages_for_role(role)\n                    # Special-case coder to allow acting on user input in first round even if not in watch_list\n                    if isinstance(role, SimpleCoder) and round_num == 1:\n                        # ensure initial message is considered\n                        for msg in reversed(self.env.history):\n                            if getattr(msg, \"cause_by\", \"\") == \"UserInput\":\n                                if msg not in inbox:\n                                    inbox.insert(0, msg)\n                                break\n\n                    # Process messages one at a time to remain deterministic\n                    for msg in list(inbox):\n                        # Avoid repeated attempts causing livelock\n                        attempts = self.env.increment_attempt(msg)\n                        if attempts > 6:\n                            # mark processed to move on\n                            self.env.mark_processed(msg, role)\n                            if self.tracer:\n                                self.tracer.log(\"ENV_SKIP\", \"Team\", f\"Skipping message {msg.id} for {role.name} after {attempts} attempts\")\n                            continue\n\n                        # Guard: do not let a role process its own previous message\n                        if getattr(msg, \"sent_from\", None) == role.name:\n                            self.env.mark_processed(msg, role)\n                            continue\n\n                        try:\n                            response = await role.act(msg)\n                        except Exception as e:\n                            # Unexpected error: produce an error message and continue\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {str(e)}\")\n                            response = Message(\n                                content=f\"ERROR: Unexpected exception in role {role.name}: {str(e)}\",\n                                role=role.profile,\n                                cause_by=\"EXCEPTION\",\n                                sent_from=role.name,\n                                send_to=set()\n                            )\n\n                        if response:\n                            # Route response to appropriate next roles\n                            if isinstance(role, SimpleCoder):\n                                response.send_to = set([SimpleTester.profile])\n                            elif isinstance(role, SimpleTester):\n                                response.send_to = set([SimpleReviewer.profile, SimpleVerifier.profile])\n                            elif isinstance(role, SimpleReviewer):\n                                # If reviewer requested change, send to coder, otherwise to verifier\n                                content_upper = (response.content or \"\").strip().upper()\n                                if content_upper.startswith(\"REQUEST_CHANGE\"):\n                                    response.send_to = set([SimpleCoder.profile])\n                                    response.cause_by = \"REQUEST_CHANGE\"\n                                else:\n                                    response.send_to = set([SimpleVerifier.profile])\n                            elif isinstance(role, SimpleVerifier):\n                                # Broadcast verdict\n                                response.send_to = set([r.profile for r in self.env.roles])\n\n                            self.env.publish_message(response)\n                            self.env.mark_processed(msg, role)\n                            progress_this_round = True\n\n                            # If verifier produced a PASS, confirm deterministically\n                            if isinstance(role, SimpleVerifier) and isinstance(response.content, str) and \"VERIFICATION_RESULT: PASS\" in response.content:\n                                # confirm using verifier action on latest artifacts\n                                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                                verifier_action = role.actions[0] if role.actions else None\n                                confirmed = False\n                                if verifier_action:\n                                    try:\n                                        confirm_text = await verifier_action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n                                        if isinstance(confirm_text, str) and \"VERIFICATION_RESULT: PASS\" in confirm_text:\n                                            confirmed = True\n                                    except Exception as e:\n                                        if self.tracer:\n                                            self.tracer.log(\"VERIFY_CONFIRM_ERROR\", \"Team\", f\"Confirmation attempt error: {str(e)}\")\n                                if confirmed:\n                                    verified = True\n                                    if self.tracer:\n                                        self.tracer.log(\"VERIFIED_CONFIRMED\", \"Team\", f\"Verification confirmed in round {round_num}\")\n                                else:\n                                    if self.tracer:\n                                        self.tracer.log(\"VERIFIED_REJECTED\", \"Team\", f\"Verification not confirmed in round {round_num}\")\n\n            # Round end bookkeeping\n            if len(self.env.history) == last_history_len:\n                rounds_since_progress += 1\n            else:\n                rounds_since_progress = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} completed; progress={progress_this_round}; history_len={len(self.env.history)}\")\n\n            # Termination conditions\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verified; stopping in round {round_num}\")\n                break\n            if rounds_since_progress >= self.max_rounds_without_progress:\n                self.tracer.log(\"TEAM_HANG_DETECT\", \"Team\", f\"No progress for {rounds_since_progress} rounds; stopping to avoid livelock\")\n                break\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to combined_score\n\n\n### Program D3 (Score: 4.6667)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nfrom typing import Tuple\n\n# Focus: clear roles, robust communication (watch + explicit routing), verification stability, and strong fallbacks.\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry and sanitization utilities.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_llm_retries: int = 3\n    retry_backoff: float = 0.75  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    def _log(self, event_type: str, details: str):\n        if self.context and self.context.tracer:\n            self.context.tracer.log(event_type, self.name, details)\n\n    def _sanitize_text(self, text: str) -> str:\n        \"\"\"Remove common non-code wrappers like markdown fences.\"\"\"\n        if not isinstance(text, str):\n            return \"\"\n        t = text.strip()\n        # Strip triple backtick blocks if present\n        if t.startswith(\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 5.3704, Type: Migrant)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class with clear responsibilities and LLM retry wrapper\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 2\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with exponential backoff and simple error detection.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}\")\n                if not self.llm:\n                    # Local fallback\n                    return \"LLM not available: fallback response.\"\n                resp = await self.llm.ask(messages)\n                # Detect common error patterns returned by LLMInterface\n                if isinstance(resp, str) and (resp.startswith(\"Error\") or \"Error communicating\" in resp):\n                    last_err = resp\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {resp[:200]}\")\n                    # retry\n                    continue\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_EXCEPTION\", self.name, f\"Attempt {attempt} exception: {last_err}\")\n        # All retries exhausted\n        return f\"LLM_FAILURE: {last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        raise NotImplementedError()\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for idea (len={len(idea)})\")\n        prompt = (\n            \"You are a professional Python programmer. Produce clean, well-commented, \"\n            \"production-ready Python code for the task described.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Correct syntax\\n\"\n            \"2. Defensive error handling\\n\"\n            \"3. Clear docstrings/comments\\n\"\n            \"4. No surrounding backticks or explanation, only the code\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code size={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing tests for code (len={len(code)})\")\n        snippet = (code or \"\")[:3000]\n        prompt = (\n            \"You are an experienced QA engineer. Write pytest-style tests for the provided Python code.\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Cover normal and edge cases\\n\"\n            \"2. Include negative tests when appropriate\\n\"\n            \"3. Use clear docstrings for each test\\n\"\n            \"4. Return only the test code\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests size={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests and return concise actionable feedback\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing artifacts (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review simulated: consider more input validation and docstrings.\"\n        else:\n            snippet_code = (code or \"\")[:2000]\n            snippet_tests = (tests or \"\")[:2000]\n            prompt = (\n                \"You are a senior engineer performing a concise code + test review.\\n\\n\"\n                f\"Code:\\n{snippet_code}\\n\\nTests:\\n{snippet_tests}\\n\\n\"\n                \"Focus on:\\n\"\n                \"1. Correctness and likely runtime issues\\n\"\n                \"2. Test coverage gaps\\n\"\n                \"3. Practical suggestions (1-3 items)\\n\"\n                \"Return a short review.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            review = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        issues: List[str] = []\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Starting verification\")\n\n        # Basic non-empty checks\n        if not (code and code.strip()):\n            issues.append(\"code_empty\")\n        if not (tests and tests.strip()):\n            issues.append(\"tests_empty\")\n\n        # Syntax checks\n        code_ok = False\n        tests_ok = False\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:200]}\")\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = True\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:200]}\")\n\n        # Cross-reference: ensure tests mention at least one function/class name from code\n        try:\n            code_ast = ast.parse(code or \"\")\n            def_names = {n.name for n in ast.walk(code_ast) if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            tests_ast = ast.parse(tests or \"\")\n            tests_identifiers = {n.id for n in ast.walk(tests_ast) if isinstance(n, ast.Name)}\n            if def_names and def_names.isdisjoint(tests_identifiers):\n                issues.append(\"tests_may_not_reference_code_defs\")\n        except Exception:\n            # already captured syntax errors above, ignore here\n            pass\n\n        verified = (code_ok and tests_ok and not any(i.startswith(\"tests_may_not_reference\") for i in issues))\n        status = {\n            \"verified\": verified,\n            \"issues\": issues,\n            \"code_ok\": code_ok,\n            \"tests_ok\": tests_ok\n        }\n        result_lines = [f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'}\"]\n        if issues:\n            result_lines.append(\"ISSUES: \" + \"; \".join(issues))\n        result = \" | \".join(result_lines)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with explicit watch/trigger logic and idempotency\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        # track processed message ids to avoid reprocessing\n        self._processed_message_ids: Set[str] = set()\n        # env reference will be attached by Team.hire\n        self.env = getattr(self, 'env', None)\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n\n    def _should_respond_to(self, message: Message) -> bool:\n        \"\"\"Decide if this role should respond to the given message\"\"\"\n        if message is None:\n            return False\n        # If message explicitly targeted this role by name/profile\n        if getattr(message, \"send_to\", None):\n            targets = set(message.send_to)\n            if self.name in targets or self.profile in targets:\n                return True\n        # If role watches the causing action type\n        for watched in self.watch_list:\n            if getattr(message, \"cause_by\", \"\") == watched.name:\n                return True\n        # Also ignore messages we've already processed\n        if getattr(message, \"id\", None) in self._processed_message_ids:\n            return False\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action for this role based on the message.\n        Returns a Message or None.\n        This base implementation supports single-action roles.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Preparing to execute {action.name}\")\n\n        # If message provided but role decides it should not respond, skip\n        if message and not self._should_respond_to(message):\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message, 'id', '')}\")\n            return None\n\n        try:\n            # Dispatch to appropriate behavior by action name\n            if action.name == SimpleWriteCode.name:\n                idea = (message.instruct_content or message.content) if message else \"\"\n                out = await action.run(idea)\n                # Create message routing to Tester\n                send_to = {\"SimpleTester\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # Prefer to act on the latest code artifact visible\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                code_text = code_msg.content if code_msg else \"\"\n                out = await action.run(code_text)\n                # Route to Reviewer and Verifier\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # Gather latest code and tests\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                tests_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteTest.name])\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Route review to Verifier and Coder for improvements\n                send_to = {\"SimpleVerifier\", \"SimpleCoder\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # Gather latest code and tests\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                tests_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteTest.name])\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Verification messages are broadcast for team decision\n                send_to = set()  # broadcast\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                out = \"Action executed (noop)\"\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=set()\n                )\n        except Exception as e:\n            # Robust error handling: log and create a failure message\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, f\"Exception during act: {str(e)}\")\n            response = Message(\n                content=f\"ERROR: {str(e)}\",\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to=set()\n            )\n\n        # Mark the input message as processed to avoid reprocessing\n        if message and getattr(message, \"id\", None):\n            self._processed_message_ids.add(message.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message {getattr(response, 'id', '')[:8]} cause_by={response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder initiates on UserInput\n        self._watch([ ])  # empty; will respond to messages explicitly targeted\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watches code-writing actions\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Watches tests to provide review\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        # Watches tests (and reviews implicitly)\n        self._watch([SimpleWriteTest, SimpleWriteReview])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with improved routing\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # quick index of messages by cause_by for artifact lookup\n        self._index_by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        # attach env on the role instance\n        setattr(role, 'env', self)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment and index it\"\"\"\n        # Ensure message has an id (pydantic variant already does)\n        if not getattr(message, \"id\", None):\n            message.id = str(uuid.uuid4())\n        self.history.append(message)\n        # index by cause_by\n        cb = getattr(message, \"cause_by\", \"\")\n        if cb:\n            self._index_by_cause.setdefault(cb, []).append(message)\n        if self.tracer:\n            snippet = (message.content or \"\")[:200].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {message.sent_from} cause_by={cb} send_to={getattr(message, 'send_to', set())} content={snippet}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages: List[Message] = []\n        for msg in self.history:\n            # skip messages the role already processed\n            if getattr(msg, \"id\", None) in getattr(role, \"_processed_message_ids\", set()):\n                continue\n            # explicit routing takes precedence\n            if getattr(msg, \"send_to\", None):\n                if role.name in msg.send_to or role.profile in msg.send_to:\n                    relevant_messages.append(msg)\n                    continue\n            # otherwise use watch_list matching cause_by\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\n    def get_latest_artifact(self, cause_names: List[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names\"\"\"\n        for name in cause_names:\n            msgs = self._index_by_cause.get(name, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together with robust orchestration and termination logic\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # track verification stability: require N consecutive PASS to accept\n        self._consecutive_verification_passes = 0\n        self._verification_threshold = 2  # require two consecutive passes to avoid fluke\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds with clear orchestration, retries, and termination checks\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # Initial message with the idea targeted at the coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"Alice\", \"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verified_overall = False\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            new_messages_this_round = 0\n\n            # Iterate over a fixed, orchestrated order to reduce race conditions:\n            orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    # get messages that role should handle\n                    incoming = self.env.get_messages_for_role(role)\n                    if not incoming:\n                        # allow coder to be triggered on first round by initial message\n                        if RoleClass is SimpleCoder and round_num == 1:\n                            incoming = [initial_msg]\n                    # Process each incoming message (deterministic order: newest first)\n                    for msg in incoming:\n                        # Attempt action with limited retries\n                        attempts = 0\n                        max_attempts = 2\n                        while attempts < max_attempts:\n                            try:\n                                attempts += 1\n                                response = await role.act(msg)\n                                if response:\n                                    self.env.publish_message(response)\n                                    new_messages_this_round += 1\n                                    # If verifier produced a PASS, update counters\n                                    if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (response.content or \"\"):\n                                        self._consecutive_verification_passes += 1\n                                        self.tracer.log(\"VERIFIER_PASS\", \"Team\", f\"Consecutive passes={self._consecutive_verification_passes}\")\n                                    elif isinstance(role, SimpleVerifier):\n                                        # reset if fail\n                                        self._consecutive_verification_passes = 0\n                                break  # success or handled, break retry loop\n                            except Exception as e:\n                                # Log and decide to retry\n                                self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Attempt {attempts} failed: {str(e)}\")\n                                if attempts >= max_attempts:\n                                    # produce an error message into environment\n                                    err_msg = Message(\n                                        content=f\"ERROR: role {role.name} failed after {attempts} attempts: {str(e)}\",\n                                        role=role.profile,\n                                        cause_by=\"RoleRunError\",\n                                        sent_from=role.name,\n                                        send_to=set()\n                                    )\n                                    self.env.publish_message(err_msg)\n                                    new_messages_this_round += 1\n                                else:\n                                    # small implicit backoff - next loop iteration will retry\n                                    continue\n\n            # After all roles, determine termination conditions\n            if self._consecutive_verification_passes >= self._verification_threshold:\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable for {self._verification_threshold} rounds, stopping\")\n                verified_overall = True\n                break\n\n            if new_messages_this_round == 0:\n                # no progress made this round; stop to avoid infinite loop\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No new messages produced this round; stopping early\")\n                break\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} completed with {new_messages_this_round} new messages\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' ended. Rounds executed={round_num}. Messages exchanged={len(self.env.history)}. Verified={verified_overall}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (3.500)\n\n\n### Inspiration 2 (Score: 4.6667, Type: High-Performer)\n```python\n# python\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nfrom typing import Dict, Set\n\nclass Action(ABC):\n    \"\"\"Base action with clear responsibilities, LLM retry logic, and graceful failure reporting.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    retry_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _call_llm_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries, logging, and backoff. Returns a string (or structured error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # Deterministic fallback to avoid raising\n                    return \"LLM_UNAVAILABLE_FALLBACK\"\n                resp = await self.llm.ask(messages)\n                # LLMInterface returns strings; treat strings starting with \"Error\" as failures\n                if isinstance(resp, str) and resp.startswith(\"Error\"):\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = e\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {str(e)}\")\n                # Exponential backoff\n                await asyncio.sleep(self.retry_backoff * attempt)\n        # After retries, return structured error so downstream can handle without exception\n        err_msg = f\"ERROR: LLM failed after {self.max_retries} attempts: {str(last_err)}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FAIL\", self.name, err_msg)\n        return err_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce a code artifact from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating code for idea: {idea[:120]}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a single Python module that implements the described functionality.\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, functional Python code\\n\"\n            \"- Proper error handling\\n\"\n            \"- Docstrings/comments\\n\"\n            \"- Parsable by ast.parse\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Return only the Python code, no wrappers or explanation.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        # Quick static validation: try parse; if LLM returned an error string starting with \"ERROR:\", fallback to minimal code\n        parsed_ok = False\n        if isinstance(result, str) and not result.startswith(\"ERROR:\") and result.strip():\n            try:\n                ast.parse(result)\n                parsed_ok = True\n            except Exception as e:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_VALIDATION\", self.name, f\"AST parse failed: {str(e)}\")\n        if not parsed_ok:\n            # Fallback minimal safe module\n            fallback = (\n                f\"# Fallback implementation for idea: {idea}\\n\"\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback implementation\")\n            return fallback\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code length={len(result)}\")\n        return result\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produce pytest-style tests targeting the provided code artifact.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating tests for code ({len(code) if code else 0} chars)\")\n        truncated = (code or \"\")[:2000]\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided module.\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest\\n\"\n            \"- Cover edge cases and error conditions where possible\\n\"\n            \"- Include docstrings for each test\\n\"\n            \"- Reference functions found in the module when possible\\n\\n\"\n            f\"Code:\\n{truncated}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        # Validate tests parse\n        tests_ok = False\n        if isinstance(result, str) and not result.startswith(\"ERROR:\") and result.strip():\n            try:\n                ast.parse(result)\n                tests_ok = True\n            except Exception as e:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_VALIDATION\", self.name, f\"Tests AST parse failed: {str(e)}\")\n        if not tests_ok:\n            fallback = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Using fallback tests\")\n            return fallback\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests length={len(result)}\")\n        return result\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests, return actionable message or request changes.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing artifacts (human={self.is_human})\")\n        if self.is_human:\n            # Simulated human review\n            review = \"APPROVE: Human review passed with minor suggestions: add more edge-case tests.\"\n        else:\n            prompt = (\n                \"You are a senior code reviewer. Provide a concise review of the code and tests.\\n\\n\"\n                \"Deliverable:\\n\"\n                \"- If issues that must be fixed exist, start response with 'REQUEST_CHANGE:' followed by required fixes.\\n\"\n                \"- Otherwise start with 'APPROVE:' and a brief rationale.\\n\\n\"\n                f\"Code:\\n{(code or '')[:1500]}\\n\\nTests:\\n{(tests or '')[:1500]}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            result = await self._call_llm_with_retries(messages)\n            if isinstance(result, str) and result.startswith(\"ERROR:\"):\n                # Fallback to conservative request change\n                review = \"REQUEST_CHANGE: Automated reviewer unavailable; please perform manual review.\"\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Reviewer LLM unavailable\")\n            else:\n                review = result\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Deterministic verification combining static checks and heuristics.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Performing verification checks\")\n        diagnostics = []\n        code_ok = False\n        tests_ok = False\n\n        # Code parse and basic heuristics\n        try:\n            code_ast = ast.parse(code or \"\")\n            defs = [n for n in code_ast.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))]\n            if defs:\n                code_ok = True\n                diagnostics.append(f\"code_defs:{len(defs)}\")\n            else:\n                diagnostics.append(\"code_defs:0\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n\n        # Tests parse and heuristics\n        try:\n            tests_ast = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            if tests_ok and code_ok:\n                # Check whether tests reference code functions\n                code_names = {n.name for n in ast.walk(code_ast) if isinstance(n, ast.FunctionDef)}\n                test_names = {n.id for n in ast.walk(tests_ast) if isinstance(n, ast.Name)}\n                referenced = code_names & test_names\n                diagnostics.append(f\"tests_refs:{len(referenced)}\")\n                if not referenced:\n                    diagnostics.append(\"tests_refs:0_match\")\n            else:\n                diagnostics.append(\"tests_parse_or_empty\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        verified = code_ok and tests_ok and not any(\"parse_error\" in d for d in diagnostics)\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(diagnostics)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"Base role with explicit responsibilities, watch/trigger logic, failure tracking, and clear outputs.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: Set[str] = set()  # names of causes to listen for\n    responsibility: str = \"Undefined\"\n    max_failures_before_escalation: int = 2\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = set()\n        self.responsibility = kwargs.get(\"responsibility\", self.responsibility)\n        self.failure_count = 0\n        # env will be assigned by Team.hire\n        self.env: Optional[Environment] = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[str]):\n        \"\"\"Provide action names or cause strings that this role responds to.\"\"\"\n        self.watch_list = set(actions)\n\n    def should_act_on(self, message: Optional[Message]) -> bool:\n        \"\"\"Decide whether to act on a given message.\"\"\"\n        if message is None:\n            return False\n        # Direct addressing\n        send_to = getattr(message, \"send_to\", None)\n        if send_to and (self.profile in send_to or self.name in send_to):\n            return True\n        # Cause-based matching\n        if getattr(message, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action for the role with error handling and failure accounting.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Invoking {action.name} for message_id={(getattr(message,'id',None))}\")\n        try:\n            # Map inputs per action type\n            if isinstance(action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or (message.content if message else \"\")\n                result = await action.run(idea or \"\")\n            elif isinstance(action, SimpleWriteTest):\n                code_src = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(code_src)\n            elif isinstance(action, SimpleWriteReview):\n                # Attempt to collect latest code & tests\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name) if self.env else (None, None)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            elif isinstance(action, SimpleVerify):\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name) if self.env else (None, None)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            else:\n                # Generic\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, f\"Unhandled exception: {str(e)}\")\n            result = f\"ERROR: Role {self.name} exception: {str(e)}\"\n\n        # Account failure vs success\n        if isinstance(result, str) and result.startswith(\"ERROR:\"):\n            self.failure_count += 1\n        else:\n            self.failure_count = 0\n\n        # Build message\n        out_msg = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name,\n            sent_from=self.name,\n            send_to=set()\n        )\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message {getattr(out_msg,'id',None)} cause_by={out_msg.cause_by}\")\n\n        # Escalate if repeated failures (log only; escalation policy can be extended)\n        if self.failure_count > self.max_failures_before_escalation and self.context and self.context.tracer:\n            self.context.tracer.log(\"ESCALATION\", self.name, f\"Failure count {self.failure_count} exceeded threshold\")\n\n        return out_msg\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    responsibility = \"Turn idea into initial code artifact\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder listens to explicit user input or change requests\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    responsibility = \"Produce tests for the latest code artifact\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    responsibility = \"Review code and tests and request changes or approve\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    responsibility = \"Deterministically verify artifacts and declare pass/fail\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest.name, SimpleWriteCode.name])\n\n\nclass Environment:\n    \"\"\"Environment manages messages, processing state, and routing logic.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track which roles processed which message ids\n        self._processed: Dict[str, Set[str]] = {}\n        # attempts to avoid livelock\n        self._attempts: Dict[str, int] = {}\n\n    def add_role(self, role: Role):\n        self.roles.append(role)\n        role.env = self\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure message has id\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        self._attempts.setdefault(message.id, 0)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message {getattr(message,'id','')} from {message.sent_from}: {str(message.content)[:150]} | cause_by={message.cause_by}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"Message {message.id} processed by {role.name}\")\n\n    def increment_attempt(self, message: Message) -> int:\n        self._attempts[message.id] = self._attempts.get(message.id, 0) + 1\n        return self._attempts[message.id]\n\n    def get_unprocessed_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages matching role.watch_list or direct addressing that haven't been processed by role.\"\"\"\n        results: List[Message] = []\n        for msg in self.history:\n            # skip messages already processed by this role\n            processed = self._processed.get(msg.id, set())\n            if role.name in processed:\n                continue\n            # direct addressing\n            send_to = getattr(msg, \"send_to\", None)\n            if send_to and (role.profile in send_to or role.name in send_to):\n                results.append(msg)\n                continue\n            # cause matching\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                results.append(msg)\n        return results\n\n    def find_latest_pair(self, code_cause: str, tests_cause: str):\n        \"\"\"Find the latest code and test messages (best-effort).\"\"\"\n        code_msg = None\n        tests_msg = None\n        for msg in reversed(self.history):\n            if not code_msg and getattr(msg, \"cause_by\", None) == code_cause:\n                code_msg = msg\n            if not tests_msg and getattr(msg, \"cause_by\", None) == tests_cause:\n                tests_msg = msg\n            if code_msg and tests_msg:\n                break\n        return code_msg, tests_msg\n\n\nclass Team:\n    \"\"\"Orchestrates the multi-agent pipeline with explicit termination, verification confirmation, and stagnation detection.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # pipeline order enforces clear responsibilities\n        self.pipeline = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        self.max_rounds_without_progress = 3\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # initial user message broadcast to all roles\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=set([r.profile for r in self.env.roles]) if self.env.roles else set()\n        )\n        # publish initial message (roles will be added after hire in the usual flow; ensure send_to can be empty safely)\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        rounds_since_progress = 0\n        last_history_len = len(self.env.history)\n\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            progress_this_round = False\n\n            # For each pipeline stage, process roles deterministically\n            for role_cls in self.pipeline:\n                for role in [r for r in self.env.roles if isinstance(r, role_cls)]:\n                    # Gather unprocessed messages for this role (or allow coder to act on initial)\n                    inbox = self.env.get_unprocessed_messages_for_role(role)\n                    # Special-case coder to allow acting on user input in first round even if not in watch_list\n                    if isinstance(role, SimpleCoder) and round_num == 1:\n                        # ensure initial message is considered\n                        for msg in reversed(self.env.history):\n                            if getattr(msg, \"cause_by\", \"\") == \"UserInput\":\n                                if msg not in inbox:\n                                    inbox.insert(0, msg)\n                                break\n\n                    # Process messages one at a time to remain deterministic\n                    for msg in list(inbox):\n                        # Avoid repeated attempts causing livelock\n                        attempts = self.env.increment_attempt(msg)\n                        if attempts > 6:\n                            # mark processed to move on\n                            self.env.mark_processed(msg, role)\n                            if self.tracer:\n                                self.tracer.log(\"ENV_SKIP\", \"Team\", f\"Skipping message {msg.id} for {role.name} after {attempts} attempts\")\n                            continue\n\n                        # Guard: do not let a role process its own previous message\n                        if getattr(msg, \"sent_from\", None) == role.name:\n                            self.env.mark_processed(msg, role)\n                            continue\n\n                        try:\n                            response = await role.act(msg)\n                        except Exception as e:\n                            # Unexpected error: produce an error message and continue\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {str(e)}\")\n                            response = Message(\n                                content=f\"ERROR: Unexpected exception in role {role.name}: {str(e)}\",\n                                role=role.profile,\n                                cause_by=\"EXCEPTION\",\n                                sent_from=role.name,\n                                send_to=set()\n                            )\n\n                        if response:\n                            # Route response to appropriate next roles\n                            if isinstance(role, SimpleCoder):\n                                response.send_to = set([SimpleTester.profile])\n                            elif isinstance(role, SimpleTester):\n                                response.send_to = set([SimpleReviewer.profile, SimpleVerifier.profile])\n                            elif isinstance(role, SimpleReviewer):\n                                # If reviewer requested change, send to coder, otherwise to verifier\n                                content_upper = (response.content or \"\").strip().upper()\n                                if content_upper.startswith(\"REQUEST_CHANGE\"):\n                                    response.send_to = set([SimpleCoder.profile])\n                                    response.cause_by = \"REQUEST_CHANGE\"\n                                else:\n                                    response.send_to = set([SimpleVerifier.profile])\n                            elif isinstance(role, SimpleVerifier):\n                                # Broadcast verdict\n                                response.send_to = set([r.profile for r in self.env.roles])\n\n                            self.env.publish_message(response)\n                            self.env.mark_processed(msg, role)\n                            progress_this_round = True\n\n                            # If verifier produced a PASS, confirm deterministically\n                            if isinstance(role, SimpleVerifier) and isinstance(response.content, str) and \"VERIFICATION_RESULT: PASS\" in response.content:\n                                # confirm using verifier action on latest artifacts\n                                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                                verifier_action = role.actions[0] if role.actions else None\n                                confirmed = False\n                                if verifier_action:\n                                    try:\n                                        confirm_text = await verifier_action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n                                        if isinstance(confirm_text, str) and \"VERIFICATION_RESULT: PASS\" in confirm_text:\n                                            confirmed = True\n                                    except Exception as e:\n                                        if self.tracer:\n                                            self.tracer.log(\"VERIFY_CONFIRM_ERROR\", \"Team\", f\"Confirmation attempt error: {str(e)}\")\n                                if confirmed:\n                                    verified = True\n                                    if self.tracer:\n                                        self.tracer.log(\"VERIFIED_CONFIRMED\", \"Team\", f\"Verification confirmed in round {round_num}\")\n                                else:\n                                    if self.tracer:\n                                        self.tracer.log(\"VERIFIED_REJECTED\", \"Team\", f\"Verification not confirmed in round {round_num}\")\n\n            # Round end bookkeeping\n            if len(self.env.history) == last_history_len:\n                rounds_since_progress += 1\n            else:\n                rounds_since_progress = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} completed; progress={progress_this_round}; history_len={len(self.env.history)}\")\n\n            # Termination conditions\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verified; stopping in round {round_num}\")\n                break\n            if rounds_since_progress >= self.max_rounds_without_progress:\n                self.tracer.log(\"TEAM_HANG_DETECT\", \"Team\", f\"No progress for {rounds_since_progress} rounds; stopping to avoid livelock\")\n                break\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative runs_successfully approach, Alternative combined_score approach, Excellent avg_failures_per_task (14.000)\n\n\n### Inspiration 3 (Score: 3.2125, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport random\nfrom typing import Callable, Tuple\n\nRETRY_ATTEMPTS = 3\nRETRY_BACKOFF_BASE = 0.5  # seconds\nMAX_MESSAGE_ATTEMPTS = 5\n\nclass Action(ABC):\n    \"\"\"Base action class with retry and error handling for LLM/API calls.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries and exponential backoff. Returns response or raises.\"\"\"\n        if not self.llm:\n            # No LLM configured; return sentinel to allow caller to fallback\n            return \"LLM_NOT_AVAILABLE\"\n        last_err = None\n        for attempt in range(1, RETRY_ATTEMPTS + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}\")\n                resp = await self.llm.ask(messages)\n                # Basic failure detection: LLMInterface returns string starting with \"Error\"\n                if isinstance(resp, str) and resp.startswith(\"Error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff with jitter\n                await asyncio.sleep(RETRY_BACKOFF_BASE * (2 ** (attempt - 1)) + random.random() * 0.1)\n        # All retries failed\n        raise RuntimeError(f\"LLM call failed after {RETRY_ATTEMPTS} attempts: {last_err}\")\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce a compilable code artifact from a short instruction.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"idea={(idea or '')[:120]}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a single Python module that implements the described functionality. \"\n            \"Keep functions small and documented. Ensure code is parseable by ast.parse and does not include extraneous text.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n1. Clean, functional Python code\\n2. Proper error handling\\n3. Docstrings and comments\\n4. Production-ready\\n\\n\"\n            \"Provide only the Python code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python developer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = None\n        try:\n            resp = await self._llm_call_with_retries(messages)\n            if resp == \"LLM_NOT_AVAILABLE\":\n                raise RuntimeError(\"LLM not available\")\n            code = resp\n        except Exception as e:\n            # Fallback minimal code to keep pipeline moving\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, f\"LLM failure: {str(e)[:200]}\")\n            code = (\n                f\"# Fallback implementation for: {idea}\\n\\n\"\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n\n        # Validate that generated code parses\n        parsed_ok = False\n        try:\n            import ast\n            ast.parse(code or \"\")\n            parsed_ok = True\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"AST parse failed: {str(e)[:200]}\")\n            # Attempt a minimal corrective step: wrap in a safe function if possible\n            try:\n                corrective = \"def _safe_wrapper():\\n\"\n                for line in (code or \"\").splitlines():\n                    corrective += \"    \" + line + \"\\n\"\n                corrective += \"\\n\"\n                import ast as _ast\n                _ast.parse(corrective)\n                code = corrective\n                parsed_ok = True\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_VALIDATION_FIX\", self.name, \"Applied simple wrapper to fix parse issues\")\n            except Exception:\n                parsed_ok = False\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"len={len(code or '')}; parsed_ok={parsed_ok}\")\n        return code or \"\"\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produce pytest-style tests targeting functions present in the code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        # Extract function names to direct tests\n        func_names = []\n        try:\n            import ast\n            mod = ast.parse(code or \"\")\n            func_names = [n.name for n in ast.walk(mod) if isinstance(n, ast.FunctionDef)]\n        except Exception:\n            func_names = []\n\n        prompt = (\n            \"You are a QA engineer that writes pytest tests. Produce pytest tests for the given module. \"\n            \"If function names are available, write at least one positive and one negative test per function. \"\n            \"Include docstrings for each test. Provide only the Python test code.\"\n        )\n        if func_names:\n            prompt += f\"\\nTarget functions: {', '.join(func_names[:8])}\"\n        prompt += \"\\n\\nCode:\\n\" + (code[:2000] if code else \"(empty)\")\n\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer who writes pytest tests.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = None\n        try:\n            resp = await self._llm_call_with_retries(messages)\n            if resp == \"LLM_NOT_AVAILABLE\":\n                raise RuntimeError(\"LLM not available\")\n            tests = resp\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, f\"LLM failure: {str(e)[:200]}\")\n            tests = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder_exists():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n\n        # Validate tests parse\n        tests_ok = False\n        try:\n            import ast\n            ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n        except Exception as e:\n            tests_ok = False\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Tests AST parse failed: {str(e)[:200]}\")\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"len={len(tests or '')}; parsed_ok={tests_ok}\")\n        return tests or \"\"\n\nclass SimpleWriteReview(Action):\n    \"\"\"Produce concise, actionable review of code and tests.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Basic sanity checks performed. Consider adding edge-case tests and clearer error handling.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Provide a concise actionable review focused on code quality, test completeness, \"\n                \"and likely bugs. Provide a short prioritized list of suggestions.\\n\\n\"\n                f\"Code:\\n{code[:1500]}\\n\\nTests:\\n{tests[:1500]}\"\n            )\n            messages = [{\"role\": \"system\", \"content\": \"You are a senior code reviewer.\"},\n                        {\"role\": \"user\", \"content\": prompt}]\n            try:\n                resp = await self._llm_call_with_retries(messages)\n                if resp == \"LLM_NOT_AVAILABLE\":\n                    raise RuntimeError(\"LLM not available\")\n                review = resp\n            except Exception as e:\n                review = \"Automated review fallback: Unable to contact reviewer LLM. Please perform a manual review.\"\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_FALLBACK\", self.name, f\"LLM failure: {str(e)[:200]}\")\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Verify syntactic and basic semantic alignment between code and tests.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"\")\n        diagnostics = []\n        code_ok = False\n        tests_ok = False\n        try:\n            import ast\n            code_ast = ast.parse(code or \"\")\n            defs = [n for n in code_ast.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))]\n            if defs:\n                code_ok = True\n                diagnostics.append(f\"code_defs:{len(defs)}\")\n            else:\n                diagnostics.append(\"code_defs:none\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:180]}\")\n\n        try:\n            import ast\n            tests_ast = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            if tests_ok and code_ok:\n                test_names = {n.id for n in ast.walk(tests_ast) if isinstance(n, ast.Name)}\n                code_names = {n.name for n in ast.walk(code_ast) if isinstance(n, ast.FunctionDef)}\n                referenced = code_names & test_names\n                diagnostics.append(f\"tests_refs:{len(referenced)}\")\n                if not referenced:\n                    diagnostics.append(\"tests_refs:none\")\n            else:\n                diagnostics.append(\"tests_parse:empty_or_invalid\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:180]}\")\n\n        verified = code_ok and tests_ok and any(\"tests_refs\" in d and not d.endswith(\":0\") for d in diagnostics) == False or (code_ok and tests_ok)\n        # The above line ensures we require both parseable code and tests; we keep it lenient but informative.\n        result = f\"VERIFICATION_RESULT: {'PASS' if (code_ok and tests_ok) else 'FAIL'} | \" + \"; \".join(diagnostics)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with explicit responsibilities and inbox semantics.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # list of action names to watch\n    env: Optional[\"Environment\"] = None  # assigned at hire\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, action_types: List[Type[Action]]):\n        self.watch_list = [t.name for t in action_types]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"action={action.name}; msg_id={(message.id if message else 'None')}\")\n        try:\n            # Clear responsibility mapping here\n            if isinstance(action, SimpleWriteCode):\n                prompt = (message.instruct_content if (message and getattr(message, \"instruct_content\", None)) else (message.content if message else \"\"))\n                result = await action.run(prompt or \"\")\n            elif isinstance(action, SimpleWriteTest):\n                code_text = message.content if message else \"\"\n                result = await action.run(code_text)\n            elif isinstance(action, SimpleWriteReview):\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            elif isinstance(action, SimpleVerify):\n                code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            else:\n                result = \"Action completed\"\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, f\"exception: {str(e)[:200]}\")\n            result = f\"ERROR: {str(e)}\"\n\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n\n        # Mark processed to avoid duplicate processing by same role\n        if message and self.env:\n            self.env.mark_processed(message, self)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"created_msg_id={getattr(response, 'id', 'N/A')}; len={len(result)}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Tracks messages, processing state, and attempts to reduce race conditions.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        self._processed: Dict[str, Set[str]] = {}  # message.id -> set(role.name)\n        self._attempts: Dict[str, int] = {}       # message.id -> attempts count\n\n    def add_role(self, role: Role):\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"{role.name}:{role.profile}\")\n\n    def publish_message(self, message: Message):\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        self._attempts.setdefault(message.id, 0)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"from={message.sent_from}; cause_by={message.cause_by}; snippet={(message.content or '')[:140]}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"msg={message.id}; by={role.name}\")\n\n    def increment_attempt(self, message: Message) -> int:\n        self._attempts[message.id] = self._attempts.get(message.id, 0) + 1\n        return self._attempts[message.id]\n\n    def get_unprocessed_messages_for_role(self, role: Role) -> List[Message]:\n        results = []\n        for msg in self.history:\n            if msg.cause_by in role.watch_list:\n                processed = self._processed.get(msg.id, set())\n                if role.name not in processed:\n                    results.append(msg)\n        return results\n\n    def find_latest_pair(self, code_cause: str, tests_cause: str) -> Tuple[Optional[Message], Optional[Message]]:\n        code_msg = None\n        tests_msg = None\n        for msg in reversed(self.history):\n            if not code_msg and msg.cause_by == code_cause:\n                code_msg = msg\n            if not tests_msg and msg.cause_by == tests_cause:\n                tests_msg = msg\n            if code_msg and tests_msg:\n                break\n        return code_msg, tests_msg\n\nclass Team:\n    \"\"\"Team orchestrator with clear pipeline, explicit watch/trigger logic, and robust termination.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self.pipeline: List[Type[Role]] = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"idea={idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"up_to_rounds={n_round}\")\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        last_verified_round = -1\n        last_history_len = len(self.env.history)\n\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"round={round_num}\")\n            for role_type in self.pipeline:\n                for role in [r for r in self.env.roles if isinstance(r, role_type)]:\n                    # Determine inbox for this role\n                    if isinstance(role, SimpleCoder) and round_num == 1:\n                        inbox = [initial_msg]\n                    else:\n                        inbox = self.env.get_unprocessed_messages_for_role(role)\n\n                    for msg in inbox:\n                        attempts = self.env.increment_attempt(msg)\n                        if attempts > MAX_MESSAGE_ATTEMPTS:\n                            if self.tracer:\n                                self.tracer.log(\"ENV_SKIP\", \"Environment\", f\"skip msg={msg.id} for role={role.name} after_attempts={attempts}\")\n                            self.env.mark_processed(msg, role)\n                            continue\n\n                        response = await role.act(msg)\n                        if response:\n                            self.env.publish_message(response)\n                            # If verifier produced PASS, do confirmation\n                            if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (response.content or \"\"):\n                                # Run a confirmation verification locally to avoid transient success\n                                try:\n                                    verifier_action = role.actions[0]\n                                    code_msg, tests_msg = self.env.find_latest_pair(SimpleWriteCode.name, SimpleWriteTest.name)\n                                    confirm = await verifier_action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n                                    if isinstance(confirm, str) and \"VERIFICATION_RESULT: PASS\" in confirm:\n                                        verified = True\n                                        last_verified_round = round_num\n                                        self.tracer.log(\"VERIFIED_CONFIRMED\", \"Team\", f\"round={round_num}\")\n                                    else:\n                                        self.tracer.log(\"VERIFIED_REJECTED\", \"Team\", f\"round={round_num}; confirm={confirm[:200]}\")\n                                except Exception as e:\n                                    if self.tracer:\n                                        self.tracer.log(\"VERIFIED_ERROR\", \"Team\", f\"confirm exception: {str(e)[:200]}\")\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"round={round_num}\")\n            # Check for stable verification: require verification and no new messages after one extra round\n            if verified:\n                # If history length hasn't changed since verification, we can stop\n                if len(self.env.history) == last_history_len:\n                    self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"stable verified at round={round_num}\")\n                    break\n                else:\n                    # record current history length and allow one more round\n                    last_history_len = len(self.env.history)\n            else:\n                last_history_len = len(self.env.history)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach, Alternative combined_score approach, Excellent avg_failures_per_task (12.000)\n\n\n### Inspiration 4 (Score: 4.6667, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\nimport asyncio\nimport time\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\n# Improved multi-agent logic with clearer roles, robust communication,\n# explicit watch/trigger logic, verification, and retry/error handling.\n\n# Safe deterministic fallbacks used when LLM is unavailable or returns errors\n_DEFAULT_CODE = (\n    \"def solve(input_data):\\n\"\n    \"    '''Safe fallback implementation: returns the input unchanged.'''\\n\"\n    \"    return input_data\\n\"\n)\n_DEFAULT_TESTS = (\n    \"def test_solve_basic():\\n\"\n    \"    try:\\n\"\n    \"        # attempt to import solve if present\\n\"\n    \"        from __main__ import solve\\n\"\n    \"    except Exception:\\n\"\n    \"        assert True\\n\"\n    \"        return\\n\"\n    \"    assert solve(1) == 1\\n\"\n    \"    assert solve('a') == 'a'\\n\"\n)\n\ndef _strip_code_fences(text: Optional[str]) -> str:\n    \"\"\"Strip common markdown code fences and leading/trailing whitespace.\"\"\"\n    if not text:\n        return \"\"\n    t = text.strip()\n    # remove typical fences and leading language markers\n    if t.startswith(\"\n```\nUnique approach: Modification: Full rewrite, Alternative runs_successfully approach, Alternative combined_score approach, Excellent avg_failures_per_task (14.000)\n\n\n### Inspiration 5 (Score: 4.6667, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nfrom typing import Tuple\n\n# Focus: clear roles, robust communication (watch + explicit routing), verification stability, and strong fallbacks.\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry and sanitization utilities.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_llm_retries: int = 3\n    retry_backoff: float = 0.75  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    def _log(self, event_type: str, details: str):\n        if self.context and self.context.tracer:\n            self.context.tracer.log(event_type, self.name, details)\n\n    def _sanitize_text(self, text: str) -> str:\n        \"\"\"Remove common non-code wrappers like markdown fences.\"\"\"\n        if not isinstance(text, str):\n            return \"\"\n        t = text.strip()\n        # Strip triple backtick blocks if present\n        if t.startswith(\"\n```\nUnique approach: Modification: Full rewrite, Alternative runs_successfully approach, Alternative combined_score approach, Excellent avg_failures_per_task (14.000)\n\n\n\n# Current Program\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport random\nfrom typing import Tuple\n\n# Goals implemented:\n# - Clear roles and responsibilities\n# - Explicit triggers and routing (send_to)\n# - Deterministic orchestration with per-role processed tracking\n# - Robust LLM retry + fallback\n# - Strong verification and confirmation + stable termination (consecutive passes)\n# - Error handling and retry across role actions\n\nDEFAULT_VERIFICATION_STREAK = 2\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.8  # seconds\nMAX_MESSAGE_ATTEMPTS = 6\n\nclass Action(ABC):\n    \"\"\"Base action with LLM retry, backoff, validation and fallback semantics.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = LLM_MAX_RETRIES\n    backoff_base: float = LLM_BACKOFF_BASE\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def call_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries and exponential backoff. Returns string result or an explicit error token.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # Deterministic fallback to avoid hard failure\n                    fallback = \"LLM_UNAVAILABLE: deterministic fallback\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # jittered backoff\n                await asyncio.sleep(self.backoff_base * (2 ** (attempt - 1)) + random.uniform(0, 0.25))\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce a validated Python module from idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            # clear signal for empty idea\n            fallback = \"# WARNING: Empty idea provided. No code generated.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_WARN\", self.name, \"Empty idea\")\n            return fallback\n\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module implementing the described task. \"\n            \"Return only valid Python source code, no markdown fences or explanations. Include docstrings and input validation.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self.call_llm(messages)\n        # If LLM failed, return explicit failure so downstream can react\n        if isinstance(resp, str) and resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n            fallback = f\"# CODE_GEN_ERROR: {resp}\\n# Please retry or provide a human-coded fallback.\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; returning error sentinel\")\n            return fallback\n\n        # Try to sanitize common code fences\n        code = self._strip_code_fences(resp)\n        # Validate syntax\n        try:\n            ast.parse(code)\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_VALIDATE\", self.name, \"Code syntax ok\")\n            return code\n        except Exception as e:\n            # attempt small fix: wrap into function if possible\n            try:\n                wrapper = \"def _generated_wrapper():\\n\"\n                for line in code.splitlines():\n                    wrapper += \"    \" + line + \"\\n\"\n                ast.parse(wrapper)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_FIX\", self.name, \"Applied safe wrapper to fix syntax\")\n                return wrapper\n            except Exception:\n                err = f\"# CODE_PARSE_ERROR: {str(e)[:160]}\\n# Raw Output:\\n{code}\"\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_ERROR\", self.name, f\"Code parse failed: {str(e)[:200]}\")\n                return err\n\n    def _strip_code_fences(self, text: Optional[str]) -> str:\n        if not text:\n            return \"\"\n        t = text.strip()\n        # remove triple backticks\n        if t.startswith(\"```\") and \"```\" in t[3:]:\n            parts = t.split(\"```\")\n            # choose the largest code-like chunk\n            candidates = [p for p in parts if '\\n' in p]\n            if candidates:\n                return candidates[0].strip()\n        # remove leading language markers like \"python\\n\"\n        if t.lower().startswith(\"python\\n\"):\n            return t[len(\"python\\n\"):].strip()\n        return t\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests referencing code artifacts.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        snippet = (code or \"\")[:3000]\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided Python module. \"\n            \"Include clear test names and assertions. Return only Python test code.\"\n            f\"\\n\\nCode:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self.call_llm(messages)\n        if isinstance(resp, str) and resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n            fallback = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; returning fallback tests\")\n            return fallback\n\n        tests = self._strip_code_fences(resp)\n        # basic validation: should contain 'test_' or 'assert'\n        try:\n            parsed = ast.parse(tests)\n            has_test = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n            if has_test or has_assert:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_VALIDATE\", self.name, \"Tests appear valid\")\n                return tests\n            else:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ACTION_WARN\", self.name, \"Tests contain no test_ functions; returning fallback\")\n                return (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_ERROR\", self.name, f\"Tests parse failed: {str(e)[:200]}\")\n            return (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test that always passes.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n\n    def _strip_code_fences(self, text: Optional[str]) -> str:\n        if not text:\n            return \"\"\n        t = text.strip()\n        if t.startswith(\"```\") and \"```\" in t[3:]:\n            parts = t.split(\"```\")\n            candidates = [p for p in parts if '\\n' in p]\n            if candidates:\n                return candidates[0].strip()\n        return t\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items (or simulated human review).\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        # Static checks first\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:160]}\")\n\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ACTION_HUMAN\", self.name, review)\n            return review\n\n        prompt = (\n            \"You are a senior engineer. Provide a short, prioritized review. Start with 'APPROVE:' if acceptable or \"\n            \"'REQUEST_CHANGE:' followed by required fixes. Keep it concise.\\n\\n\"\n            f\"Code (first 1500 chars):\\n{(code or '')[:1500]}\\n\\nTests (first 1500 chars):\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self.call_llm(messages)\n        if isinstance(resp, str) and resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n            # conservative fallback: request change if any static issues, else minimal approve\n            if issues:\n                return \"REQUEST_CHANGE: Automated reviewer failed; static issues found: \" + \"; \".join(issues)\n            return \"APPROVE: Minimal (automated reviewer unavailable)\"\n        return resp\n\nclass SimpleVerify(Action):\n    \"\"\"Deterministic verification combining syntax, tests presence, and cross-references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        issues = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Syntax checks\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_ok = True\n            issues.append(\"code_syntax:ok\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:160]}\")\n            parsed_code = None\n\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            # detect pytest style\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            if has_test_fn or has_assert:\n                tests_ok = True\n                issues.append(\"tests_syntax_and_asserts:ok\")\n            else:\n                issues.append(\"tests_no_test_functions\")\n            parsed_tests = parsed_tests\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:160]}\")\n            parsed_tests = None\n\n        # Cross reference\n        if parsed_code and parsed_tests:\n            code_defs = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            test_names = {n.id for n in ast.walk(parsed_tests) if isinstance(n, ast.Name)}\n            if code_defs and (code_defs & test_names):\n                referenced = True\n                issues.append(f\"tests_reference_count:{len(code_defs & test_names)}\")\n            else:\n                issues.append(\"tests_reference_count:0\")\n\n        verified = code_ok and tests_ok and referenced\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(issues)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role: clear responsibility, triggers_on list, single primary action.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    triggers_on: List[str] = []  # cause_by tokens or direct addressing\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.triggers_on = kwargs.get('triggers_on', [])\n        self.env = None\n        # processed ids to avoid duplicate work\n        self._processed_ids: Set[str] = set()\n        # failure accounting for escalation\n        self.failure_count = 0\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def listens_to(self, causes: List[str]):\n        self.triggers_on = list(causes)\n\n    def _should_handle(self, msg: Message) -> bool:\n        if not msg or getattr(msg, \"id\", None) is None:\n            return False\n        if msg.id in self._processed_ids:\n            return False\n        # don't process messages self produced\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        # explicit routing\n        targets = set(getattr(msg, \"send_to\", set()) or set(getattr(msg, \"sent_to\", set()) or set()))\n        if targets:\n            if self.profile in targets or self.name in targets:\n                return True\n            return False\n        # triggers_on matching cause_by\n        if getattr(msg, \"cause_by\", None) in self.triggers_on:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # guard: if message provided but not for us, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Acting on message={(getattr(message,'id',None))} cause_by={(getattr(message,'cause_by',None))}\")\n        try:\n            # explicit mapping:\n            if isinstance(action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await action.run(idea)\n                send_to = {\"SimpleTester\"}\n                # if code generation clearly failed, route back to coder for retry and reviewer for context\n                if isinstance(out, str) and (\"LLM_FAILED\" in out or \"CODE_PARSE_ERROR\" in out or out.startswith(\"# CODE_GEN_ERROR\")):\n                    send_to = {self.profile}\n                msg = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif isinstance(action, SimpleWriteTest):\n                # prefer code from provided message, else latest artifact\n                code_text = \"\"\n                if message and getattr(message, \"content\", None):\n                    code_text = message.content\n                elif self.env:\n                    code_art = self.env.find_latest_artifact([SimpleWriteCode.name])\n                    code_text = code_art.content if code_art else \"\"\n                out = await action.run(code_text)\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                # if tests generation clearly failed, route back to coder/tester\n                if isinstance(out, str) and out.startswith(\"import pytest\") is False and out.startswith(\"#\"):\n                    # heuristics: fallback produced comment\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                msg = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif isinstance(action, SimpleWriteReview):\n                # gather latest code/tests\n                code_art = self.env.find_latest_artifact([SimpleWriteCode.name])\n                tests_art = self.env.find_latest_artifact([SimpleWriteTest.name])\n                out = await action.run(code_art.content if code_art else \"\", tests_art.content if tests_art else \"\")\n                lowered = (out or \"\").lower()\n                if lowered.startswith(\"request_change\") or \"request_change\" in lowered or \"fix\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                    cause = \"REQUEST_CHANGE\"\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                    cause = action.name\n                msg = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=cause,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif isinstance(action, SimpleVerify):\n                code_art = self.env.find_latest_artifact([SimpleWriteCode.name])\n                tests_art = self.env.find_latest_artifact([SimpleWriteTest.name])\n                out = await action.run(code_art.content if code_art else \"\", tests_art.content if tests_art else \"\")\n                # verification broadcasts to all for transparency\n                send_to = set([r.profile for r in self.env.roles]) if self.env else set()\n                msg = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                # generic action handling\n                out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                msg = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=set()\n                )\n            # mark processed for input message to prevent reprocessing\n            if message and getattr(message, \"id\", None):\n                self._processed_ids.add(message.id)\n            # also mark produced message id as processed locally\n            if getattr(msg, \"id\", None):\n                self._processed_ids.add(msg.id)\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(msg,'id',None)} send_to={getattr(msg,'send_to',set())}\")\n            return msg\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            # produce error message targeted at coder to surface issues\n            msg = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n            # mark input processed\n            if message and getattr(message, \"id\", None):\n                self._processed_ids.add(message.id)\n            return msg\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # listens to user input and change requests\n        self.listens_to([\"UserInput\", \"REQUEST_CHANGE\", \"Nudge\"])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.listens_to([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.listens_to([SimpleWriteTest.name, SimpleWriteCode.name])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.listens_to([SimpleWriteTest.name, SimpleWriteReview.name, SimpleWriteCode.name])\n\nclass Environment:\n    \"\"\"Tracks roles, history, processed state, and provides artifact lookup.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # per-role processed set: (role.name, message.id)\n        self.processed: Set[Tuple[str, str]] = set()\n        # attempt counts per (role.name, message.id) to avoid livelock\n        self.attempts: Dict[Tuple[str, str], int] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to to set\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        # ensure id exists (pydantic does)\n        if not getattr(message, \"id\", None):\n            message.id = str(uuid.uuid4())\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if not getattr(message, \"id\", None):\n            return\n        key = (role.name, message.id)\n        self.processed.add(key)\n        # reset attempts for this pair\n        self.attempts.pop(key, None)\n        if self.tracer:\n            self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def increment_attempt(self, role: Role, message: Message) -> int:\n        key = (role.name, message.id)\n        self.attempts[key] = self.attempts.get(key, 0) + 1\n        return self.attempts[key]\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages this role should process (unprocessed, applicable).\"\"\"\n        out = []\n        for msg in self.history:\n            if not getattr(msg, \"id\", None):\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing has precedence\n            targets = set(getattr(msg, \"send_to\", set()) or set(getattr(msg, \"sent_to\", set()) or set()))\n            if targets:\n                if role.profile in targets or role.name in targets:\n                    out.append(msg)\n                    continue\n                else:\n                    continue\n            # otherwise consider triggers_on\n            if getattr(msg, \"cause_by\", None) in role.triggers_on:\n                out.append(msg)\n        return out\n\n    def find_latest_artifact(self, cause_names: List[str]) -> Optional[Message]:\n        \"\"\"Return most recent message whose cause_by in cause_names (first match prioritized).\"\"\"\n        for msg in reversed(self.history):\n            if getattr(msg, \"cause_by\", None) in cause_names:\n                return msg\n        return None\n\nclass Team:\n    \"\"\"Orchestrates deterministic multi-agent collaboration with stable verification termination.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.idea: str = \"\"\n        self.required_stable_passes = DEFAULT_VERIFICATION_STREAK\n        # ordering stable to avoid races\n        self.order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_single_role(self, role: Role) -> int:\n        \"\"\"Process pending messages for a role. Returns number of new messages published.\"\"\"\n        produced = 0\n        msgs = self.env.get_messages_for_role(role)\n        # deterministic ordering: oldest first\n        for m in msgs:\n            # avoid livelock on repeated attempts\n            attempts = self.env.increment_attempt(role, m)\n            if attempts > MAX_MESSAGE_ATTEMPTS:\n                # mark processed so we move on\n                self.env.mark_processed(role, m)\n                if self.tracer:\n                    self.tracer.log(\"ENV_SKIP\", \"Team\", f\"Skipping msg {m.id} for role {role.name} after {attempts} attempts\")\n                continue\n            resp = await role.act(m)\n            # mark input as processed regardless to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                produced += 1\n                # If verifier produced PASS, we'll handle streak externally\n        return produced\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial targeted message to coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verifier_streak = 0\n        last_verification_index = -1\n\n        for round_idx in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            round_new_msgs = 0\n\n            # process roles in deterministic order\n            for role_cls in self.order:\n                for role in [r for r in self.env.roles if isinstance(r, role_cls)]:\n                    # special-case: coder may be proactive on initial round if not yet handled user input\n                    if isinstance(role, SimpleCoder):\n                        # ensure coder gets initial message when not processed\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                produced = await self._process_single_role(role)\n                                round_new_msgs += produced\n                                break\n                        else:\n                            # process other pending messages for coder\n                            produced = await self._process_single_role(role)\n                            round_new_msgs += produced\n                        continue\n                    # normal processing\n                    produced = await self._process_single_role(role)\n                    round_new_msgs += produced\n\n            # After processing all roles this round, inspect verifier outputs\n            # find most recent verifier message\n            last_verifier_msg = None\n            for msg in reversed(self.env.history):\n                if getattr(msg, \"cause_by\", \"\") == SimpleVerify.name and getattr(msg, \"sent_from\", \"\") == \"Dana\":\n                    last_verifier_msg = msg\n                    break\n            if last_verifier_msg:\n                if \"VERIFICATION_RESULT: PASS\" in (last_verifier_msg.content or \"\"):\n                    # Ensure this verification is most recent relevant verification\n                    idx = self.env.history.index(last_verifier_msg)\n                    if idx >= last_verification_index:\n                        verifier_streak += 1\n                        last_verification_index = idx\n                        self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={verifier_streak}\")\n                    else:\n                        verifier_streak = 1\n                        last_verification_index = idx\n                else:\n                    if verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", \"verifier produced non-pass -> resetting streak\")\n                    verifier_streak = 0\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} done; new_msgs={round_new_msgs}; verifier_streak={verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require required_stable_passes consecutive PASS results\n            if verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {verifier_streak} passes; stopping\")\n                break\n\n            # stagnation detection: if no new messages this round, proactively nudge coder once\n            if round_new_msgs == 0:\n                # create a nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # immediately process coder for nudge\n                for role in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                    produced = await self._process_single_role(role)\n                    round_new_msgs += produced\n                # if still no progress, consider stopping next round to avoid livelock\n                if round_new_msgs == 0:\n                    self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No progress after nudge; stopping to avoid livelock\")\n                    break\n\n        # final summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_idx} rounds with {len(self.env.history)} messages. verifier_streak={verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest = getattr(team, \"invest\", lambda x: None)\n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}