{"id": "d032481a-f839-4c4d-a908-6e338542e63f", "code": "\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nfrom typing import Tuple\n\n# Focus: clear roles, robust communication (watch + explicit routing), verification stability, and strong fallbacks.\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry and sanitization utilities.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_llm_retries: int = 3\n    retry_backoff: float = 0.75  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    def _log(self, event_type: str, details: str):\n        if self.context and self.context.tracer:\n            self.context.tracer.log(event_type, self.name, details)\n\n    def _sanitize_text(self, text: str) -> str:\n        \"\"\"Remove common non-code wrappers like markdown fences.\"\"\"\n        if not isinstance(text, str):\n            return \"\"\n        t = text.strip()\n        # Strip triple backtick blocks if present\n        if t.startswith(\"", "language": "python", "parent_id": "2919bea8-9d23-4fa9-a704-c5cd77b590fd", "generation": 2, "timestamp": 1754655659.9653237, "iteration_found": 22, "metrics": {"runs_successfully": 0.0, "combined_score": 0.0, "avg_failures_per_task": 14.0, "error": "unterminated string literal (detected at line 186) (tmpawlpk_7g.py, line 186)"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes per the MAST taxonomy.\n\nFocus on:\n- Clear role definitions and responsibilities\n- Robust inter-agent communication patterns and explicit watch/trigger logic\n- Termination conditions (avoid premature termination; stop once verified)\n- Strong verification and validation steps\n- Error handling and retry on LLM/API failures\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 0.5000\n- overall_score: 0.2500\n- combined_score: 0.1000\n- avg_failures_per_task: 12.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.1667, avg_failures_per_task: 5.0000, total_failures: 30.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 7.1111)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    \n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            code = await self.llm.ask(messages)\n        else:\n            code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} characters of code\")\n        \n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code[:2000]}  # Truncate if too long\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            tests = await self.llm.ask(messages)\n        else:\n            tests = f\"# Tests for the implementation\\n# [Tests would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} characters of tests\")\n        \n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        if self.is_human:\n            # Simulate human review\n            review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n            \n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            \n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review completed: {len(review)} characters\")\n        \n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n        try:\n            ast.parse(code)\n            code_ok = True\n        except Exception as e:\n            code_ok = False\n            code_err = str(e)\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n        except Exception as e:\n            tests_ok = False\n            tests_err = str(e)\n        status = []\n        if code_ok:\n            status.append(\"code_syntax: ok\")\n        else:\n            status.append(f\"code_syntax: fail ({code_err[:120]})\")\n        if tests_ok:\n            status.append(\"tests_syntax: ok\")\n        else:\n            status.append(f\"tests_syntax: fail ({(tests_err if 'tests_err' in locals() else 'empty')[:120]})\")\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        if not self.actions:\n            return None\n        \n        # Execute the first action (simplified)\n        action = self.actions[0]\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Executing action: {action.name}\")\n        \n        # Execute action based on type\n        if isinstance(action, SimpleWriteCode):\n            if message and hasattr(message, 'instruct_content'):\n                result = await action.run(message.instruct_content or message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteTest):\n            if message:\n                result = await action.run(message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteReview):\n            # For review, we need both code and tests\n            if message:\n                # Extract code and tests from previous messages (simplified)\n                result = await action.run(message.content, \"\")\n            else:\n                result = await action.run(\"\", \"\")\n        elif isinstance(action, SimpleVerify):\n            # For verification, try to find latest code and tests from history\n            env = getattr(self, 'env', None)\n            code_msg = None\n            tests_msg = None\n            if env:\n                for msg in reversed(env.history):\n                    if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                        code_msg = msg\n                    if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                        tests_msg = msg\n                    if code_msg and tests_msg:\n                        break\n            result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n        else:\n            result = \"Action completed\"\n        \n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed, message created\")\n        \n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", \n                          f\"Message from {message.sent_from}: {message.content[:100]}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            # Check if this message is from an action the role watches\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        verified = False\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Orchestrated sequence: Coder -> Tester -> Reviewer -> Verifier\n            for role in self.env.roles:\n                if isinstance(role, SimpleCoder):\n                    response = await role.act(initial_msg if round_num == 0 else None)\n                    if response:\n                        self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleTester):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleReviewer):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleVerifier):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n                            if \"VERIFICATION_RESULT: PASS\" in response.content:\n                                verified = True\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                break\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.1667), Performs well on avg_failures_per_task (5.0000), Performs well on total_failures (30.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 2 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nfrom typing import Tuple\n\n# Clearer responsibilities via docstrings, explicit watch/trigger logic, robust retries, and stable verification.\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry wrapper and standardized interface.\n    Responsibilities:\n    - Provide a run(...) coroutine that performs the action and returns a textual result.\n    - Use _ask_with_retry for LLM calls to reduce transient failure modes.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_llm_retries: int = 3\n    retry_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Ask the LLM with retry and exponential backoff. Returns final string or error string.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_llm_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\n                        \"LLM_CALL\",\n                        self.name,\n                        f\"Attempt {attempt}/{self.max_llm_retries} to invoke LLM\"\n                    )\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                else:\n                    resp = \"LLM unavailable: fallback response\"\n                # Detect common error signatures and retry\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # Backoff before retrying\n                await asyncio.sleep(self.retry_backoff * (2 ** (attempt - 1)))\n        # All retries exhausted\n        err_msg = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, err_msg)\n        return err_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a textual result.\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Writes code given an idea. Responsible only for generating the initial implementation.\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating code for idea (len={len(idea)})\")\n        prompt = (\n            \"You are a professional programmer. Write clean, production-ready Python code for the task below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Clear function-level code with docstrings\\n\"\n            \"2. Proper error handling and input validation\\n\"\n            \"3. Minimal dependencies\\n\"\n            \"4. Return only Python code without backticks or commentary\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code length: {len(resp)}\")\n        return resp\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produces pytest-style tests for given code. Focused responsibility: test generation only.\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating tests for code (len={len(code)})\")\n        prompt = (\n            \"You are a QA engineer. Given the Python implementation below, produce pytest tests that:\\n\"\n            \"1. Validate typical behavior\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Use clear test function names and docstrings\\n\\n\"\n            \"Implementation:\\n\"\n            f\"{code[:3000]}\\n\\n\"\n            \"Provide only pytest code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests length: {len(resp)}\")\n        return resp\n\nclass SimpleWriteReview(Action):\n    \"\"\"Reviews code and tests and returns concise actionable items.\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Starting review (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Please verify edge case handling and exceptions.\"\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise review of the implementation and tests below, focusing on:\\n\"\n                \"1. Correctness\\n\"\n                \"2. Missing edge cases\\n\"\n                \"3. Suggestions for fixes or improvements\\n\\n\"\n                f\"Code:\\n{code[:2000]}\\n\\nTests:\\n{tests[:2000]}\\n\\n\"\n                \"Return a short bullet list of actions to take.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            resp = await self._ask_with_retry(messages)\n            review = resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length: {len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Verifies syntactic correctness, basic cohesion between code and tests, and decides readiness.\n    Implements stronger validation and requires stable verification across rounds to avoid premature acceptance.\n    \"\"\"\n    name: str = \"SimpleVerify\"\n    stable_threshold: int = 2  # require this many consecutive PASS to accept\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Beginning verification\")\n        import ast\n        details = []\n        code_ok = False\n        tests_ok = False\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({str(e)[:200]})\")\n        # For tests, check that they exist and are syntactically correct\n        if tests and tests.strip():\n            try:\n                ast.parse(tests)\n                # Quick heuristic: check presence of pytest-style function names\n                if \"def test_\" in tests:\n                    tests_ok = True\n                    details.append(\"tests_syntax: ok\")\n                else:\n                    details.append(\"tests_syntax: fail (no test_ functions found)\")\n            except Exception as e:\n                details.append(f\"tests_syntax: fail ({str(e)[:200]})\")\n        else:\n            details.append(\"tests_syntax: fail (empty)\")\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(details)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class with explicit responsibilities and watch/trigger logic.\n    Each role has:\n    - name: human-readable agent name\n    - profile: the functional role\n    - watch_list: list of cause_by names (strings) that trigger this role\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        # env will be injected by Team.hire\n        self.env = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # Normalize to names for robust matching even if classes differ\n        self.watch_list = [a.name for a in actions]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action for this role.\n        Returns a Message object representing the result or None on no-op.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Invoking action {action.name} for message {getattr(message, 'id', 'init')}\")\n\n        try:\n            # Dispatch based on action type names for clarity\n            if action.name == SimpleWriteCode.name:\n                # Code writer expects instruct_content or fallback to content\n                idea = (message.instruct_content if getattr(message, 'instruct_content', None) else (message.content if message else \"\"))\n                result = await action.run(idea)\n            elif action.name == SimpleWriteTest.name:\n                code_text = message.content if message else \"\"\n                result = await action.run(code_text)\n            elif action.name == SimpleWriteReview.name:\n                # Find latest code and tests in env history deterministically\n                code_msg = None\n                tests_msg = None\n                if self.env:\n                    for msg in reversed(self.env.history):\n                        if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                            code_msg = msg\n                        if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                            tests_msg = msg\n                        if code_msg and tests_msg:\n                            break\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            elif action.name == SimpleVerify.name:\n                # Find latest code and tests\n                code_msg = None\n                tests_msg = None\n                if self.env:\n                    for msg in reversed(self.env.history):\n                        if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                            code_msg = msg\n                        if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                            tests_msg = msg\n                        if code_msg and tests_msg:\n                            break\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                result = await action.run(code_text, tests_text)\n            else:\n                result = \"NO_OP\"\n        except Exception as e:\n            # Catch unexpected errors in role processing and return an error message\n            err_text = f\"ROLE_ERROR: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err_text)\n            result = err_text\n\n        # Build response message with metadata for routing\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name,\n            sent_to=None\n        )\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message {response.id} cause_by={response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        # Verifier watches both code and tests; trigger when tests or code are updated\n        self._watch([SimpleWriteCode, SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment with explicit processed tracking to avoid duplicate processing.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track which (role_name, message_id) pairs have been processed\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish message and log it. Messages are appended to history; processing decisions are external.\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message {message.id} from {message.sent_from} cause_by={message.cause_by} content_len={len(message.content)}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        self.processed.add((role.name, message.id))\n        if self.tracer:\n            self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"Role {role.name} processed message {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages that match role.watch_list (by cause_by string).\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            if msg.cause_by in role.watch_list and not self.has_processed(role, msg):\n                relevant_messages.append(msg)\n        # Keep chronological order (oldest first)\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team orchestrator: explicit, ordered workflow with robust termination and verification stability.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # Verification stability tracking\n        self.verifier_streak = 0\n        self.required_stable_passes = 2  # require two consecutive PASS verification results\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _run_role_on_messages(self, role: Role, messages: List[Message]):\n        \"\"\"Helper to process messages for a role in FIFO order. Each message marked processed once acted upon.\"\"\"\n        for msg in messages:\n            # Role acts on message\n            resp = await role.act(msg)\n            # Mark input message processed regardless of success to avoid infinite loops\n            self.env.mark_processed(role, msg)\n            if resp:\n                # Publish role response for downstream roles\n                self.env.publish_message(resp)\n                # Log\n                if self.tracer:\n                    self.tracer.log(\"TEAM_PUBLISH\", \"Team\", f\"Role {role.name} published message {resp.id} cause_by={resp.cause_by}\")\n                # If verifier produced a PASS, track streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    if self.tracer:\n                        self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"Consecutive PASS count is now {self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset streak on any non-pass (fail or error)\n                    if self.tracer:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"Verification failed or inconclusive; resetting streak from {self.verifier_streak} to 0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Main orchestration loop. Ensures deterministic sequence and stable verification termination.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n\n        # Initial message with the idea published by a User\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        # We will trigger coder on initial message (even though coder does not strictly watch 'UserInput')\n        # Also allow multiple rounds but require stable verification to stop early.\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            # 1) Coder: On first round or if there is new user instruction not yet processed by coder\n            coders = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n            for coder in coders:\n                # find any UserInput messages not yet processed by coder\n                msgs = [m for m in self.env.history if m.cause_by == \"UserInput\" and not self.env.has_processed(coder, m)]\n                # If no explicit user input, coder can run in subsequent rounds only if there's reviewer feedback; else skip\n                if not msgs:\n                    # Allow coder to re-run if previous review suggests changes (watch for reviewer messages)\n                    msgs = self.env.get_messages_for_role(coder)\n                if msgs:\n                    await self._run_role_on_messages(coder, msgs)\n\n            # 2) Tester: respond to latest unprocessed code messages\n            testers = [r for r in self.env.roles if isinstance(r, SimpleTester)]\n            for tester in testers:\n                msgs = self.env.get_messages_for_role(tester)\n                if msgs:\n                    await self._run_role_on_messages(tester, msgs)\n\n            # 3) Reviewer: respond to tests produced\n            reviewers = [r for r in self.env.roles if isinstance(r, SimpleReviewer)]\n            for reviewer in reviewers:\n                msgs = self.env.get_messages_for_role(reviewer)\n                if msgs:\n                    await self._run_role_on_messages(reviewer, msgs)\n\n            # 4) Verifier: respond to code or test updates\n            verifiers = [r for r in self.env.roles if isinstance(r, SimpleVerifier)]\n            for verifier in verifiers:\n                msgs = self.env.get_messages_for_role(verifier)\n                if msgs:\n                    await self._run_role_on_messages(verifier, msgs)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed. verifier_streak={self.verifier_streak}\")\n\n            # Termination: require stable consecutive PASSes to avoid premature acceptance.\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} consecutive rounds; stopping early\")\n                break\n\n        # Final summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n\n### Program 3 (Score: 3.2125)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\n\nclass Action(ABC):\n    \"\"\"Base action class: defines responsibilities and retry helpers\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 2\n    retry_backoff: float = 0.5  # seconds (used in async sleeps)\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            try:\n                self.llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries on transient errors or explicit error responses.\"\"\"\n        last_err = None\n        for attempt in range(self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # deterministic fallback\n                    return \"LLM-FALLBACK: Generated content (fallback).\"\n                resp = await self.llm.ask(messages)\n                # Consider responses that start with 'Error' or contain 'Error communicating' as failures\n                if isinstance(resp, str) and (resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower()):\n                    last_err = resp\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt+1}: LLM error -> {resp[:200]}\")\n                    # backoff before retrying\n                    await asyncio.sleep(self.retry_backoff * (attempt + 1))\n                    continue\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_EXCEPTION\", self.name, f\"Attempt {attempt+1}: Exception -> {last_err}\")\n                await asyncio.sleep(self.retry_backoff * (attempt + 1))\n        # If all retries fail, return a clear error marker\n        return f\"Error: LLM failed after {self.max_retries+1} attempts: {last_err}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements - Responsibility: produce initial implementation\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for idea (len={len(idea)}).\")\n\n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        code = await self._ask_with_retry(messages)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code length={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code - Responsibility: produce tests targeted at latest code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating tests for code (len={len(code)})\")\n\n        code_snippet = code[:2000] if code else \"\"\n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code_snippet}\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        tests = await self._ask_with_retry(messages)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests length={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests - Responsibility: provide actionable review items\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code/tests (human={self.is_human})\")\n\n        if self.is_human:\n            review = \"Human review: The code looks reasonable. Consider edge-case handling and clearer docstrings.\"\n        else:\n            snippet_code = code[:1500] if code else \"\"\n            snippet_tests = tests[:1500] if tests else \"\"\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{snippet_code}\n\nTests:\n{snippet_tests}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            review = await self._ask_with_retry(messages)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness - Responsibility: strong validation and stability checks\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Starting verification.\")\n\n        import ast\n        status = []\n        verified = False\n\n        # Basic structural checks\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n            code_ok = False\n        else:\n            try:\n                ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                code_ok = False\n                code_err = str(e)\n                status.append(f\"code_syntax: fail ({code_err[:120]})\")\n\n        # Tests checks: presence and basic syntax\n        if not tests or not tests.strip():\n            tests_ok = False\n            status.append(\"tests: empty\")\n        else:\n            try:\n                ast.parse(tests)\n                # heuristic: contain pytest style tests\n                if \"def test_\" in tests or \"pytest\" in tests:\n                    tests_ok = True\n                    status.append(\"tests_syntax: ok\")\n                else:\n                    tests_ok = False\n                    status.append(\"tests_syntax: ok_but_no_pytest_functions\")\n            except Exception as e:\n                tests_ok = False\n                tests_err = str(e)\n                status.append(f\"tests_syntax: fail ({tests_err[:120]})\")\n\n        # Additional static checks\n        if code_ok:\n            has_function = (\"def \" in code) or (\"class \" in code)\n            if not has_function:\n                status.append(\"code_smell: no functions/classes detected\")\n        # Decide verification\n        verified = code_ok and tests_ok\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with clear responsibilities and stateful message handling\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        # track processed message ids to avoid duplicate processing\n        self._processed_message_ids: Set[str] = set()\n        # env may be injected by Team.hire\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n\n    def _should_handle(self, msg: Message) -> bool:\n        \"\"\"Decide whether the role should handle the message based on watch list and send_to\"\"\"\n        # never handle messages already processed by this role\n        if getattr(msg, \"id\", None) in self._processed_message_ids:\n            return False\n        # If message explicitly targeted to this profile or role name\n        if getattr(msg, \"send_to\", None):\n            if (self.profile in msg.send_to) or (self.name in msg.send_to):\n                return True\n        # If message was caused by an action this role watches\n        for act in self.watch_list:\n            if msg.cause_by == act.name:\n                return True\n        # Default: do not handle\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"\n        Perform an action based on a message.\n        Responsibilities:\n        - Only handle messages that this role should handle.\n        - Use action-specific logic.\n        - Add error handling and retry on LLM/API failures.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]  # single-action role model\n\n        # If a message was provided ensure it's appropriate\n        if message and not self._should_handle(message):\n            # skip because not for this role\n            return None\n\n        # Log start\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Starting action {action.name} for message id={(message.id if message else 'init')}\")\n\n        # Execute with internal retry in case of transient LLM/API errors\n        try:\n            # Map action types to inputs\n            if isinstance(action, SimpleWriteCode):\n                instr = \"\"\n                if message:\n                    # prefer instruct_content for initial idea\n                    instr = getattr(message, \"instruct_content\", None) or message.content or \"\"\n                result = await action.run(instr)\n                # Create message to Tester primarily\n                send_to = { \"SimpleTester\" }\n                # also notify reviewer for early review if needed\n                send_to.add(\"SimpleReviewer\")\n\n            elif isinstance(action, SimpleWriteTest):\n                # expect code-containing message\n                code_text = \"\"\n                if message:\n                    code_text = message.content or \"\"\n                else:\n                    # try to find latest code in env\n                    if self.env:\n                        for msg in reversed(self.env.history):\n                            if msg.cause_by == SimpleWriteCode.name:\n                                code_text = msg.content\n                                break\n                result = await action.run(code_text)\n                send_to = { \"SimpleReviewer\" }\n\n            elif isinstance(action, SimpleWriteReview):\n                # need both code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if message:\n                    # If message is tests, find latest code; if code, find latest tests\n                    if message.cause_by == SimpleWriteTest.name:\n                        tests_text = message.content\n                        if self.env:\n                            for msg in reversed(self.env.history):\n                                if msg.cause_by == SimpleWriteCode.name:\n                                    code_text = msg.content\n                                    break\n                    else:\n                        # generic: try to collect both\n                        if self.env:\n                            for msg in reversed(self.env.history):\n                                if msg.cause_by == SimpleWriteCode.name and not code_text:\n                                    code_text = msg.content\n                                if msg.cause_by == SimpleWriteTest.name and not tests_text:\n                                    tests_text = msg.content\n                                if code_text and tests_text:\n                                    break\n                result = await action.run(code_text, tests_text)\n                # Reviewer notifies verifier\n                send_to = { \"SimpleVerifier\" }\n\n            elif isinstance(action, SimpleVerify):\n                # Verifier collects latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for msg in reversed(self.env.history):\n                        if msg.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = msg.content\n                        if msg.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = msg.content\n                        if code_text and tests_text:\n                            break\n                result = await action.run(code_text, tests_text)\n                send_to = set()  # verification is terminal; no automatic next send\n            else:\n                result = \"No-op\"\n                send_to = set()\n\n        except Exception as e:\n            # catch-all to avoid crashing the team run; publish an error message\n            err_txt = f\"Role {self.name} encountered exception: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, err_txt)\n            # Create an error response message\n            response = Message(\n                content=err_txt,\n                role=self.profile,\n                cause_by=(action.name if action else \"unknown\"),\n                sent_from=self.name\n            )\n            # mark as processed to avoid repeated attempts\n            if getattr(response, \"id\", None):\n                self._processed_message_ids.add(response.id)\n            return response\n\n        # Build response message and attach routing metadata\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name,\n            sent_from=self.name,\n            send_to=set(send_to)\n        )\n\n        # Mark input message as processed by this role (if provided)\n        if message and getattr(message, \"id\", None):\n            self._processed_message_ids.add(message.id)\n\n        # Also mark the response as processed to avoid reprocessing by same role\n        if getattr(response, \"id\", None):\n            self._processed_message_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action {action.name} produced message id={response.id} sent_to={response.send_to}\")\n\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Reviewer watches for tests primarily (to review tests) and can be triggered by code as well\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with explicit routing and message visibility\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        # Normalize send_to to a set for consistency\n        if not getattr(message, \"send_to\", None):\n            try:\n                message.send_to = set(message.send_to or [])\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {message.sent_from} (cause={message.cause_by}) -> {list(message.send_to)}; preview: {str(message.content)[:120]}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to.\n        Only returns messages that the role hasn't processed yet and that either:\n        - explicitly target the role (send_to)\n        - or were caused by an action that the role watches\n        \"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            try:\n                mid = getattr(msg, \"id\", None)\n                if mid and mid in role._processed_message_ids:\n                    continue\n                # Skip messages produced by the role itself\n                if getattr(msg, \"sent_from\", None) == role.name:\n                    continue\n                # explicit routing\n                if getattr(msg, \"send_to\", None):\n                    if (role.profile in msg.send_to) or (role.name in msg.send_to):\n                        relevant_messages.append(msg)\n                        continue\n                # watch-list routing\n                for watched_action in role.watch_list:\n                    if msg.cause_by == watched_action.name:\n                        relevant_messages.append(msg)\n                        break\n            except Exception:\n                # ignore broken message entries\n                continue\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together with robust orchestration and termination rules\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # track verification stability to avoid premature termination\n        self._last_verification_result: Optional[str] = None\n        self._verification_stable_count: int = 0\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _run_role_sequence(self, ordered_profiles: List[str], initial_msg: Message):\n        \"\"\"\n        Run one orchestrated sequence where each role may act if it has relevant messages.\n        The ordering ensures predictable interactions and reduces race conditions.\n        \"\"\"\n        # Publish initial message if provided\n        if initial_msg:\n            self.env.publish_message(initial_msg)\n\n        for profile in ordered_profiles:\n            roles = self.env.get_roles(profile)\n            for role in roles:\n                # collect messages relevant to this role\n                msgs = self.env.get_messages_for_role(role)\n                # process the most recent relevant message first\n                if msgs:\n                    for m in msgs:\n                        try:\n                            resp = await role.act(m)\n                            if resp:\n                                self.env.publish_message(resp)\n                        except Exception as e:\n                            # ensure role failures are logged and generate an error message but do not crash\n                            err = f\"Exception during role {role.name} act: {str(e)}\"\n                            self.tracer.log(\"ROLE_RUN_EXCEPTION\", role.name, err)\n                            err_msg = Message(content=err, role=role.profile, sent_from=role.name, cause_by=\"RoleException\")\n                            self.env.publish_message(err_msg)\n                else:\n                    # allow role to act without a specific message if it has an initial action (e.g., coder on first round)\n                    try:\n                        resp = await role.act(None)\n                        if resp:\n                            self.env.publish_message(resp)\n                    except Exception as e:\n                        err = f\"Exception during role {role.name} act (no-msg): {str(e)}\"\n                        self.tracer.log(\"ROLE_RUN_EXCEPTION\", role.name, err)\n                        err_msg = Message(content=err, role=role.profile, sent_from=role.name, cause_by=\"RoleException\")\n                        self.env.publish_message(err_msg)\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds with robust termination conditions\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n\n        # Initial message with the idea - targeted primarily at the SimpleCoder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        # Sequence order: Coder -> Tester -> Reviewer -> Verifier\n        order = [\"SimpleCoder\", \"SimpleTester\", \"SimpleReviewer\", \"SimpleVerifier\"]\n\n        verified = False\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            # Run orchestrated sequence - this function publishes initial_msg only on first round\n            await self._run_role_sequence(order, initial_msg if round_num == 0 else None)\n\n            # After sequence, check for verification messages in history\n            latest_verifier_msgs = [m for m in reversed(self.env.history) if m.cause_by == SimpleVerify.name]\n            if latest_verifier_msgs:\n                latest = latest_verifier_msgs[0]\n                content = latest.content or \"\"\n                # Simple parsing for PASS/FAIL\n                if \"VERIFICATION_RESULT: PASS\" in content:\n                    verified = True\n                    self.tracer.log(\"VERIFICATION_DETECTED\", \"Team\", f\"Verifier reported PASS at round {round_num+1}\")\n                    # Stop once verified with a stable verification (here 1 stable pass is considered sufficient)\n                    self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                    break\n                else:\n                    # continue rounds; log failure\n                    self.tracer.log(\"VERIFICATION_DETECTED\", \"Team\", f\"Verifier reported FAIL at round {round_num+1}: {content[:200]}\")\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n\n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 7.1111, Type: Migrant)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    \n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            code = await self.llm.ask(messages)\n        else:\n            code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} characters of code\")\n        \n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code[:2000]}  # Truncate if too long\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            tests = await self.llm.ask(messages)\n        else:\n            tests = f\"# Tests for the implementation\\n# [Tests would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} characters of tests\")\n        \n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        if self.is_human:\n            # Simulate human review\n            review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n            \n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            \n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review completed: {len(review)} characters\")\n        \n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n        try:\n            ast.parse(code)\n            code_ok = True\n        except Exception as e:\n            code_ok = False\n            code_err = str(e)\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n        except Exception as e:\n            tests_ok = False\n            tests_err = str(e)\n        status = []\n        if code_ok:\n            status.append(\"code_syntax: ok\")\n        else:\n            status.append(f\"code_syntax: fail ({code_err[:120]})\")\n        if tests_ok:\n            status.append(\"tests_syntax: ok\")\n        else:\n            status.append(f\"tests_syntax: fail ({(tests_err if 'tests_err' in locals() else 'empty')[:120]})\")\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        if not self.actions:\n            return None\n        \n        # Execute the first action (simplified)\n        action = self.actions[0]\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Executing action: {action.name}\")\n        \n        # Execute action based on type\n        if isinstance(action, SimpleWriteCode):\n            if message and hasattr(message, 'instruct_content'):\n                result = await action.run(message.instruct_content or message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteTest):\n            if message:\n                result = await action.run(message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteReview):\n            # For review, we need both code and tests\n            if message:\n                # Extract code and tests from previous messages (simplified)\n                result = await action.run(message.content, \"\")\n            else:\n                result = await action.run(\"\", \"\")\n        elif isinstance(action, SimpleVerify):\n            # For verification, try to find latest code and tests from history\n            env = getattr(self, 'env', None)\n            code_msg = None\n            tests_msg = None\n            if env:\n                for msg in reversed(env.history):\n                    if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                        code_msg = msg\n                    if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                        tests_msg = msg\n                    if code_msg and tests_msg:\n                        break\n            result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n        else:\n            result = \"Action completed\"\n        \n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed, message created\")\n        \n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", \n                          f\"Message from {message.sent_from}: {message.content[:100]}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            # Check if this message is from an action the role watches\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        verified = False\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Orchestrated sequence: Coder -> Tester -> Reviewer -> Verifier\n            for role in self.env.roles:\n                if isinstance(role, SimpleCoder):\n                    response = await role.act(initial_msg if round_num == 0 else None)\n                    if response:\n                        self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleTester):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleReviewer):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleVerifier):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n                            if \"VERIFICATION_RESULT: PASS\" in response.content:\n                                verified = True\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                break\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (5.000), Excellent total_failures (30.000)\n\n\n\n# Current Program\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nfrom typing import Tuple\n\n# Clearer responsibilities via docstrings, explicit watch/trigger logic, robust retries, and stable verification.\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry wrapper and standardized interface.\n    Responsibilities:\n    - Provide a run(...) coroutine that performs the action and returns a textual result.\n    - Use _ask_with_retry for LLM calls to reduce transient failure modes.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_llm_retries: int = 3\n    retry_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Ask the LLM with retry and exponential backoff. Returns final string or error string.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_llm_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\n                        \"LLM_CALL\",\n                        self.name,\n                        f\"Attempt {attempt}/{self.max_llm_retries} to invoke LLM\"\n                    )\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                else:\n                    resp = \"LLM unavailable: fallback response\"\n                # Detect common error signatures and retry\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # Backoff before retrying\n                await asyncio.sleep(self.retry_backoff * (2 ** (attempt - 1)))\n        # All retries exhausted\n        err_msg = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, err_msg)\n        return err_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a textual result.\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Writes code given an idea. Responsible only for generating the initial implementation.\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating code for idea (len={len(idea)})\")\n        prompt = (\n            \"You are a professional programmer. Write clean, production-ready Python code for the task below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Clear function-level code with docstrings\\n\"\n            \"2. Proper error handling and input validation\\n\"\n            \"3. Minimal dependencies\\n\"\n            \"4. Return only Python code without backticks or commentary\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code length: {len(resp)}\")\n        return resp\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produces pytest-style tests for given code. Focused responsibility: test generation only.\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating tests for code (len={len(code)})\")\n        prompt = (\n            \"You are a QA engineer. Given the Python implementation below, produce pytest tests that:\\n\"\n            \"1. Validate typical behavior\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Use clear test function names and docstrings\\n\\n\"\n            \"Implementation:\\n\"\n            f\"{code[:3000]}\\n\\n\"\n            \"Provide only pytest code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests length: {len(resp)}\")\n        return resp\n\nclass SimpleWriteReview(Action):\n    \"\"\"Reviews code and tests and returns concise actionable items.\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Starting review (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Please verify edge case handling and exceptions.\"\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise review of the implementation and tests below, focusing on:\\n\"\n                \"1. Correctness\\n\"\n                \"2. Missing edge cases\\n\"\n                \"3. Suggestions for fixes or improvements\\n\\n\"\n                f\"Code:\\n{code[:2000]}\\n\\nTests:\\n{tests[:2000]}\\n\\n\"\n                \"Return a short bullet list of actions to take.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            resp = await self._ask_with_retry(messages)\n            review = resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length: {len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Verifies syntactic correctness, basic cohesion between code and tests, and decides readiness.\n    Implements stronger validation and requires stable verification across rounds to avoid premature acceptance.\n    \"\"\"\n    name: str = \"SimpleVerify\"\n    stable_threshold: int = 2  # require this many consecutive PASS to accept\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Beginning verification\")\n        import ast\n        details = []\n        code_ok = False\n        tests_ok = False\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({str(e)[:200]})\")\n        # For tests, check that they exist and are syntactically correct\n        if tests and tests.strip():\n            try:\n                ast.parse(tests)\n                # Quick heuristic: check presence of pytest-style function names\n                if \"def test_\" in tests:\n                    tests_ok = True\n                    details.append(\"tests_syntax: ok\")\n                else:\n                    details.append(\"tests_syntax: fail (no test_ functions found)\")\n            except Exception as e:\n                details.append(f\"tests_syntax: fail ({str(e)[:200]})\")\n        else:\n            details.append(\"tests_syntax: fail (empty)\")\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(details)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class with explicit responsibilities and watch/trigger logic.\n    Each role has:\n    - name: human-readable agent name\n    - profile: the functional role\n    - watch_list: list of cause_by names (strings) that trigger this role\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        # env will be injected by Team.hire\n        self.env = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # Normalize to names for robust matching even if classes differ\n        self.watch_list = [a.name for a in actions]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action for this role.\n        Returns a Message object representing the result or None on no-op.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Invoking action {action.name} for message {getattr(message, 'id', 'init')}\")\n\n        try:\n            # Dispatch based on action type names for clarity\n            if action.name == SimpleWriteCode.name:\n                # Code writer expects instruct_content or fallback to content\n                idea = (message.instruct_content if getattr(message, 'instruct_content', None) else (message.content if message else \"\"))\n                result = await action.run(idea)\n            elif action.name == SimpleWriteTest.name:\n                code_text = message.content if message else \"\"\n                result = await action.run(code_text)\n            elif action.name == SimpleWriteReview.name:\n                # Find latest code and tests in env history deterministically\n                code_msg = None\n                tests_msg = None\n                if self.env:\n                    for msg in reversed(self.env.history):\n                        if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                            code_msg = msg\n                        if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                            tests_msg = msg\n                        if code_msg and tests_msg:\n                            break\n                result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n            elif action.name == SimpleVerify.name:\n                # Find latest code and tests\n                code_msg = None\n                tests_msg = None\n                if self.env:\n                    for msg in reversed(self.env.history):\n                        if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                            code_msg = msg\n                        if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                            tests_msg = msg\n                        if code_msg and tests_msg:\n                            break\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                result = await action.run(code_text, tests_text)\n            else:\n                result = \"NO_OP\"\n        except Exception as e:\n            # Catch unexpected errors in role processing and return an error message\n            err_text = f\"ROLE_ERROR: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err_text)\n            result = err_text\n\n        # Build response message with metadata for routing\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name,\n            sent_to=None\n        )\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message {response.id} cause_by={response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        # Verifier watches both code and tests; trigger when tests or code are updated\n        self._watch([SimpleWriteCode, SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment with explicit processed tracking to avoid duplicate processing.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track which (role_name, message_id) pairs have been processed\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish message and log it. Messages are appended to history; processing decisions are external.\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message {message.id} from {message.sent_from} cause_by={message.cause_by} content_len={len(message.content)}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        self.processed.add((role.name, message.id))\n        if self.tracer:\n            self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"Role {role.name} processed message {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages that match role.watch_list (by cause_by string).\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            if msg.cause_by in role.watch_list and not self.has_processed(role, msg):\n                relevant_messages.append(msg)\n        # Keep chronological order (oldest first)\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team orchestrator: explicit, ordered workflow with robust termination and verification stability.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # Verification stability tracking\n        self.verifier_streak = 0\n        self.required_stable_passes = 2  # require two consecutive PASS verification results\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _run_role_on_messages(self, role: Role, messages: List[Message]):\n        \"\"\"Helper to process messages for a role in FIFO order. Each message marked processed once acted upon.\"\"\"\n        for msg in messages:\n            # Role acts on message\n            resp = await role.act(msg)\n            # Mark input message processed regardless of success to avoid infinite loops\n            self.env.mark_processed(role, msg)\n            if resp:\n                # Publish role response for downstream roles\n                self.env.publish_message(resp)\n                # Log\n                if self.tracer:\n                    self.tracer.log(\"TEAM_PUBLISH\", \"Team\", f\"Role {role.name} published message {resp.id} cause_by={resp.cause_by}\")\n                # If verifier produced a PASS, track streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    if self.tracer:\n                        self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"Consecutive PASS count is now {self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset streak on any non-pass (fail or error)\n                    if self.tracer:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"Verification failed or inconclusive; resetting streak from {self.verifier_streak} to 0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Main orchestration loop. Ensures deterministic sequence and stable verification termination.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n\n        # Initial message with the idea published by a User\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        # We will trigger coder on initial message (even though coder does not strictly watch 'UserInput')\n        # Also allow multiple rounds but require stable verification to stop early.\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            # 1) Coder: On first round or if there is new user instruction not yet processed by coder\n            coders = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n            for coder in coders:\n                # find any UserInput messages not yet processed by coder\n                msgs = [m for m in self.env.history if m.cause_by == \"UserInput\" and not self.env.has_processed(coder, m)]\n                # If no explicit user input, coder can run in subsequent rounds only if there's reviewer feedback; else skip\n                if not msgs:\n                    # Allow coder to re-run if previous review suggests changes (watch for reviewer messages)\n                    msgs = self.env.get_messages_for_role(coder)\n                if msgs:\n                    await self._run_role_on_messages(coder, msgs)\n\n            # 2) Tester: respond to latest unprocessed code messages\n            testers = [r for r in self.env.roles if isinstance(r, SimpleTester)]\n            for tester in testers:\n                msgs = self.env.get_messages_for_role(tester)\n                if msgs:\n                    await self._run_role_on_messages(tester, msgs)\n\n            # 3) Reviewer: respond to tests produced\n            reviewers = [r for r in self.env.roles if isinstance(r, SimpleReviewer)]\n            for reviewer in reviewers:\n                msgs = self.env.get_messages_for_role(reviewer)\n                if msgs:\n                    await self._run_role_on_messages(reviewer, msgs)\n\n            # 4) Verifier: respond to code or test updates\n            verifiers = [r for r in self.env.roles if isinstance(r, SimpleVerifier)]\n            for verifier in verifiers:\n                msgs = self.env.get_messages_for_role(verifier)\n                if msgs:\n                    await self._run_role_on_messages(verifier, msgs)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed. verifier_streak={self.verifier_streak}\")\n\n            # Termination: require stable consecutive PASSes to avoid premature acceptance.\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} consecutive rounds; stopping early\")\n                break\n\n        # Final summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nfrom typing import Tuple\n\n# Focus: clear roles, robust communication (watch + explicit routing), verification stability, and strong fallbacks.\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry and sanitization utilities.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_llm_retries: int = 3\n    retry_backoff: float = 0.75  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    def _log(self, event_type: str, details: str):\n        if self.context and self.context.tracer:\n            self.context.tracer.log(event_type, self.name, details)\n\n    def _sanitize_text(self, text: str) -> str:\n        \"\"\"Remove common non-code wrappers like markdown fences.\"\"\"\n        if not isinstance(text, str):\n            return \"\"\n        t = text.strip()\n        # Strip triple backtick blocks if present\n        if t.startswith(\"```\"):\n            # Remove any leading/trailing code fences\n            lines = t.splitlines()\n            # drop first and last fence lines if present\n            if lines and lines[0].startswith(\"```\"):\n                lines = lines[1:]\n            if lines and lines[-1].startswith(\"```\"):\n                lines = lines[:-1]\n            t = \"\\n\".join(lines).strip()\n        return t\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Ask the LLM with retry and exponential backoff. Returns final string or error string.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_llm_retries + 1):\n            try:\n                self._log(\"LLM_CALL\", f\"Attempt {attempt}/{self.max_llm_retries}\")\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                else:\n                    resp = \"LLM unavailable: fallback response\"\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return self._sanitize_text(resp)\n            except Exception as e:\n                last_err = str(e)\n                self._log(\"LLM_ERROR\", f\"Attempt {attempt} failed: {last_err}\")\n                await asyncio.sleep(self.retry_backoff * (2 ** (attempt - 1)))\n        err_msg = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        self._log(\"LLM_FINAL_FAILURE\", err_msg)\n        return err_msg\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a textual result.\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Writes code given an idea or revision instruction. Single responsibility: produce implementation.\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    def _fallback_code(self, idea: str) -> str:\n        \"\"\"Deterministic minimal yet production-like code to ensure progress when LLM fails.\"\"\"\n        return (\n            '\"\"\"Basic implementation generated as fallback.\"\"\"\\n'\n            \"from typing import Any, Iterable\\n\\n\"\n            \"def solve(task: str, data: Any = None) -> str:\\n\"\n            '    \\\"\\\"\\\"Solve the given task description.\\n'\n            \"    This is a fallback implementation that echoes inputs.\\n\"\n            \"    Args:\\n\"\n            \"        task: Task description\\n\"\n            \"        data: Optional payload\\n\"\n            \"    Returns:\\n\"\n            \"        A string result.\\n\"\n            \"    \\\"\\\"\\\"\\n\"\n            \"    if not isinstance(task, str):\\n\"\n            \"        raise TypeError('task must be a string')\\n\"\n            \"    return f\\\"Task: {task.strip()} | Data: {str(data)[:100]}\\\"\\n\"\n        )\n\n    async def run(self, idea: str) -> str:\n        self._log(\"ACTION_START\", f\"Generating code for idea len={len(idea)}\")\n        prompt = (\n            \"You are a professional programmer. Write clean, production-ready Python code for the task below.\\n\\n\"\n            f\"Task/Revision Instructions:\\n{idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Provide well-structured functions with docstrings\\n\"\n            \"2. Validate inputs and handle errors\\n\"\n            \"3. Avoid external dependencies unless necessary\\n\"\n            \"4. Return only Python code (no fences or commentary)\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self._ask_with_retry(messages)\n        if resp.startswith(\"LLM_FAILED_AFTER_RETRIES\") or resp.startswith(\"LLM unavailable\") or resp.lower().startswith(\"error\"):\n            resp = self._fallback_code(idea)\n            self._log(\"ACTION_FALLBACK\", \"Using deterministic fallback code\")\n        self._log(\"ACTION_END\", f\"Generated code length: {len(resp)}\")\n        return resp\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produces pytest tests for given code. Single responsibility: test generation.\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    def _fallback_tests(self) -> str:\n        return (\n            \"import pytest\\n\\n\"\n            \"from types import ModuleType\\n\"\n            \"import importlib.util\\n\"\n            \"import sys\\n\\n\"\n            \"def _load_module_from_string(code: str, name: str = 'mod') -> ModuleType:\\n\"\n            \"    spec = importlib.util.spec_from_loader(name, loader=None)\\n\"\n            \"    module = importlib.util.module_from_spec(spec)\\n\"\n            \"    exec(code, module.__dict__)\\n\"\n            \"    return module\\n\\n\"\n            \"def test_solve_exists_and_handles_str():\\n\"\n            \"    code = __import__('builtins').__dict__.get('__CODE_UNDER_TEST__', '')\\n\"\n            \"    mod = _load_module_from_string(code)\\n\"\n            \"    assert hasattr(mod, 'solve')\\n\"\n            \"    assert callable(mod.solve)\\n\"\n            \"    out = mod.solve('sample task', {'k': 'v'})\\n\"\n            \"    assert isinstance(out, str)\\n\"\n            \"    assert 'sample task' in out\\n\"\n        )\n\n    async def run(self, code: str) -> str:\n        self._log(\"ACTION_START\", f\"Generating tests for code len={len(code)}\")\n        prompt = (\n            \"You are a QA engineer. Given the Python implementation below, produce pytest tests that:\\n\"\n            \"1. Validate typical behavior\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Use clear test names and docstrings\\n\\n\"\n            f\"Implementation:\\n{code[:3000]}\\n\\n\"\n            \"Provide only pytest code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        resp = await self._ask_with_retry(messages)\n        if resp.startswith(\"LLM_FAILED_AFTER_RETRIES\") or resp.startswith(\"LLM unavailable\") or resp.lower().startswith(\"error\"):\n            resp = self._fallback_tests()\n            self._log(\"ACTION_FALLBACK\", \"Using deterministic fallback tests\")\n        self._log(\"ACTION_END\", f\"Generated tests length: {len(resp)}\")\n        return resp\n\nclass SimpleWriteReview(Action):\n    \"\"\"Reviews code and tests and returns concise actionable feedback.\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        self._log(\"ACTION_START\", f\"Starting review (human={self.is_human})\")\n        if self.is_human:\n            review = \"- Ensure input validation and explicit error messages\\n- Add edge-case tests for empty inputs\"\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise review of the implementation and tests below, focusing on:\\n\"\n                \"1. Correctness and clarity\\n\"\n                \"2. Missing edge cases\\n\"\n                \"3. Concrete actions to improve code and tests\\n\\n\"\n                f\"Code:\\n{code[:2000]}\\n\\nTests:\\n{tests[:2000]}\\n\\n\"\n                \"Return a short bullet list of actions.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            review = await self._ask_with_retry(messages)\n            if review.startswith(\"LLM_FAILED_AFTER_RETRIES\") or review.startswith(\"LLM unavailable\") or review.lower().startswith(\"error\"):\n                review = \"- Code structure acceptable; add explicit type checks\\n- Add tests for invalid inputs and boundary conditions\"\n                self._log(\"ACTION_FALLBACK\", \"Using deterministic fallback review\")\n        self._log(\"ACTION_END\", f\"Review length: {len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Verifies code and tests for syntax and basic cohesion; returns PASS/FAIL with details.\"\"\"\n    name: str = \"SimpleVerify\"\n    stable_threshold: int = 2  # not used internally; used by Team for termination stability\n\n    async def run(self, code: str, tests: str) -> str:\n        self._log(\"ACTION_START\", \"Beginning verification\")\n        import ast\n\n        details = []\n        code_ok = False\n        tests_ok = False\n\n        # Sanitize\n        code = self._sanitize_text(code or \"\")\n        tests = self._sanitize_text(tests or \"\")\n\n        # Code syntax + structure\n        if not code.strip():\n            details.append(\"code: empty\")\n        else:\n            try:\n                tree = ast.parse(code)\n                code_ok = True\n                details.append(\"code_syntax: ok\")\n                # Structural check: at least one function or class\n                has_def = any(isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)) for n in tree.body)\n                if has_def:\n                    details.append(\"code_structure: function_or_class_present\")\n                else:\n                    code_ok = False\n                    details.append(\"code_structure: missing functions/classes\")\n            except Exception as e:\n                details.append(f\"code_syntax: fail ({str(e)[:200]})\")\n\n        # Tests syntax + heuristics\n        if not tests.strip():\n            details.append(\"tests: empty\")\n        else:\n            try:\n                ttree = ast.parse(tests)\n                details.append(\"tests_syntax: ok\")\n                # Heuristics: presence of test_ or assert\n                tests_have_fn = \"def test_\" in tests\n                tests_have_assert = \"assert \" in tests\n                if tests_have_fn or tests_have_assert:\n                    tests_ok = True\n                    details.append(\"tests_semantics: looks_like_pytest\")\n                else:\n                    details.append(\"tests_semantics: missing test_ or assert\")\n            except Exception as e:\n                details.append(f\"tests_syntax: fail ({str(e)[:200]})\")\n\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(details)\n        self._log(\"ACTION_END\", result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with explicit responsibility and watch/trigger logic.\n    watch_list contains cause_by names (strings). Explicit routing via send_to is also honored.\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env = None  # injected by Team\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # Normalize to names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _log(self, event_type: str, details: str):\n        if self.context and self.context.tracer:\n            self.context.tracer.log(event_type, self.name, details)\n\n    def _find_latest_by_cause(self, cause_by: str) -> Optional[Message]:\n        if not self.env:\n            return None\n        for msg in reversed(self.env.history):\n            if msg.cause_by == cause_by:\n                return msg\n        return None\n\n    def _find_initial_idea(self) -> str:\n        if not self.env:\n            return \"\"\n        for msg in self.env.history:\n            if msg.cause_by == \"UserInput\":\n                return (msg.instruct_content or msg.content or \"\").strip()\n        return \"\"\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action for this role.\"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n        self._log(\"ROLE_ACT\", f\"Invoking action {action.name} for msg={getattr(message, 'id', 'init')}\")\n\n        try:\n            send_to: Set[str] = set()\n\n            if action.name == SimpleWriteCode.name:\n                # Build instruction: initial idea or revision based on review\n                if message and message.cause_by == SimpleWriteReview.name:\n                    # Pull original idea and latest code for context\n                    idea = self._find_initial_idea()\n                    latest_code_msg = self._find_latest_by_cause(SimpleWriteCode.name)\n                    latest_code = latest_code_msg.content if latest_code_msg else \"\"\n                    review = message.content\n                    combined = (\n                        f\"{idea}\\n\\n\"\n                        \"Please revise the existing implementation according to this review:\\n\"\n                        f\"{review}\\n\\n\"\n                        \"Existing implementation:\\n\"\n                        f\"{latest_code[:3000]}\"\n                    )\n                    result = await action.run(combined)\n                else:\n                    # initial or generic\n                    idea = (message.instruct_content if getattr(message, 'instruct_content', None) else (message.content if message else self._find_initial_idea()))\n                    result = await action.run(idea or \"\")\n                send_to = {\"SimpleTester\", \"SimpleReviewer\"}\n\n            elif action.name == SimpleWriteTest.name:\n                # Use latest code if message not directly code\n                code_text = \"\"\n                if message and message.cause_by == SimpleWriteCode.name:\n                    code_text = message.content\n                else:\n                    code_msg = self._find_latest_by_cause(SimpleWriteCode.name)\n                    code_text = code_msg.content if code_msg else \"\"\n                result = await action.run(code_text)\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n\n            elif action.name == SimpleWriteReview.name:\n                # Need both code and tests\n                code_msg = self._find_latest_by_cause(SimpleWriteCode.name)\n                tests_msg = self._find_latest_by_cause(SimpleWriteTest.name)\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                result = await action.run(code_text, tests_text)\n                send_to = {\"SimpleCoder\", \"SimpleVerifier\"}\n\n            elif action.name == SimpleVerify.name:\n                code_msg = self._find_latest_by_cause(SimpleWriteCode.name)\n                tests_msg = self._find_latest_by_cause(SimpleWriteTest.name)\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                result = await action.run(code_text, tests_text)\n                send_to = set()\n\n            else:\n                result = \"NO_OP\"\n                send_to = set()\n\n        except Exception as e:\n            err_text = f\"ROLE_ERROR: {str(e)}\"\n            self._log(\"ROLE_EXCEPTION\", err_text)\n            result = err_text\n            send_to = set()\n\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name,\n            send_to=set(send_to)\n        )\n\n        self._log(\"ROLE_COMPLETE\", f\"Produced message {response.id} cause_by={response.cause_by} send_to={list(send_to)}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder reacts to review feedback\n        self._watch([SimpleWriteReview])\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteCode, SimpleWriteTest, SimpleWriteReview])\n\nclass Environment:\n    \"\"\"Environment with routing and processed tracking to avoid duplicates.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        self.processed: Set[Tuple[str, str]] = set()  # (role_name, message_id)\n\n    def add_role(self, role: Role):\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\n                \"ENV_MESSAGE\",\n                \"Environment\",\n                f\"Message {message.id} from {message.sent_from} cause_by={message.cause_by} send_to={list(message.send_to or [])} len={len(message.content)}\"\n            )\n\n    def mark_processed(self, role: Role, message: Message):\n        self.processed.add((role.name, message.id))\n        if self.tracer:\n            self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"Role {role.name} processed message {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages that match explicit routing or watch_list.\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if self.has_processed(role, msg):\n                continue\n            if msg.sent_from == role.name:\n                continue\n            # Explicit routing wins\n            if getattr(msg, \"send_to\", None):\n                if role.profile in msg.send_to or role.name in msg.send_to:\n                    out.append(msg)\n                    continue\n            # Otherwise watch-list by cause\n            if msg.cause_by in role.watch_list:\n                out.append(msg)\n        return out\n\nclass Team:\n    \"\"\"Team orchestrator with explicit sequence, verification stability, and heartbeat rechecks.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self.verifier_streak = 0\n        self.required_stable_passes = 2  # stable consecutive PASSes needed\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _run_role_on_messages(self, role: Role, messages: List[Message]) -> int:\n        \"\"\"Process messages for a role in FIFO order; returns number of responses published.\"\"\"\n        produced = 0\n        for msg in messages:\n            resp = await role.act(msg)\n            # Mark input message processed to avoid loops\n            self.env.mark_processed(role, msg)\n            if resp:\n                self.env.publish_message(resp)\n                produced += 1\n                if isinstance(role, SimpleVerifier):\n                    content = resp.content or \"\"\n                    if \"VERIFICATION_RESULT: PASS\" in content:\n                        self.verifier_streak += 1\n                        self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"Consecutive PASS now {self.verifier_streak}\")\n                    else:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"Verification not PASS -> reset streak\")\n                        self.verifier_streak = 0\n        return produced\n\n    async def _verifier_heartbeat(self) -> int:\n        \"\"\"If we have at least one PASS but not enough stable passes, re-run verifier on latest state to confirm.\"\"\"\n        produced = 0\n        verifiers = [r for r in self.env.roles if isinstance(r, SimpleVerifier)]\n        for verifier in verifiers:\n            resp = await verifier.act(None)\n            if resp:\n                self.env.publish_message(resp)\n                produced += 1\n                content = resp.content or \"\"\n                if \"VERIFICATION_RESULT: PASS\" in content:\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"Heartbeat PASS -> streak {self.verifier_streak}\")\n                else:\n                    self.tracer.log(\"VERIFIER_RESET\", \"Team\", \"Heartbeat not PASS -> reset streak\")\n                    self.verifier_streak = 0\n        return produced\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Main orchestration loop with robust termination after verified stability.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n\n        # Initial idea message, routed to coder primarily\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            # 1) Coder: on initial user input or review feedback\n            for coder in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                # Unprocessed user inputs for coder\n                user_msgs = [m for m in self.env.history if m.cause_by == \"UserInput\" and not self.env.has_processed(coder, m)]\n                msgs = user_msgs or self.env.get_messages_for_role(coder)\n                if msgs:\n                    await self._run_role_on_messages(coder, msgs)\n\n            # 2) Tester: respond to new code\n            for tester in [r for r in self.env.roles if isinstance(r, SimpleTester)]:\n                msgs = self.env.get_messages_for_role(tester)\n                if msgs:\n                    await self._run_role_on_messages(tester, msgs)\n\n            # 3) Reviewer: respond to tests or code\n            for reviewer in [r for r in self.env.roles if isinstance(r, SimpleReviewer)]:\n                msgs = self.env.get_messages_for_role(reviewer)\n                if msgs:\n                    await self._run_role_on_messages(reviewer, msgs)\n\n            # 4) Verifier: respond to code, tests, or review updates\n            verifier_acted = 0\n            for verifier in [r for r in self.env.roles if isinstance(r, SimpleVerifier)]:\n                msgs = self.env.get_messages_for_role(verifier)\n                if msgs:\n                    verifier_acted += await self._run_role_on_messages(verifier, msgs)\n\n            # Heartbeat re-check to avoid premature acceptance and ensure stability\n            if self.verifier_streak > 0 and self.verifier_streak < self.required_stable_passes and verifier_acted == 0:\n                self.tracer.log(\"VERIFIER_HEARTBEAT\", \"Team\", \"No verifier activity; running heartbeat check\")\n                await self._verifier_heartbeat()\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed. verifier_streak={self.verifier_streak}\")\n\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} consecutive passes; stopping early\")\n                break\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}