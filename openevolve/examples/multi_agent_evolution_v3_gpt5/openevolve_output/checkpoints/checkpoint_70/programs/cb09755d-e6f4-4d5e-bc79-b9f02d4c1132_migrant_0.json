{"id": "cb09755d-e6f4-4d5e-bc79-b9f02d4c1132_migrant_0", "code": "# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport random\nimport time\n\nclass Action(ABC):\n    \"\"\"\n    Base action class.\n    - Provides robust LLM call with exponential backoff, jitter, and clear error handling.\n    - Actions are pure units of work that take inputs and return outputs (strings).\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 0.5\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"\n        Call the LLM with retries, exponential backoff and jitter.\n        Returns either the LLM string response or a structured error string starting with \"LLM_ERROR:\".\n        \"\"\"\n        import asyncio\n\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # Deterministic fallback for offline runs\n                    response = \"LLM_FALLBACK: no-llm-available\"\n                else:\n                    response = await self.llm.ask(messages)\n\n                # Detect common LLM error patterns\n                if not isinstance(response, str) or response.strip() == \"\":\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                if response.strip().lower().startswith(\"error\") or \"http\" in response and \"error\" in response.lower():\n                    last_err = response\n                    raise RuntimeError(f\"LLM returned error-like text: {response[:200]}\")\n\n                # Log success\n                if self.context and getattr(self.context, \"tracer\", None):\n                    self.context.tracer.log(\"LLM_OK\", self.name, f\"Attempt {attempt} succeeded (len={len(response)})\")\n                return response\n\n            except Exception as exc:\n                last_err = str(exc)\n                if self.context and getattr(self.context, \"tracer\", None):\n                    self.context.tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                # Backoff with jitter\n                if attempt < self.max_retries:\n                    backoff = self.base_backoff * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n                else:\n                    if self.context and getattr(self.context, \"tracer\", None):\n                        self.context.tracer.log(\"LLM_GIVEUP\", self.name, f\"Giving up after {self.max_retries} attempts: {last_err[:200]}\")\n        return f\"LLM_ERROR: {last_err}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a string result.\"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and getattr(self.context, \"tracer\", None):\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating code for idea (len={len(idea)})\")\n        prompt = (\n            \"You are an expert Python developer.\\n\"\n            \"Task:\\n\"\n            f\"{idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Provide production-ready Python code.\\n\"\n            \"- Include docstrings and input validation where appropriate.\\n\"\n            \"- Keep functions small and testable.\\n\"\n            \"- Return only the Python code.\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._llm_call(messages)\n        # Basic sanity checks and fallback\n        if result.startswith(\"LLM_ERROR\"):\n            fallback = f\"# ERROR: unable to generate code automatically. {result}\\n\\n# Placeholder function\\n\\ndef placeholder():\\n    \\\"\\\"\\\"Placeholder due to LLM failure.\\\"\\\"\\\"\\n    return None\\n\"\n            if self.context and getattr(self.context, \"tracer\", None):\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Using placeholder code due to LLM error\")\n            return fallback\n        return result\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and getattr(self.context, \"tracer\", None):\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Generating tests for code (len={len(code)})\")\n        truncated = (code or \"\")[:4000]\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided Python code.\\n\\n\"\n            \"Code:\\n\"\n            f\"{truncated}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Provide pytest test functions with clear assertions and docstrings.\\n\"\n            \"- Cover typical, boundary and error cases when applicable.\\n\"\n            \"- Return only pytest-compatible Python code.\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._llm_call(messages)\n        if result.startswith(\"LLM_ERROR\"):\n            note = f\"# ERROR_GENERATING_TESTS: {result}\\n# Tests not generated due to LLM error.\\n\"\n            if self.context and getattr(self.context, \"tracer\", None):\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Using placeholder test note due to LLM error\")\n            return note\n        return result\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and getattr(self.context, \"tracer\", None):\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code/tests (human={self.is_human})\")\n        if self.is_human:\n            return \"HUMAN_REVIEW: recommended manual review.\"\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review and a readiness verdict.\\n\\n\"\n            \"Code (truncated):\\n\"\n            f\"{(code or '')[:2000]}\\n\\n\"\n            \"Tests (truncated):\\n\"\n            f\"{(tests or '')[:2000]}\\n\\n\"\n            \"Return:\\n- A short list of issues (if any)\\n- Checklist of fixes\\n- VERDICT: READY or NOT_READY (single line at the end prefixed by VERDICT:)\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._llm_call(messages)\n        if result.startswith(\"LLM_ERROR\"):\n            fallback = \"REVIEW_ERROR: Review could not be completed due to LLM failure.\"\n            if self.context and getattr(self.context, \"tracer\", None):\n                self.context.tracer.log(\"ACTION_FALLBACK\", self.name, \"Review fallback due to LLM error\")\n            return fallback\n        return result\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"\n        Deterministic verification using static analysis heuristics.\n        Returns a structured verification result string.\n        \"\"\"\n        import ast\n        issues: List[str] = []\n        code_ok = False\n        tests_ok = False\n\n        if self.context and getattr(self.context, \"tracer\", None):\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Starting verification\")\n\n        # Code syntax check\n        if not code or not code.strip():\n            issues.append(\"code_missing_or_empty\")\n        else:\n            try:\n                parsed = ast.parse(code)\n                code_ok = True\n                fn_names = [n.name for n in parsed.body if isinstance(n, ast.FunctionDef)]\n            except Exception as e:\n                issues.append(f\"code_syntax_error: {e}\")\n                fn_names = []\n\n        # Tests syntax and heuristics\n        if not tests or not tests.strip():\n            issues.append(\"tests_missing_or_empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristics: tests must contain 'assert' and at least one function named test_\n                contains_assert = \"assert \" in tests or \"pytest\" in tests.lower()\n                test_fns = [n.name for n in parsed_tests.body if isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\")]\n                tests_ok = bool(contains_assert and test_fns)\n                if not contains_assert:\n                    issues.append(\"tests_missing_asserts\")\n                if not test_fns:\n                    issues.append(\"tests_missing_test_functions\")\n            except Exception as e:\n                issues.append(f\"tests_syntax_error: {e}\")\n\n        # Ensure tests reference code functions when possible\n        references_code = False\n        if code_ok and tests_ok and fn_names:\n            for fn in fn_names:\n                if fn and fn in (tests or \"\"):\n                    references_code = True\n                    break\n            if not references_code:\n                issues.append(\"tests_do_not_reference_code\")\n\n        verified = code_ok and tests_ok and (references_code or not fn_names)\n        result = {\n            \"verified\": verified,\n            \"code_ok\": code_ok,\n            \"tests_ok\": tests_ok,\n            \"issues\": issues\n        }\n        summary = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | details: {result}\"\n        if self.context and getattr(self.context, \"tracer\", None):\n            self.context.tracer.log(\"ACTION_END\", self.name, summary)\n        return summary\n\n\nclass Role(ABC):\n    \"\"\"\n    Clear role definition and responsibilities.\n    - Each role has a small set of actions.\n    - Each role maintains processed message ids to avoid duplicate work.\n    - Roles define watch_list (action names) and default recipients for produced messages.\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # watch action names\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env = kwargs.get('env', None)\n        self._processed_message_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        \"\"\"\n        Decide whether the role should respond:\n        - Not already processed\n        - Explicitly addressed via send_to or sent_to\n        - Message cause_by matches watched actions\n        - Human user instructions target coders by default\n        \"\"\"\n        if not message:\n            return False\n        if hasattr(message, \"id\") and message.id in self._processed_message_ids:\n            return False\n        # explicit addressing: either send_to set contains profile/name, or sent_to string matches\n        sent_to_set = getattr(message, \"send_to\", None)\n        if sent_to_set:\n            if isinstance(sent_to_set, (set, list)) and (self.profile in sent_to_set or self.name in sent_to_set or \"*\" in sent_to_set):\n                return True\n        sent_to_str = getattr(message, \"sent_to\", None)\n        if isinstance(sent_to_str, str) and (sent_to_str == self.profile or sent_to_str == self.name or sent_to_str == \"*\"):\n            return True\n        # watched action trigger\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input goes to coders\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"\n        Core action executor:\n        - Picks first applicable action and runs it.\n        - Records processed message id.\n        - Returns a Message with content, cause_by and intended send_to recipients.\n        - Robust error handling with retries for transient failures.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        if self.context and getattr(self.context, \"tracer\", None):\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Received message id={(getattr(message,'id',None))} cause_by={(getattr(message,'cause_by',None))}\")\n\n        # find message to act on (if provided)\n        if message is not None and not self.should_respond(message):\n            if self.context and getattr(self.context, \"tracer\", None):\n                self.context.tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message id={(getattr(message,'id',None))}\")\n            return None\n\n        action = self.actions[0]  # single-responsibility per role; keep simple\n        attempts = 0\n        last_err = None\n        while attempts < 2:\n            attempts += 1\n            try:\n                # Build inputs based on action type\n                if isinstance(action, SimpleWriteCode):\n                    instruct = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                    result = await action.run(instruct)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    # Prefer code from message or find latest code in environment\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    result = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    # Acquire latest code and tests from env if not supplied\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if code_text and tests_text:\n                                break\n                    result = await action.run(code_text, tests_text)\n                    recipients = {\"SimpleVerifier\", \"SimpleCoder\"}\n                elif isinstance(action, SimpleVerify):\n                    # collect latest code/tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    result = await action.run(code_text, tests_text)\n                    recipients = {\"Team\"}\n                else:\n                    result = await action.run()\n                    recipients = {\"Team\"}\n                # Mark message processed\n                if message and hasattr(message, \"id\"):\n                    self._processed_message_ids.add(message.id)\n                # Create response message with clear routing\n                response = Message(\n                    content=result,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if self.context and getattr(self.context, \"tracer\", None):\n                    self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as exc:\n                last_err = str(exc)\n                if self.context and getattr(self.context, \"tracer\", None):\n                    self.context.tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:200]}\")\n                # small backoff\n                time.sleep(0.1 * attempts)\n        # If here, role failed reliably\n        fail_msg = f\"ROLE_FAILED: {self.name} after retries. Error={last_err}\"\n        if self.context and getattr(self.context, \"tracer\", None):\n            self.context.tracer.log(\"ROLE_FAIL\", self.name, fail_msg)\n        response = Message(\n            content=fail_msg,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])  # primarily triggered by UserInput or explicit addressing\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])  # run when code is available\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview])\n\n\nclass Environment:\n    \"\"\"\n    Environment handles message publication and routing.\n    - Maintains history (ordered).\n    - Provides messages relevant to a role using explicit send_to and watch_list rules.\n    \"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # Ensure ID exists\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"\n        Return messages a role should consider:\n        - Explicitly addressed messages (send_to / sent_to)\n        - Messages whose cause_by matches role.watch_list\n        - Exclude messages already processed by the role\n        \"\"\"\n        relevant: List[Message] = []\n        for msg in self.history:\n            if hasattr(msg, \"id\") and msg.id in getattr(role, \"_processed_message_ids\", set()):\n                continue\n            # explicit addressing via send_to (preferred)\n            sent_to = getattr(msg, \"send_to\", None)\n            if sent_to:\n                if isinstance(sent_to, (set, list)) and (role.profile in sent_to or role.name in sent_to or \"*\" in sent_to):\n                    relevant.append(msg)\n                    continue\n            # explicit sent_to string field\n            sent_to_str = getattr(msg, \"sent_to\", None)\n            if isinstance(sent_to_str, str) and (sent_to_str == role.profile or sent_to_str == role.name or sent_to_str == \"*\"):\n                relevant.append(msg)\n                continue\n            # watch_list triggers\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n                continue\n        return relevant\n\n\nclass Team:\n    \"\"\"\n    Team orchestrates roles, sequencing, termination, and verification confirmation logic.\n    - Requires multiple independent verification confirmations to avoid premature termination.\n    - Tracks progress and stops on verification PASS or prolonged no-progress.\n    \"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # require confirmations from verifiers (could be same verifier across rounds)\n        self._verify_confirm_count = 0\n        self._verify_confirm_needed = 2\n        # track unique verifiers or rounds that produced PASS to reduce false positives\n        self._verify_pass_rounds: Set[int] = set()\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        import asyncio\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; need {self._verify_confirm_needed} confirmations to stop early\")\n\n        # Initial User instruction directed to coder(s)\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        for round_idx in range(n_round):\n            round_num = round_idx + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            progress_made = False\n\n            # Evaluate each role; roles decide if they act based on environment messages\n            for role in list(self.env.roles):\n                # Gather messages relevant to this role\n                msgs = self.env.get_messages_for_role(role)\n                # On first round, ensure coder sees the initial instruction even if not in msgs\n                if isinstance(role, SimpleCoder) and round_idx == 0:\n                    msgs = [initial_msg] + msgs\n                # Process messages in order; roles may produce one message per input to keep steps atomic\n                for msg in msgs:\n                    try:\n                        resp = await role.act(msg)\n                        if resp:\n                            self.env.publish_message(resp)\n                            progress_made = True\n                            # If verifier response contains a PASS, count confirmation\n                            if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                if \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                    self._verify_confirm_count += 1\n                                    self._verify_pass_rounds.add(round_idx)\n                                    self.tracer.log(\"VERIFY_CONFIRM\", \"Team\", f\"Verifier {role.name} PASS ({self._verify_confirm_count}/{self._verify_confirm_needed})\")\n                                    if self._verify_confirm_count >= self._verify_confirm_needed:\n                                        verified = True\n                                elif \"VERIFICATION_RESULT: FAIL\" in resp.content:\n                                    # reset confirmations on explicit fail\n                                    self._verify_confirm_count = 0\n                                    self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Verifier {role.name} reported FAIL; confirmations reset\")\n                            # Log role failures directed to team\n                            if isinstance(resp.content, str) and resp.content.startswith(\"ROLE_FAILED\"):\n                                self.tracer.log(\"TEAM_NOTE\", \"Team\", f\"Role failure: {resp.content[:200]}\")\n                    except Exception as e:\n                        self.tracer.log(\"ROUND_ERROR\", role.name, f\"Exception during role.act: {e}\")\n\n            # Determine progress/no-progress and update termination conditions\n            if len(self.env.history) == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} complete (progress={progress_made})\")\n\n            # Termination: require at least one full round and required confirmations\n            if verified and round_num >= 1:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification confirmed after {self._verify_confirm_count} confirmations; stopping\")\n                break\n\n            # Stop if no progress for multiple rounds to avoid wasting cycles\n            if no_progress_rounds >= 2:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No progress for 2 consecutive rounds; terminating early\")\n                break\n\n            # allow small async pause\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        summary = f\"Project '{self.idea}' finished after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "cb09755d-e6f4-4d5e-bc79-b9f02d4c1132", "generation": 2, "timestamp": 1754656352.3791902, "iteration_found": 0, "metrics": {"runs_successfully": 1.0, "overall_score": 0.5, "combined_score": 0.31578947368421056, "avg_failures_per_task": 2.1666666666666665, "total_failures": 13.0, "successful_runs": 6.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 0, "migrant": true}, "artifacts_json": null, "artifact_dir": null}