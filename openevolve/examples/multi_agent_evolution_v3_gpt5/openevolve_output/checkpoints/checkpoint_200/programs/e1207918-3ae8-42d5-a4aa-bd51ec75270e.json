{"id": "e1207918-3ae8-42d5-a4aa-bd51ec75270e", "code": "\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"LLM_UNAVAILABLE_FALLBACK: deterministic placeholder response\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nimport random\nfrom typing import Tuple, Iterable\n\n# Goals implemented (MAST-oriented):\n# - Clear role definitions and single-responsibility actions\n# - Robust communication: explicit send_to + watch/trigger logic\n# - Idempotent routing: per-role delivery tracking\n# - Strong verification with syntax, tests presence, cross-reference, and digest\n# - Error handling with LLM/API retries/backoff + deterministic fallbacks\n# - Safe termination: require consecutive verified passes with stable digest; stall detection and nudges\n\n# Tunables\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5  # seconds\nROLE_MAX_ATTEMPTS = 2\nREQUIRED_STABLE_PASSES = 2\nNO_PROGRESS_GRACE = 2  # rounds without new messages before stopping\n\n# ---------------------------\n# Actions\n# ---------------------------\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call helper and simple contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def ask_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries/backoff/jitter. On failure return 'LLM_ERROR:<reason>'.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, \"LLM not configured; using deterministic error\")\n            return \"LLM_ERROR:unavailable\"\n        last_err = None\n        for attempt in range(1, LLM_MAX_RETRIES + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_MAX_RETRIES}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                if resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower():\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < LLM_MAX_RETRIES:\n                    backoff = LLM_BACKOFF_BASE * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.15)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Exhausted retries: {last_err}\")\n        return f\"LLM_ERROR:{last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an implementation from an idea (fallbacks ensure parseable code).\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        text = idea or \"\"\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(text)}\")\n        if not text.strip():\n            # deterministic placeholder\n            return (\n                '\"\"\"Fallback implementation (empty idea).\"\"\"\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Return the input; placeholder for missing idea.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a compact, production-ready Python module implementing the task.\\n\"\n            \"Return only valid Python code (no backticks). Include docstrings and input validation where reasonable.\\n\\n\"\n            f\"Task: {text}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self.ask_llm(messages)\n        if code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic code\")\n            return (\n                f'\"\"\"Fallback implementation for: {text[:160]}\"\"\"\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback function when generation fails.\\\"\\\"\\\"\\n\"\n                \"    if value is None:\\n\"\n                \"        return None\\n\"\n                \"    return value\\n\"\n            )\n        # ensure parseable\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_PARSE_FAIL\", self.name, f\"Generated code not parseable: {e}\")\n            return (\n                f'\"\"\"Fallback due to parse error for: {text[:160]}\"\"\"\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback after parse error.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests with minimal guarantees.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        snippet = (code or \"\")[:3000]\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(snippet)}\")\n        # Extract public symbols\n        symbols: List[str] = []\n        try:\n            tree = ast.parse(code or \"\")\n            for n in tree.body:\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n        except Exception:\n            symbols = []\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module.\\n\"\n            \"- Use def test_* functions and assert statements.\\n\"\n            \"- Cover normal and at least one edge case.\\n\"\n            \"- Return only valid test code.\\n\\n\"\n            f\"Public symbols (heuristic): {', '.join(symbols[:8]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self.ask_llm(messages)\n        # validate minimal structure\n        if tests.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using fallback tests\")\n            name = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{name}_exists():\\n\"\n                \"    # Fallback presence test\\n\"\n                \"    assert True\\n\"\n            )\n        try:\n            parsed = ast.parse(tests)\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed)) or (\"assert \" in tests)\n            if not (has_test_fn or has_assert):\n                raise ValueError(\"No test functions or asserts found\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_PARSE_FAIL\", self.name, f\"Tests invalid: {e}\")\n            name = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test when generation invalid.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code/tests and emit a verdict line for routing.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        # quick static analysis\n        issues: List[str] = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:160]}\")\n\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"OK\") + \"\\nVERDICT: \" + (\"FAIL\" if issues else \"PASS\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review. End with a single line 'VERDICT: PASS' or 'VERDICT: FAIL'.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\nTests (truncated):\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues or 'none'}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        review = await self.ask_llm(messages)\n        if review.startswith(\"LLM_ERROR\") or \"VERDICT:\" not in (review or \"\"):\n            # Fall back to static issues heuristic\n            verdict = \"FAIL\" if issues else \"PASS\"\n            review = (review if isinstance(review, str) else \"Automated review unavailable.\") + f\"\\nVERDICT: {verdict}\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Deterministic verification: syntax + test presence + cross-reference + digest.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Code parse + collect definitions\n        public_defs: Set[str] = set()\n        try:\n            code_tree = ast.parse(code or \"\")\n            public_defs = {n.name for n in ast.walk(code_tree) if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\")}\n            code_ok = True\n            diagnostics.append(f\"code_defs:{len(public_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n\n        # Tests parse + presence\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(tests_tree))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(tests_tree)) or (\"assert \" in (tests or \"\"))\n            tests_ok = bool(has_test_fn or has_assert)\n            diagnostics.append(\"tests_presence:ok\" if tests_ok else \"tests_presence:none\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        # Cross-reference\n        try:\n            if public_defs and tests_ok:\n                test_names = {n.id for n in ast.walk(ast.parse(tests or \"\")) if isinstance(n, ast.Name)}\n                referenced = bool(public_defs & test_names)\n                diagnostics.append(\"tests_reference:ok\" if referenced else \"tests_reference:none\")\n            else:\n                diagnostics.append(\"tests_reference:skip\")\n        except Exception as e:\n            diagnostics.append(f\"reference_check_error:{str(e)[:160]}\")\n\n        verified = bool(code_ok and tests_ok and (referenced or not public_defs))\n        # Stable digest for early-stop confirmation\n        try:\n            digest = hashlib.sha256(((code or \"\") + \"\\n--TESTS--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n# ---------------------------\n# Roles\n# ---------------------------\n\nclass Role(ABC):\n    \"\"\"Single-responsibility role with watch/trigger logic and idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    env: Optional[\"Environment\"] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # action names this role watches\n    is_human: bool = False\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.env = kwargs.get(\"env\", None)\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self._processed_message_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_handle(self, msg: Message) -> bool:\n        if not msg:\n            return False\n        # avoid reprocessing and self-authored\n        if getattr(msg, \"id\", None) in self._processed_message_ids:\n            return False\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        # explicit routing (send_to set/list or string)\n        targets = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None)\n        if targets:\n            try:\n                if isinstance(targets, (set, list)):\n                    if self.name in targets or self.profile in targets or \"*\" in targets:\n                        return True\n                elif isinstance(targets, str):\n                    if targets in (self.name, self.profile, \"*\"):\n                        return True\n            except Exception:\n                pass\n            return False\n        # watch/trigger based on cause_by (action name)\n        if getattr(msg, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: allow coder to act on initial user input\n        if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n        action = self.actions[0]\n        if message is not None and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skip msg id={getattr(message,'id',None)}\")\n            return None\n\n        # Dispatch by action type; keep simple and deterministic\n        try:\n            if isinstance(action, SimpleWriteCode):\n                idea = (getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\")\n                out = await action.run(idea)\n                recipients = {\"SimpleTester\"}\n            elif isinstance(action, SimpleWriteTest):\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = message.content or \"\"\n                if not code_text and getattr(self, \"env\", None):\n                    latest_code = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = latest_code.content if latest_code else \"\"\n                out = await action.run(code_text)\n                recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n            elif isinstance(action, SimpleWriteReview):\n                code_text, tests_text = \"\", \"\"\n                if getattr(self, \"env\", None):\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    test_msg = self.env.get_latest_artifact([SimpleWriteTest.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                    tests_text = test_msg.content if test_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Use verdict for routing\n                verdict_line = (out or \"\").lower()\n                recipients = {\"SimpleVerifier\"} if \"verdict: pass\" in verdict_line else {\"SimpleCoder\", \"SimpleTester\"}\n            elif isinstance(action, SimpleVerify):\n                code_text, tests_text = \"\", \"\"\n                if getattr(self, \"env\", None):\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    test_msg = self.env.get_latest_artifact([SimpleWriteTest.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                    tests_text = test_msg.content if test_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                recipients = set()  # broadcast/record only\n            else:\n                out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                recipients = set()\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, f\"Exception during act: {type(e).__name__}: {str(e)[:160]}\")\n            out = f\"ROLE_EXCEPTION: {type(e).__name__}: {str(e)[:160]}\"\n            recipients = {\"SimpleCoder\"}\n\n        # mark processed input to avoid duplicates\n        if message and getattr(message, \"id\", None):\n            self._processed_message_ids.add(message.id)\n\n        response = Message(\n            content=out,\n            role=self.profile,\n            cause_by=action.name,\n            sent_from=self.name,\n            send_to=recipients\n        )\n        # avoid handling own response\n        self._processed_message_ids.add(response.id)\n        if tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={list(recipients)}\")\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\n# ---------------------------\n# Environment\n# ---------------------------\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing, per-role delivery tracking, and artifact lookup.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered: role.name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n        # index for quick artifact lookup by cause_by\n        self._by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to type and ensure id\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        cb = getattr(message, \"cause_by\", \"\")\n        if cb:\n            self._by_cause.setdefault(cb, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to the role and relevant by routing or watch triggers.\"\"\"\n        relevant: List[Message] = []\n        delivered = self._delivered.setdefault(role.name, set())\n\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if not mid or mid in delivered:\n                continue\n            # never re-deliver own message\n            if getattr(msg, \"sent_from\", None) == role.name:\n                delivered.add(mid)\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None)\n            routed = False\n            if send_to:\n                try:\n                    if isinstance(send_to, (set, list)):\n                        routed = role.name in send_to or role.profile in send_to or \"*\" in send_to\n                    elif isinstance(send_to, str):\n                        routed = send_to in (role.name, role.profile, \"*\")\n                except Exception:\n                    routed = False\n            if routed:\n                relevant.append(msg)\n                delivered.add(mid)\n                continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n                delivered.add(mid)\n                continue\n            # user input defaults for coder(s)\n            if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in role.profile:\n                relevant.append(msg)\n                delivered.add(mid)\n                continue\n        return relevant\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Fetch most recent message for any cause_by in cause_names.\"\"\"\n        for name in cause_names:\n            bucket = self._by_cause.get(name, [])\n            if bucket:\n                return bucket[-1]\n        return None\n\n# ---------------------------\n# Team Orchestrator\n# ---------------------------\n\nclass Team:\n    \"\"\"Deterministic orchestrator with robust verification streak and stall handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability\n        self._last_digest: Optional[str] = None\n        self._pass_streak: int = 0\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; need {REQUIRED_STABLE_PASSES} stable passes\")\n        # Initial directive to coder(s)\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        last_history_len = len(self.env.history)\n        no_progress_rounds = 0\n        rounds_ran = 0\n\n        for r in range(n_round):\n            rounds_ran = r + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rounds_ran}/{n_round}\")\n            new_msgs = 0\n\n            for RoleClass in order:\n                for role in [x for x in self.env.roles if isinstance(x, RoleClass)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # Ensure coder sees the initial prompt on first round\n                    if isinstance(role, SimpleCoder) and r == 0 and initial_msg not in msgs:\n                        msgs = [initial_msg] + msgs\n                    for msg in msgs:\n                        try:\n                            # Role-level retry around act to catch transient internal issues\n                            attempts = 0\n                            resp: Optional[Message] = None\n                            while attempts < ROLE_MAX_ATTEMPTS:\n                                attempts += 1\n                                resp = await role.act(msg)\n                                if resp is not None:\n                                    break\n                                await asyncio.sleep(0.05 * attempts)\n                            if resp:\n                                self.env.publish_message(resp)\n                                new_msgs += 1\n                                # track verification stability if verifier produced PASS\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    text = resp.content\n                                    if \"VERIFICATION_RESULT: PASS\" in text:\n                                        # extract digest\n                                        digest = None\n                                        for part in text.split(\"|\"):\n                                            part = part.strip()\n                                            if part.startswith(\"digest=\"):\n                                                digest = part.split(\"=\", 1)[1]\n                                                break\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._pass_streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._pass_streak = 1\n                                        else:\n                                            # treat PASS without digest as non-stable\n                                            self._pass_streak = 1\n                                            self._last_digest = None\n                                        self.tracer.log(\"VERIFY_STREAK\", \"Team\", f\"streak={self._pass_streak} digest={digest}\")\n                                    elif \"VERIFICATION_RESULT: FAIL\" in text:\n                                        if self._pass_streak > 0:\n                                            self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Reset streak {self._pass_streak}->0\")\n                                        self._pass_streak = 0\n                                        self._last_digest = None\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {type(e).__name__}: {str(e)[:160]}\")\n\n            # Round summary and progress checks\n            current_len = len(self.env.history)\n            if current_len == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = current_len\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"new_msgs={new_msgs} streak={self._pass_streak} history={len(self.env.history)}\")\n\n            # Termination: stable verification streak\n            if self._pass_streak >= REQUIRED_STABLE_PASSES:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Stable verification streak={self._pass_streak}; stopping\")\n                break\n\n            # Stall handling: nudge coder then stop if persists\n            if new_msgs == 0:\n                if no_progress_rounds == 1:\n                    nudge = Message(\n                        content=f\"Please refine or improve the implementation for: {self.idea}\",\n                        instruct_content=self.idea,\n                        role=\"System\",\n                        sent_from=\"Orchestrator\",\n                        cause_by=\"Nudge\",\n                        send_to={\"SimpleCoder\"}\n                    )\n                    self.env.publish_message(nudge)\n                elif no_progress_rounds >= NO_PROGRESS_GRACE:\n                    self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating\")\n                    break\n\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' finished after {rounds_ran} rounds with {len(self.env.history)} messages. Verified={self._pass_streak >= REQUIRED_STABLE_PASSES}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "94dcdcdb-c53c-47bf-bc7b-de3590950a23", "generation": 4, "timestamp": 1754660866.6836293, "iteration_found": 183, "metrics": {"runs_successfully": 1.0, "overall_score": 0.5, "combined_score": 0.2068965517241379, "avg_failures_per_task": 3.8333333333333335, "total_failures": 23.0, "successful_runs": 6.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "overall_score": 0.5, "combined_score": 0.24000000000000005, "avg_failures_per_task": 3.1666666666666665, "total_failures": 19.0, "successful_runs": 6.0}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes per the MAST taxonomy.\n\nFocus on:\n- Clear role definitions and responsibilities\n- Robust inter-agent communication patterns and explicit watch/trigger logic\n- Termination conditions (avoid premature termination; stop once verified)\n- Strong verification and validation steps\n- Error handling and retry on LLM/API failures\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 1.0000\n- overall_score: 0.5000\n- combined_score: 0.2400\n- avg_failures_per_task: 3.1667\n- total_failures: 19.0000\n- successful_runs: 6.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: combined_score. Consider continuing with similar changes.\n- Metrics showing regression: avg_failures_per_task, total_failures. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.2308, avg_failures_per_task: 3.3333, total_failures: 20.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.2308, avg_failures_per_task: 3.3333, total_failures: 20.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.2400, avg_failures_per_task: 3.1667, total_failures: 19.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 4.9844)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2400), Performs well on avg_failures_per_task (3.1667), Performs well on total_failures (19.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 2 (Score: 4.9844)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2400), Performs well on avg_failures_per_task (3.1667), Performs well on total_failures (19.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 3 (Score: 5.1774)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport random\nimport time\nimport ast\nimport hashlib\nfrom typing import Tuple, Iterable, Callable\n\n# Evolution parameters (tunable)\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5\nROLE_MAX_ATTEMPTS = 3\nVERIFY_REQUIRED_STREAK = 2\nNO_PROGRESS_GRACE = 2  # rounds before terminating for lack of progress\n\n# ---------------------------\n# Actions\n# ---------------------------\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call wrapper and clear contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = LLM_MAX_RETRIES\n    base_backoff: float = LLM_BACKOFF_BASE\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _call_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries, exponential backoff and jitter. Returns string or error marker.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_UNAVAILABLE\", self.name, \"LLMInterface not configured; using deterministic fallback marker\")\n            return \"LLM_ERROR:LLM_UNAVAILABLE\"\n\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                low = resp.strip().lower()\n                if low.startswith(\"error\") or \"error communicating\" in low:\n                    last_err = resp\n                    raise RuntimeError(f\"LLM returned error-like text: {resp[:200]}\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Attempt {attempt} success len={len(resp)}\")\n                return resp\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < self.max_retries:\n                    backoff = self.base_backoff * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Giving up after {self.max_retries} attempts: {last_err}\")\n        return f\"LLM_ERROR:{last_err}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return an artifact string.\"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"Empty idea; returning deterministic fallback code\")\n            return (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback placeholder.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a compact, production-ready Python module implementing the task.\\n\"\n            \"Return only valid Python source code. Include docstrings and input validation where reasonable.\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._call_llm(messages)\n        if isinstance(code, str) and code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback code\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea[:120]}\"\"\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder implementation.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        # validate parseable Python\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, f\"Generated code not parseable: {e}\")\n            return (\n                f'\"\"\"Fallback due to parse error for: {idea[:120]}\"\"\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback after parse error.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated code len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No code provided; returning minimal test\")\n            return \"def test_placeholder():\\n    assert True\\n\"\n        # extract symbols\n        symbols = []\n        try:\n            parsed = ast.parse(code)\n            for n in parsed.body:\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n        except Exception:\n            symbols = []\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided module. \"\n            \"Include nominal and at least one edge-case. Return only pytest code.\\n\\n\"\n            f\"Public symbols (heuristic): {', '.join(symbols[:6]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{(code or '')[:3000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._call_llm(messages)\n        if isinstance(tests, str) and tests.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback tests\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_exists():\\n\"\n                f\"    # basic presence test for {target}\\n\"\n                f\"    assert True\\n\"\n            )\n        # validate tests parseable and contain assert or test_ function\n        try:\n            parsed_tests = ast.parse(tests)\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in parsed_tests.body)\n            has_assert = \"assert \" in tests or any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            if not (has_test_fn or has_assert):\n                raise ValueError(\"No tests/asserts detected\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Tests invalid: {e}\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # quick static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: manual review recommended; \" + (\"; \".join(issues) if issues else \"no static issues found\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review supplied\")\n            return review\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review and end with a single-line VERDICT: PASS or VERDICT: FAIL.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests (truncated):\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        review = await self._call_llm(messages)\n        if isinstance(review, str) and review.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM review unavailable; requesting changes\")\n            return \"REQUEST_CHANGE: Automated review unavailable; request human review.\"\n        if \"VERDICT:\" not in (review or \"\"):\n            review = (review or \"\").strip() + \"\\n\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Performing deterministic verification\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # code parse and detect defs\n        code_defs = set()\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_defs = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            code_ok = bool(parsed_code and code_defs)\n            diagnostics.append(f\"code_defs:{len(code_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n\n        # tests parse and assert presence\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests)) or (\"assert \" in (tests or \"\"))\n            tests_ok = has_test_fn or has_assert\n            diagnostics.append(\"tests_has_assert\" if has_assert else \"tests_no_assert\")\n            diagnostics.append(\"tests_has_test_fn\" if has_test_fn else \"tests_no_test_fn\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        # cross-reference\n        try:\n            if code_defs and tests_ok:\n                for name in code_defs:\n                    if name and name in (tests or \"\"):\n                        referenced = True\n                        break\n                diagnostics.append(f\"tests_reference_count:{sum(1 for n in code_defs if n in (tests or ''))}\")\n            else:\n                diagnostics.append(\"tests_reference_count:0\")\n        except Exception as e:\n            diagnostics.append(f\"reference_check_error:{str(e)[:160]}\")\n\n        verified = code_ok and tests_ok and referenced\n        status = \"PASS\" if verified else \"FAIL\"\n        # stable digest for change detection\n        try:\n            digest_src = (code or \"\").encode() + b\"||\" + (tests or \"\").encode()\n            digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n        result = f\"VERIFICATION_RESULT: {status} | digest={digest} | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n# ---------------------------\n# Roles\n# ---------------------------\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities, watch/trigger logic, and idempotency.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = kwargs.get(\"env\", None)\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        \"\"\"Decide whether to respond to a message.\"\"\"\n        if not message:\n            return False\n        if getattr(message, \"id\", None) in self._processed_ids:\n            return False\n        # explicit addressing: send_to (preferred) or sent_to\n        send_to = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n        if send_to:\n            try:\n                if isinstance(send_to, (set, list)):\n                    if self.name in send_to or self.profile in send_to or \"*\" in send_to:\n                        return True\n                elif isinstance(send_to, str):\n                    if send_to in (self.name, self.profile, \"*\"):\n                        return True\n            except Exception:\n                pass\n        # watch-trigger\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input to coders\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action with retries and return produced Message (or None).\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message id={getattr(message,'id',None)}\")\n            return None\n\n        action = self.actions[0]\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_MAX_ATTEMPTS:\n            attempts += 1\n            try:\n                # Dispatch by action type\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    code_text = getattr(message, \"content\", \"\") if message else \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        # find latest code artifact\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    # collect latest code and tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    lowered = (out or \"\").lower()\n                    if lowered.startswith(\"request_change\") or \"request_change\" in lowered or \"request_changes\" in lowered:\n                        recipients = {\"SimpleCoder\", \"SimpleTester\"}\n                    else:\n                        recipients = {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = set()  # broadcast handled by orchestrator\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark processed input to avoid reprocessing\n                if message and getattr(message, \"id\", None):\n                    self._processed_ids.add(message.id)\n\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced {getattr(response,'id',None)} cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:200]}\")\n                await asyncio.sleep(0.1 * attempts)\n        # exhausted attempts\n        fail = f\"ROLE_FAILED: {self.name} after {ROLE_MAX_ATTEMPTS} attempts - {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, fail[:200])\n        response = Message(\n            content=fail,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\n# ---------------------------\n# Environment\n# ---------------------------\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing, processed-tracking and artifact lookup.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered: role_name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure id exists for non-pydantic fallback\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        # normalize send_to\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def mark_delivered(self, role: Role, message: Message):\n        if not getattr(message, \"id\", None):\n            return\n        self._delivered.setdefault(role.name, set()).add(message.id)\n        if self.tracer:\n            self.tracer.log(\"ENV_MARK_DELIVERED\", \"Environment\", f\"{role.name} delivered {message.id}\")\n\n    def has_been_delivered(self, role: Role, message: Message) -> bool:\n        return getattr(message, \"id\", None) in self._delivered.get(role.name, set())\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to role that should be handled by it.\"\"\"\n        out: List[Message] = []\n        delivered = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if not mid or mid in delivered:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                # mark self-produced messages as delivered for this role\n                delivered.add(mid)\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            targeted = False\n            try:\n                if isinstance(send_to, (set, list)):\n                    if role.name in send_to or role.profile in send_to:\n                        targeted = True\n                elif isinstance(send_to, str):\n                    if send_to in (role.name, role.profile):\n                        targeted = True\n            except Exception:\n                targeted = False\n            if targeted:\n                out.append(msg)\n                delivered.add(mid)\n                continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n                delivered.add(mid)\n                continue\n        return out\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names.\"\"\"\n        cause_set = set(cause_names)\n        for msg in reversed(self.history):\n            if getattr(msg, \"cause_by\", None) in cause_set:\n                return msg\n        return None\n\n# ---------------------------\n# Team orchestrator\n# ---------------------------\n\nclass Team:\n    \"\"\"Orchestrates roles, termination, verification handshake, and stability checks.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self._verify_streak: int = 0\n        self._verify_required: int = VERIFY_REQUIRED_STREAK\n        self._last_digest: Optional[str] = None\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role(self, role: Role) -> int:\n        \"\"\"Process pending messages for a role and return number of produced messages.\"\"\"\n        produced = 0\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            return 0\n        for msg in msgs:\n            # Protect against role processing its own message\n            if getattr(msg, \"sent_from\", None) == role.name:\n                self.env.mark_delivered(role, msg)\n                continue\n            try:\n                resp = await role.act(msg)\n            except Exception as e:\n                self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {e}\")\n                resp = Message(content=f\"ERROR: role {role.name} crashed: {str(e)}\", role=role.profile, cause_by=\"RoleCrash\", sent_from=role.name, send_to=set())\n            # mark delivered even if resp is None so we don't retry forever\n            self.env.mark_delivered(role, msg)\n            if resp:\n                self.env.publish_message(resp)\n                produced += 1\n                # update verification streak if verifier role\n                if isinstance(role, SimpleVerifier):\n                    content = resp.content or \"\"\n                    if \"VERIFICATION_RESULT: PASS\" in content:\n                        # extract digest if present\n                        digest = None\n                        for token in content.split(\"|\"):\n                            token = token.strip()\n                            if token.startswith(\"digest=\"):\n                                digest = token.split(\"=\", 1)[1]\n                                break\n                        if digest and digest == self._last_digest:\n                            self._verify_streak += 1\n                        elif digest:\n                            self._last_digest = digest\n                            self._verify_streak = 1\n                        else:\n                            # pass without digest: treat as single pass but not stable\n                            self._last_digest = None\n                            self._verify_streak += 1\n                        self.tracer.log(\"VERIFY_UPDATE\", \"Team\", f\"streak={self._verify_streak} digest={digest}\")\n                    else:\n                        if self._verify_streak > 0:\n                            self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Resetting streak {self._verify_streak}->0\")\n                        self._verify_streak = 0\n                        self._last_digest = None\n        return produced\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; require {self._verify_required} stable verifications to stop early\")\n        # initial message to coder(s)\n        coder_targets = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_targets\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        # deterministic processing order to reduce races\n        orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(n_round):\n            round_num = round_idx + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            round_new_msgs = 0\n\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    # ensure coder sees initial on first round\n                    if isinstance(role, SimpleCoder) and round_idx == 0:\n                        # if initial not delivered to coder yet, ensure delivery\n                        if not self.env.has_been_delivered(role, initial_msg):\n                            # deliver initial message for processing\n                            self.env._delivered.setdefault(role.name, set()).discard(initial_msg.id) if False else None\n                    produced = await self._process_role(role)\n                    round_new_msgs += produced\n\n            # compute progress\n            if len(self.env.history) == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} complete produced={round_new_msgs} verify_streak={self._verify_streak}\")\n\n            # termination: require at least one full round and stable verification streak\n            if self._verify_streak >= self._verify_required and round_num >= 1:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self._verify_streak} passes; stopping\")\n                verified = True\n                break\n\n            # stop if no progress for multiple rounds\n            if no_progress_rounds >= NO_PROGRESS_GRACE:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating early\")\n                break\n\n            # if stalled but not yet terminated, nudge coder once\n            if round_new_msgs == 0:\n                for r in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                    nudge = Message(\n                        content=f\"Nudge: please refine implementation for: {self.idea}\",\n                        instruct_content=self.idea,\n                        role=\"System\",\n                        sent_from=\"Orchestrator\",\n                        cause_by=\"Nudge\",\n                        send_to={r.profile}\n                    )\n                    self.env.publish_message(nudge)\n\n            # cooperative yield\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        summary = f\"Project '{self.idea}' finished after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2308), Performs well on avg_failures_per_task (3.3333), Performs well on total_failures (20.0000), Performs well on successful_runs (6.0000)\n\n\n### Program 4 (Score: 5.1774)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport random\nimport re\nfrom typing import Tuple, Any, Dict\n\n# Goals:\n# - Clear single-responsibility roles with explicit routing and watch logic.\n# - Robust LLM/API calls with retries and jitter.\n# - Deterministic verification with digest and stable consecutive PASS requirement.\n# - Simplified, readable orchestration and environment routing.\n# - Error-tolerant fallbacks that keep the pipeline moving.\n\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5\nROLE_MAX_ATTEMPTS = 2\nREQUIRED_STABLE_PASSES = 2\nNO_PROGRESS_LIMIT = 2  # consecutive rounds\n\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM wrapper and clear run contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Ask LLM with retries/backoff. Returns string or 'LLM_ERROR:<reason>'.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, \"LLM unavailable; returning deterministic error\")\n            return \"LLM_ERROR:unavailable\"\n\n        last_err = None\n        for attempt in range(1, LLM_MAX_RETRIES + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_MAX_RETRIES}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response\")\n                low = resp.strip().lower()\n                if low.startswith(\"error\") or \"error communicating\" in low:\n                    last_err = resp\n                    raise RuntimeError(\"Error response\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"len={len(resp)}\")\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:160]}\")\n                if attempt < LLM_MAX_RETRIES:\n                    backoff = LLM_BACKOFF_BASE * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.15)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Exhausted retries: {last_err}\")\n        return f\"LLM_ERROR:{last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return text output.\"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Empty idea -> placeholder code\")\n            return (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder implementation.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module implementing the task.\\n\"\n            \"Constraints:\\n- Only Python code (no backticks)\\n- Include docstrings and input validation\\n- Keep functions small and testable\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        code = await self._ask_llm(messages)\n        if code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM error -> deterministic fallback code\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea[:200]}\"\"\"\\n\\n'\n                \"def placeholder(input_value=None):\\n\"\n                \"    \\\"\\\"\\\"Echo-like fallback for when code generation fails.\\\"\\\"\\\"\\n\"\n                \"    if input_value is None:\\n\"\n                \"        return None\\n\"\n                \"    return input_value\\n\"\n            )\n        # syntax validation\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Parse error: {e}\")\n            return (\n                f'\"\"\"Fallback due to parse error for: {idea[:200]}\"\"\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback after parse error.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No code -> minimal test\")\n            return \"def test_placeholder():\\n    assert True\\n\"\n\n        # Extract top-level names for reference\n        names: List[str] = []\n        try:\n            tree = ast.parse(code)\n            for n in tree.body:\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\"):\n                    names.append(n.name)\n        except Exception:\n            names = []\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module.\\n\"\n            \"- Use def test_* functions and assert statements.\\n\"\n            \"- Cover typical and edge cases.\\n\"\n            \"- Return only test code.\\n\\n\"\n            f\"Public symbols: {', '.join(names[:8]) or '(none detected)'}\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:3000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        tests = await self._ask_llm(messages)\n        # validate tests\n        def _fallback_tests(target: str) -> str:\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_sanity():\\n\"\n                \"    \\\"\\\"\\\"Fallback sanity test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n\n        if tests.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM error -> fallback tests\")\n            return _fallback_tests(names[0] if names else \"placeholder\")\n        try:\n            parsed = ast.parse(tests)\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed)) or (\"assert\" in (tests or \"\"))\n            if not (has_test_fn or has_assert):\n                raise ValueError(\"No tests/asserts found\")\n        except Exception:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, \"Tests invalid -> fallback\")\n            return _fallback_tests(names[0] if names else \"placeholder\")\n\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        # Static checks\n        issues: List[str] = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:120]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:120]}\")\n\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"OK\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review.\\n\"\n            \"End with a single line: VERDICT: PASS or VERDICT: FAIL.\\n\\n\"\n            f\"Code:\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests:\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues or 'none'}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        review = await self._ask_llm(messages)\n        if review.startswith(\"LLM_ERROR\") or not isinstance(review, str) or not review.strip():\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Review LLM error -> request change\")\n            return \"REQUEST_CHANGE: Automated reviewer failed. Please perform manual review.\\nVERDICT: FAIL\"\n        if \"VERDICT:\" not in review:\n            review = review.rstrip() + \"\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Code syntax and public definitions\n        public_defs: Set[str] = set()\n        try:\n            code_tree = ast.parse(code or \"\")\n            public_defs = {n.name for n in ast.walk(code_tree) if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\")}\n            code_ok = True\n            diagnostics.append(f\"code_defs:{len(public_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:120]}\")\n\n        # Tests syntax and presence\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(tests_tree))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(tests_tree)) or (\"assert\" in (tests or \"\"))\n            tests_ok = bool(has_test_fn or has_assert)\n            diagnostics.append(\"tests_presence:ok\" if tests_ok else \"tests_presence:none\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:120]}\")\n\n        # Cross-reference: tests mention code symbols\n        try:\n            if public_defs and tests_ok:\n                name_refs = {n.id for n in ast.walk(ast.parse(tests or \"\")) if isinstance(n, ast.Name)}\n                referenced = bool(public_defs & name_refs)\n                diagnostics.append(\"tests_reference:ok\" if referenced else \"tests_reference:none\")\n            else:\n                diagnostics.append(\"tests_reference:skip\")\n        except Exception as e:\n            diagnostics.append(f\"reference_check_error:{str(e)[:120]}\")\n\n        verified = bool(code_ok and tests_ok and (referenced or not public_defs))\n\n        # Stable digest to confirm successive identical pass\n        try:\n            import hashlib\n            digest = hashlib.sha256(((code or \"\") + \"\\n--TESTS--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"\n    Base role with single-responsibility action, explicit watch/routing, and idempotent processing.\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # action names\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self.env = kwargs.get(\"env\", None)\n        # Local processed to avoid repeated handling of same msg by a role instance\n        self._processed_message_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        \"\"\"Decide whether to respond based on explicit routing, watch triggers, and prior processing.\"\"\"\n        if not message:\n            return False\n        # Skip if we already processed this message\n        if getattr(message, \"id\", None) in self._processed_message_ids:\n            return False\n        # Skip self-authored\n        if getattr(message, \"sent_from\", None) == self.name:\n            return False\n        # Prefer explicit routing (send_to supports set/list or string)\n        targets = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n        if targets:\n            if isinstance(targets, (set, list)):\n                if self.name in targets or self.profile in targets or \"*\" in targets:\n                    return True\n            elif isinstance(targets, str):\n                if targets in (self.name, self.profile, \"*\"):\n                    return True\n            # if targets specified but not for us, don't respond\n            return False\n        # Watch-list by cause_by\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # Default route: initial user input goes to coder\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the single action for this role and produce a routed Message.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n\n        action = self.actions[0]\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skip msg id={getattr(message,'id',None)}\")\n            return None\n\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_MAX_ATTEMPTS:\n            attempts += 1\n            try:\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        # Find latest code artifact\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    code_text, tests_text = \"\", \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = {\"SimpleVerifier\", \"SimpleCoder\"} if \"REQUEST_CHANGE\" in (out or \"\").upper() else {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    code_text, tests_text = \"\", \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = set()  # broadcast semantics\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark input as processed\n                if message and getattr(message, \"id\", None):\n                    self._processed_message_ids.add(message.id)\n\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:160]}\")\n                await asyncio.sleep(0.05 * attempts)\n\n        # Exhausted attempts -> return failure message\n        failure = f\"ROLE_FAILED: {self.name} after {ROLE_MAX_ATTEMPTS} attempts - {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, failure)\n        return Message(\n            content=failure,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview])\n\n\nclass Environment:\n    \"\"\"\n    Message bus with routing and per-role processed tracking.\n    - history: ordered messages\n    - _processed: msg_id -> set(role.name) to avoid duplicate handling\n    \"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        self._processed: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"from={message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        if getattr(message, \"id\", None):\n            self._processed.setdefault(message.id, set()).add(role.name)\n            if self.tracer:\n                self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_been_processed_by(self, message: Message, role: Role) -> bool:\n        return role.name in self._processed.get(getattr(message, \"id\", \"\"), set())\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Relevant messages for role: explicit routing first, then watch triggers. Skip processed/self-authored.\"\"\"\n        relevant: List[Message] = []\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if not mid:\n                continue\n            if self.has_been_processed_by(msg, role):\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit addressing\n            send_to = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None)\n            matched = False\n            if send_to:\n                if isinstance(send_to, (set, list)) and (role.name in send_to or role.profile in send_to or \"*\" in send_to):\n                    relevant.append(msg)\n                    matched = True\n                elif isinstance(send_to, str) and send_to in (role.name, role.profile, \"*\"):\n                    relevant.append(msg)\n                    matched = True\n                if matched:\n                    continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n        return relevant\n\n\nclass Team:\n    \"\"\"\n    Orchestrates roles with deterministic ordering and stable verification-based termination.\n    - Requires REQUIRED_STABLE_PASSES consecutive PASS with the same digest.\n    - Nudges coder on stalls before terminating for no progress.\n    \"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self._last_digest: Optional[str] = None\n        self._pass_streak: int = 0\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Run up to {n_round} rounds; require {REQUIRED_STABLE_PASSES} stable passes\")\n        # Initial user instruction to coder(s)\n        initial = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial)\n\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n        rounds_ran = 0\n\n        for r in range(n_round):\n            rounds_ran = r + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rounds_ran}/{n_round}\")\n            progress = False\n\n            for RoleClass in order:\n                for role in [ro for ro in self.env.roles if isinstance(ro, RoleClass)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # Guarantee coder sees initial message in first round\n                    if isinstance(role, SimpleCoder) and r == 0 and initial not in msgs:\n                        msgs = [initial] + msgs\n                    for msg in msgs:\n                        try:\n                            resp = await role.act(msg)\n                            # mark processed regardless of result to avoid loops\n                            self.env.mark_processed(msg, role)\n                            if resp:\n                                self.env.publish_message(resp)\n                                progress = True\n                                # verification tracking\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    content = resp.content\n                                    if \"VERIFICATION_RESULT: PASS\" in content:\n                                        # extract digest if present\n                                        digest = None\n                                        for part in content.split(\"|\"):\n                                            p = part.strip()\n                                            if p.startswith(\"digest=\"):\n                                                digest = p.split(\"=\", 1)[1]\n                                                break\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._pass_streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._pass_streak = 1\n                                            self.tracer.log(\"VERIFY_PASS\", \"Team\", f\"digest={digest} streak={self._pass_streak}\")\n                                        else:\n                                            # pass without digest counts as 1 but cannot be stable across rounds\n                                            self._last_digest = None\n                                            self._pass_streak = 1\n                                    elif \"VERIFICATION_RESULT: FAIL\" in content:\n                                        if self._pass_streak > 0:\n                                            self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Reset streak {self._pass_streak}->0 due to FAIL\")\n                                        self._pass_streak = 0\n                                        self._last_digest = None\n                            # note role failures\n                            if resp and isinstance(resp.content, str) and resp.content.startswith(\"ROLE_FAILED\"):\n                                self.tracer.log(\"TEAM_NOTE\", \"Team\", f\"{resp.content[:160]}\")\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {type(e).__name__}: {str(e)[:160]}\")\n\n            # Termination and stall handling\n            current_len = len(self.env.history)\n            if current_len == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = current_len\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"progress={progress} streak={self._pass_streak} history={len(self.env.history)}\")\n\n            # Verified if stable streak achieved\n            if self._pass_streak >= REQUIRED_STABLE_PASSES:\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Stable verification streak={self._pass_streak}; stopping\")\n                break\n\n            # Nudge coder on first stall, then terminate if persists\n            if no_progress_rounds == 1:\n                nudge = Message(\n                    content=f\"Please refine or improve the implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n            elif no_progress_rounds >= NO_PROGRESS_LIMIT:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; stopping\")\n                break\n\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        verified = self._pass_streak >= REQUIRED_STABLE_PASSES\n        summary = f\"Project '{self.idea}' finished after {rounds_ran} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.2308), Performs well on avg_failures_per_task (3.3333), Performs well on total_failures (20.0000), Performs well on successful_runs (6.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 5.3704)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class with clear responsibilities and LLM retry wrapper\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 2\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _llm_call_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with exponential backoff and simple error detection.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}\")\n                if not self.llm:\n                    # Local fallback\n                    return \"LLM not available: fallback response.\"\n                resp = await self.llm.ask(messages)\n                # Detect common error patterns returned by LLMInterface\n                if isinstance(resp, str) and (resp.startswith(\"Error\") or \"Error communicating\" in resp):\n                    last_err = resp\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {resp[:200]}\")\n                    # retry\n                    continue\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_EXCEPTION\", self.name, f\"Attempt {attempt} exception: {last_err}\")\n        # All retries exhausted\n        return f\"LLM_FAILURE: {last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        raise NotImplementedError()\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for idea (len={len(idea)})\")\n        prompt = (\n            \"You are a professional Python programmer. Produce clean, well-commented, \"\n            \"production-ready Python code for the task described.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Correct syntax\\n\"\n            \"2. Defensive error handling\\n\"\n            \"3. Clear docstrings/comments\\n\"\n            \"4. No surrounding backticks or explanation, only the code\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated code size={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing tests for code (len={len(code)})\")\n        snippet = (code or \"\")[:3000]\n        prompt = (\n            \"You are an experienced QA engineer. Write pytest-style tests for the provided Python code.\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Cover normal and edge cases\\n\"\n            \"2. Include negative tests when appropriate\\n\"\n            \"3. Use clear docstrings for each test\\n\"\n            \"4. Return only the test code\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated tests size={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests and return concise actionable feedback\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing artifacts (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review simulated: consider more input validation and docstrings.\"\n        else:\n            snippet_code = (code or \"\")[:2000]\n            snippet_tests = (tests or \"\")[:2000]\n            prompt = (\n                \"You are a senior engineer performing a concise code + test review.\\n\\n\"\n                f\"Code:\\n{snippet_code}\\n\\nTests:\\n{snippet_tests}\\n\\n\"\n                \"Focus on:\\n\"\n                \"1. Correctness and likely runtime issues\\n\"\n                \"2. Test coverage gaps\\n\"\n                \"3. Practical suggestions (1-3 items)\\n\"\n                \"Return a short review.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            review = await self._llm_call_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        issues: List[str] = []\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Starting verification\")\n\n        # Basic non-empty checks\n        if not (code and code.strip()):\n            issues.append(\"code_empty\")\n        if not (tests and tests.strip()):\n            issues.append(\"tests_empty\")\n\n        # Syntax checks\n        code_ok = False\n        tests_ok = False\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:200]}\")\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = True\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:200]}\")\n\n        # Cross-reference: ensure tests mention at least one function/class name from code\n        try:\n            code_ast = ast.parse(code or \"\")\n            def_names = {n.name for n in ast.walk(code_ast) if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            tests_ast = ast.parse(tests or \"\")\n            tests_identifiers = {n.id for n in ast.walk(tests_ast) if isinstance(n, ast.Name)}\n            if def_names and def_names.isdisjoint(tests_identifiers):\n                issues.append(\"tests_may_not_reference_code_defs\")\n        except Exception:\n            # already captured syntax errors above, ignore here\n            pass\n\n        verified = (code_ok and tests_ok and not any(i.startswith(\"tests_may_not_reference\") for i in issues))\n        status = {\n            \"verified\": verified,\n            \"issues\": issues,\n            \"code_ok\": code_ok,\n            \"tests_ok\": tests_ok\n        }\n        result_lines = [f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'}\"]\n        if issues:\n            result_lines.append(\"ISSUES: \" + \"; \".join(issues))\n        result = \" | \".join(result_lines)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with explicit watch/trigger logic and idempotency\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        # track processed message ids to avoid reprocessing\n        self._processed_message_ids: Set[str] = set()\n        # env reference will be attached by Team.hire\n        self.env = getattr(self, 'env', None)\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n\n    def _should_respond_to(self, message: Message) -> bool:\n        \"\"\"Decide if this role should respond to the given message\"\"\"\n        if message is None:\n            return False\n        # If message explicitly targeted this role by name/profile\n        if getattr(message, \"send_to\", None):\n            targets = set(message.send_to)\n            if self.name in targets or self.profile in targets:\n                return True\n        # If role watches the causing action type\n        for watched in self.watch_list:\n            if getattr(message, \"cause_by\", \"\") == watched.name:\n                return True\n        # Also ignore messages we've already processed\n        if getattr(message, \"id\", None) in self._processed_message_ids:\n            return False\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action for this role based on the message.\n        Returns a Message or None.\n        This base implementation supports single-action roles.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Preparing to execute {action.name}\")\n\n        # If message provided but role decides it should not respond, skip\n        if message and not self._should_respond_to(message):\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message {getattr(message, 'id', '')}\")\n            return None\n\n        try:\n            # Dispatch to appropriate behavior by action name\n            if action.name == SimpleWriteCode.name:\n                idea = (message.instruct_content or message.content) if message else \"\"\n                out = await action.run(idea)\n                # Create message routing to Tester\n                send_to = {\"SimpleTester\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # Prefer to act on the latest code artifact visible\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                code_text = code_msg.content if code_msg else \"\"\n                out = await action.run(code_text)\n                # Route to Reviewer and Verifier\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # Gather latest code and tests\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                tests_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteTest.name])\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Route review to Verifier and Coder for improvements\n                send_to = {\"SimpleVerifier\", \"SimpleCoder\"}\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # Gather latest code and tests\n                code_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteCode.name])\n                tests_msg = self.env.get_latest_artifact(cause_names=[SimpleWriteTest.name])\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Verification messages are broadcast for team decision\n                send_to = set()  # broadcast\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                out = \"Action executed (noop)\"\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=set()\n                )\n        except Exception as e:\n            # Robust error handling: log and create a failure message\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, f\"Exception during act: {str(e)}\")\n            response = Message(\n                content=f\"ERROR: {str(e)}\",\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to=set()\n            )\n\n        # Mark the input message as processed to avoid reprocessing\n        if message and getattr(message, \"id\", None):\n            self._processed_message_ids.add(message.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced message {getattr(response, 'id', '')[:8]} cause_by={response.cause_by}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder initiates on UserInput\n        self._watch([ ])  # empty; will respond to messages explicitly targeted\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watches code-writing actions\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Watches tests to provide review\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        # Watches tests (and reviews implicitly)\n        self._watch([SimpleWriteTest, SimpleWriteReview])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with improved routing\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # quick index of messages by cause_by for artifact lookup\n        self._index_by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        # attach env on the role instance\n        setattr(role, 'env', self)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment and index it\"\"\"\n        # Ensure message has an id (pydantic variant already does)\n        if not getattr(message, \"id\", None):\n            message.id = str(uuid.uuid4())\n        self.history.append(message)\n        # index by cause_by\n        cb = getattr(message, \"cause_by\", \"\")\n        if cb:\n            self._index_by_cause.setdefault(cb, []).append(message)\n        if self.tracer:\n            snippet = (message.content or \"\")[:200].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {message.sent_from} cause_by={cb} send_to={getattr(message, 'send_to', set())} content={snippet}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages: List[Message] = []\n        for msg in self.history:\n            # skip messages the role already processed\n            if getattr(msg, \"id\", None) in getattr(role, \"_processed_message_ids\", set()):\n                continue\n            # explicit routing takes precedence\n            if getattr(msg, \"send_to\", None):\n                if role.name in msg.send_to or role.profile in msg.send_to:\n                    relevant_messages.append(msg)\n                    continue\n            # otherwise use watch_list matching cause_by\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\n    def get_latest_artifact(self, cause_names: List[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names\"\"\"\n        for name in cause_names:\n            msgs = self._index_by_cause.get(name, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together with robust orchestration and termination logic\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # track verification stability: require N consecutive PASS to accept\n        self._consecutive_verification_passes = 0\n        self._verification_threshold = 2  # require two consecutive passes to avoid fluke\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds with clear orchestration, retries, and termination checks\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # Initial message with the idea targeted at the coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"Alice\", \"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verified_overall = False\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            new_messages_this_round = 0\n\n            # Iterate over a fixed, orchestrated order to reduce race conditions:\n            orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    # get messages that role should handle\n                    incoming = self.env.get_messages_for_role(role)\n                    if not incoming:\n                        # allow coder to be triggered on first round by initial message\n                        if RoleClass is SimpleCoder and round_num == 1:\n                            incoming = [initial_msg]\n                    # Process each incoming message (deterministic order: newest first)\n                    for msg in incoming:\n                        # Attempt action with limited retries\n                        attempts = 0\n                        max_attempts = 2\n                        while attempts < max_attempts:\n                            try:\n                                attempts += 1\n                                response = await role.act(msg)\n                                if response:\n                                    self.env.publish_message(response)\n                                    new_messages_this_round += 1\n                                    # If verifier produced a PASS, update counters\n                                    if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (response.content or \"\"):\n                                        self._consecutive_verification_passes += 1\n                                        self.tracer.log(\"VERIFIER_PASS\", \"Team\", f\"Consecutive passes={self._consecutive_verification_passes}\")\n                                    elif isinstance(role, SimpleVerifier):\n                                        # reset if fail\n                                        self._consecutive_verification_passes = 0\n                                break  # success or handled, break retry loop\n                            except Exception as e:\n                                # Log and decide to retry\n                                self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Attempt {attempts} failed: {str(e)}\")\n                                if attempts >= max_attempts:\n                                    # produce an error message into environment\n                                    err_msg = Message(\n                                        content=f\"ERROR: role {role.name} failed after {attempts} attempts: {str(e)}\",\n                                        role=role.profile,\n                                        cause_by=\"RoleRunError\",\n                                        sent_from=role.name,\n                                        send_to=set()\n                                    )\n                                    self.env.publish_message(err_msg)\n                                    new_messages_this_round += 1\n                                else:\n                                    # small implicit backoff - next loop iteration will retry\n                                    continue\n\n            # After all roles, determine termination conditions\n            if self._consecutive_verification_passes >= self._verification_threshold:\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable for {self._verification_threshold} rounds, stopping\")\n                verified_overall = True\n                break\n\n            if new_messages_this_round == 0:\n                # no progress made this round; stop to avoid infinite loop\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No new messages produced this round; stopping early\")\n                break\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} completed with {new_messages_this_round} new messages\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' ended. Rounds executed={round_num}. Messages exchanged={len(self.env.history)}. Verified={verified_overall}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D2 (Score: 6.3368)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# Evolved multi-agent logic to reduce failure modes (MAST-focused)\n# Focus:\n# - Clear role responsibilities & single-action roles\n# - Robust inter-agent communication: explicit send_to routing and watch/trigger logic\n# - Deterministic orchestration and idempotent processing\n# - Strong verification & validation (syntax, tests presence, cross-reference)\n# - LLM/API error handling with retries/backoff and deterministic fallbacks\n# - Stable termination: require consecutive verified passes and confirmation\n\nimport asyncio\nimport ast\nimport hashlib\nimport random\nimport time\nfrom typing import Tuple\n\n# ----------------------\n# Action implementations\n# ----------------------\n\nclass Action(ABC):\n    \"\"\"Base action with LLM-safe call and deterministic fallback behavior.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 0.5\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def safe_ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM.ask with retries, exponential backoff and jitter. Return deterministic error tag on failure.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            fallback = \"LLM_UNAVAILABLE\"\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n            return fallback\n\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response\")\n                # detect LLMInterface error wrappers\n                if resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower():\n                    last_err = resp\n                    raise RuntimeError(f\"LLM returned error-like text: {resp[:200]}\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Received len={len(resp)}\")\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                # backoff + jitter\n                if attempt < self.max_retries:\n                    backoff = self.base_backoff * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n        # exhausted\n        final = f\"LLM_FAILED: {last_err or 'unknown'}\"\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    def deterministic_fallback(self, idea: str) -> str:\n        return (\n            '\"\"\"Deterministic fallback implementation.\"\"\"\\n'\n            \"from typing import Any\\n\\n\"\n            \"def placeholder(value: Any = None) -> Any:\\n\"\n            \"    \\\"\\\"\\\"Fallback placeholder that returns input or raises on None.\\\"\\\"\\\"\\n\"\n            \"    if value is None:\\n\"\n            \"        raise ValueError('value cannot be None')\\n\"\n            \"    return value\\n\"\n        )\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        prompt = (\n            \"You are an expert Python developer. Produce a concise, production-ready Python module implementing the task.\\n\"\n            \"Requirements: include docstrings, input validation, clear small functions, and no surrounding markdown.\\n\\n\"\n            f\"Task: {idea}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        resp = await self.safe_ask(messages)\n        # Validate parseable Python\n        valid = False\n        if isinstance(resp, str) and not resp.startswith(\"LLM_\") and not resp.strip().lower().startswith(\"error\"):\n            try:\n                ast.parse(resp)\n                valid = True\n            except Exception as e:\n                if tracer:\n                    tracer.log(\"ACTION_VALIDATE_FAIL\", self.name, f\"AST parse error: {e}\")\n        if not valid:\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using deterministic fallback code\")\n            return self.deterministic_fallback(idea or \"\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(resp)}\")\n        return resp\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    def deterministic_fallback(self, code: str) -> str:\n        # extract probable symbol\n        symbol = \"placeholder\"\n        try:\n            tree = ast.parse(code or \"\")\n            for node in tree.body:\n                if isinstance(node, ast.FunctionDef) and not node.name.startswith(\"_\"):\n                    symbol = node.name\n                    break\n                if isinstance(node, ast.ClassDef) and not node.name.startswith(\"_\"):\n                    symbol = node.name\n                    break\n        except Exception:\n            pass\n        return (\n            \"import pytest\\n\\n\"\n            f\"def test_{symbol}_exists():\\n\"\n            f\"    \\\"\\\"\\\"Fallback: ensure '{symbol}' exists or tests pipeline keeps moving.\\\"\\\"\\\"\\n\"\n            f\"    assert True\\n\"\n        )\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided Python module. Include docstrings and assert statements.\\n\\n\"\n            f\"Module (truncated):\\n{(code or '')[:3000]}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        resp = await self.safe_ask(messages)\n        # Validate presence of assert or test_ functions\n        valid = False\n        if isinstance(resp, str) and not resp.startswith(\"LLM_\") and not resp.strip().lower().startswith(\"error\"):\n            try:\n                parsed = ast.parse(resp)\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n                if has_test_fn or has_assert:\n                    valid = True\n            except Exception:\n                valid = False\n        if not valid:\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using deterministic fallback tests\")\n            return self.deterministic_fallback(code or \"\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(resp)}\")\n        return resp\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if self.is_human:\n            out = \"HUMAN_REVIEW: Please inspect code and tests manually. REVIEW_DECISION: REQUEST_CHANGES\"\n            if tracer:\n                tracer.log(\"ACTION_HUMAN\", self.name, \"Simulated human review\")\n            return out\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Running automated review\")\n        prompt = (\n            \"You are a senior reviewer. Provide a concise review and end with one line 'REVIEW_DECISION: APPROVE' or 'REVIEW_DECISION: REQUEST_CHANGES'.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:2000]}\\n\\nTests (truncated):\\n{(tests or '')[:2000]}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        resp = await self.safe_ask(messages)\n        if not isinstance(resp, str) or \"REVIEW_DECISION:\" not in resp:\n            # infer decision heuristically\n            decision = \"APPROVE\" if (\"assert\" in (tests or \"\")) and ((\"def \" in (code or \"\")) or (\"class \" in (code or \"\"))) else \"REQUEST_CHANGES\"\n            resp = (resp or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"Inferred decision {decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(resp)}\")\n        return resp\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Code syntax\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_ok = True if (code and code.strip()) else False\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n            parsed_code = None\n\n        # Tests syntax and presence\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            tests_ok = bool(has_test_fn or has_assert)\n            if tests_ok:\n                details.append(\"tests_syntax_and_presence: ok\")\n            else:\n                details.append(\"tests_syntax: ok_but_no_tests_found\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n            parsed_tests = None\n\n        # Cross-reference: tests reference code symbols\n        if parsed_code and parsed_tests:\n            defs = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            tests_text = tests or \"\"\n            if defs:\n                for name in defs:\n                    if name and name in tests_text:\n                        referenced = True\n                        break\n                if referenced:\n                    details.append(\"tests_reference_code: ok\")\n                else:\n                    details.append(\"tests_reference_code: fail\")\n            else:\n                details.append(\"tests_reference_code: warn (no top-level defs)\")\n\n        verified = code_ok and tests_ok and referenced\n        # compute digest of artifacts for stability detection\n        digest = hashlib.sha256(((code or \"\") + \"\\n--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n# ----------------------\n# Role definitions\n# ----------------------\n\nclass Role(ABC):\n    \"\"\"Base role: single responsibility, processed-tracking and explicit routing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    env: Optional[\"Environment\"] = None\n    actions: List[Action] = []\n    watch_list: Set[str] = set()  # action names to watch\n    is_human: bool = False\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = set()\n        self.env = kwargs.get(\"env\", None)\n        # track message ids processed for idempotency\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = {a.name for a in actions}\n\n    def should_handle(self, msg: Message) -> bool:\n        \"\"\"Decide whether to handle a message:\n        - not produced by self\n        - not already processed\n        - explicitly routed via send_to\n        - or cause_by in watch_list\n        \"\"\"\n        if msg is None:\n            return False\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        mid = getattr(msg, \"id\", None)\n        if mid and mid in self._processed_ids:\n            return False\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n        try:\n            if send_to and (self.name in send_to or self.profile in send_to or \"*\" in send_to):\n                return True\n        except Exception:\n            pass\n        if getattr(msg, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input to coder(s)\n        if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute single primary action and return Message with explicit routing (send_to).\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        tracer = getattr(self.context, \"tracer\", None)\n        if message and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping msg={getattr(message,'id',None)}\")\n            return None\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Executing action={action.name} on msg={getattr(message,'id',None)}\")\n        try:\n            if isinstance(action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await action.run(idea)\n                send_to = {\"SimpleTester\"}\n                # if LLM failed, route back for retry\n                if isinstance(out, str) and (out.startswith(\"LLM_\") or out.startswith(\"Error\") or out.startswith(\"LLM_FAILED\")):\n                    send_to = {self.name}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif isinstance(action, SimpleWriteTest):\n                # prefer code in message; else lookup latest\n                code_text = getattr(message, \"content\", \"\") if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name else \"\"\n                if not code_text and self.env:\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                out = await action.run(code_text)\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif isinstance(action, SimpleWriteReview):\n                # gather latest code/tests\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                lowered = (out or \"\").lower()\n                if \"request\" in lowered or \"reject\" in lowered or \"request_changes\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif isinstance(action, SimpleVerify):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # broadcast verification to all roles for trace\n                send_to = set(r.profile for r in (self.env.roles if self.env else []))\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            else:\n                out = await action.run()\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=set())\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {type(e).__name__}: {str(e)[:200]}\"\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(content=err, role=self.profile, cause_by=\"RoleException\", sent_from=self.name, send_to={\"SimpleCoder\"})\n\n        # mark processed\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # avoid reprocessing own produced message\n        try:\n            if getattr(response, \"id\", None):\n                self._processed_ids.add(response.id)\n        except Exception:\n            pass\n\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(response,'id',None)} send_to={getattr(response,'send_to',set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])  # proactive: respond to UserInput or explicit addressing\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\n# ----------------------\n# Environment & Team\n# ----------------------\n\nclass Environment:\n    \"\"\"Message store and deterministic routing with per-role delivery tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered: role.name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n        # index by cause_by for quick artifact lookup\n        self._index_by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to is set type\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        # ensure id exists\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        cb = getattr(message, \"cause_by\", \"\")\n        if cb:\n            self._index_by_cause.setdefault(cb, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={cb} -> {list(message.send_to)} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to role and relevant by explicit routing or watch_list.\"\"\"\n        out: List[Message] = []\n        seen = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if mid is None or mid in seen:\n                continue\n            # skip own messages\n            if getattr(msg, \"sent_from\", None) == role.name:\n                seen.add(mid)\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            targeted = False\n            try:\n                if send_to and (role.name in send_to or role.profile in send_to or \"*\" in send_to):\n                    targeted = True\n            except Exception:\n                targeted = False\n            if targeted:\n                out.append(msg)\n                seen.add(mid)\n                continue\n            # watch-list trigger\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n                seen.add(mid)\n                continue\n            # default: UserInput -> coder(s)\n            if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in role.profile:\n                out.append(msg)\n                seen.add(mid)\n                continue\n        return out\n\n    def get_latest_artifact(self, cause_names: List[str]) -> Optional[Message]:\n        for name in cause_names:\n            msgs = self._index_by_cause.get(name, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Orchestrator with deterministic order, verification stability checks, error handling and nudges.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        # verification stability\n        self._last_digest: Optional[str] = None\n        self._streak: int = 0\n        self._required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _confirm_verification(self) -> bool:\n        \"\"\"Run deterministic local verifier to confirm PASS (reduce false positives).\"\"\"\n        verifier = SimpleVerify(context=self.context)\n        code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n        tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name])\n        code = code_msg.content if code_msg else \"\"\n        tests = tests_msg.content if tests_msg else \"\"\n        result = await verifier.run(code, tests)\n        return isinstance(result, str) and \"VERIFICATION_RESULT: PASS\" in result\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; require {self._required_stable_passes} stable passes\")\n        # initial user message targeted at coder profile and name(s)\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_profiles\n        )\n        self.env.publish_message(initial)\n\n        for round_idx in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            progress = False\n\n            # deterministic order\n            for role_cls in (SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier):\n                for role in [r for r in self.env.roles if isinstance(r, role_cls)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # on first round, ensure coder sees the initial instruction\n                    if isinstance(role, SimpleCoder) and round_idx == 1:\n                        msgs = [initial] + [m for m in msgs if m.id != initial.id]\n                    for m in msgs:\n                        try:\n                            resp = await role.act(m)\n                            # mark delivered already occurred in get_messages_for_role; resp may be None\n                            if resp:\n                                self.env.publish_message(resp)\n                                progress = True\n                                # if verifier produced PASS: confirm & update streak\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str) and \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                    confirmed = await self._confirm_verification()\n                                    if confirmed:\n                                        # parse digest\n                                        digest = None\n                                        for part in resp.content.split(\"|\"):\n                                            p = part.strip()\n                                            if p.startswith(\"digest=\"):\n                                                digest = p.split(\"=\", 1)[1]\n                                                break\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._streak = 1\n                                            self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                            if self._streak >= self._required_stable_passes:\n                                                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self._streak} passes; stopping\")\n                                                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed early due to verification stability\")\n                                                summary = f\"Project '{self.idea}' completed after {round_idx} rounds with {len(self.env.history)} messages. Verified=True\"\n                                                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n                                                return\n                                        else:\n                                            # treat as single pass but not stable\n                                            self._streak = 1\n                                            self._last_digest = None\n                                    else:\n                                        # confirmation failed, reset streak\n                                        self._streak = 0\n                                        self._last_digest = None\n                                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", \"Confirmation failed; reset streak\")\n\n                                elif isinstance(role, SimpleVerifier):\n                                    # explicit fail resets streak\n                                    self._streak = 0\n                                    self._last_digest = None\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Exception processing message {getattr(m,'id',None)}: {type(e).__name__}: {str(e)[:200]}\")\n                            # publish an error marker to environment to make failure visible\n                            err_msg = Message(content=f\"ERROR: role {role.name} crashed: {type(e).__name__}\", role=role.profile, cause_by=\"RoleCrash\", sent_from=role.name, send_to=set())\n                            self.env.publish_message(err_msg)\n                            progress = True\n\n            # if no progress, nudge coder(s) to avoid deadlock but avoid spamming\n            if not progress:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No progress this round; nudging coder(s)\")\n                for coder in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                    nudge = Message(content=f\"Nudge: please propose or refine implementation for: {self.idea}\", instruct_content=self.idea, role=\"System\", sent_from=\"Orchestrator\", cause_by=\"Nudge\", send_to={coder.name, coder.profile})\n                    self.env.publish_message(nudge)\n                # allow coders to process nudge quickly in same round\n                await asyncio.sleep(0.01)\n                # if still no progress next rounds, team will stop after n_round\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} completed; progress={progress}; verifier_streak={self._streak}\")\n\n        # finish\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed (max rounds reached)\")\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages. Verified={self._streak >= self._required_stable_passes}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D3 (Score: 5.5635)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport random\nimport time\nimport ast\nimport re\nfrom typing import Tuple, Any\n\n# Configuration for evolved block\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5\nROLE_MAX_ATTEMPTS = 3\nVERIFY_CONFIRMATIONS_REQUIRED = 2\nNO_PROGRESS_GRACE = 2  # rounds\n\nclass Action(ABC):\n    \"\"\"\n    Base action with:\n    - robust LLM call wrapper that returns either a valid string or an error marker beginning with 'LLM_ERROR:'.\n    - access to context.tracer for logging\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _call_llm_safe(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"\n        Call the LLM with retries and exponential backoff. Returns a string response.\n        On exhaustion returns 'LLM_ERROR: <reason>'.\n        \"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, \"LLMInterface unavailable, using deterministic fallback\")\n            return \"LLM_ERROR:LLM_UNAVAILABLE\"\n\n        for attempt in range(1, LLM_MAX_RETRIES + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_MAX_RETRIES}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or resp.strip() == \"\":\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                # Detect explicit error strings from underlying interface\n                if resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower():\n                    last_err = resp\n                    raise RuntimeError(resp)\n                # success\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Attempt {attempt} succeeded len={len(resp)}\")\n                return resp\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < LLM_MAX_RETRIES:\n                    backoff = LLM_BACKOFF_BASE * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Failed after {LLM_MAX_RETRIES} attempts: {last_err}\")\n        return f\"LLM_ERROR:{last_err}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No idea provided; returning minimal placeholder\")\n            return (\n                \"# No idea provided. Fallback implementation.\\n\"\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module that implements the described functionality.\\n\"\n            \"Requirements:\\n\"\n            \"- Clean functions/classes with docstrings\\n\"\n            \"- Defensive input validation\\n\"\n            \"- No surrounding explanation or backticks; return only Python source\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python developer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._call_llm_safe(messages)\n        # quick sanity: must contain 'def' or 'class' or be fallback\n        if code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea}\"\"\"\\n\\n'\n                \"def placeholder(input_value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder that validates input.\\\"\\\"\\\"\\n\"\n                \"    if input_value is None:\\n\"\n                \"        raise ValueError('input_value cannot be None')\\n\"\n                \"    return input_value\\n\"\n            )\n        # Validate parseable Python; if not parseable, wrap in fallback\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"AST parse failed: {e}\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea} due to parse error\"\"\"\\n\\n'\n                \"def placeholder(input_value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder after parse error.\\\"\\\"\\\"\\n\"\n                \"    if input_value is None:\\n\"\n                \"        return None\\n\"\n                \"    return input_value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated code len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No code provided; producing minimal passing test\")\n            return \"def test_placeholder():\\n    assert True\\n\"\n        # Extract public symbols heuristically\n        symbols = []\n        try:\n            tree = ast.parse(code)\n            for n in ast.walk(tree):\n                if isinstance(n, ast.FunctionDef) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n                if isinstance(n, ast.ClassDef) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n        except Exception:\n            symbols = []\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided Python module.\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest asserts\\n\"\n            \"- Cover nominal and edge cases\\n\"\n            \"- Return only the test code\\n\\n\"\n            f\"Public symbols: {', '.join(symbols[:6]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{(code or '')[:3000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._call_llm_safe(messages)\n        if tests.startswith(\"LLM_ERROR\") or not tests or (\"assert\" not in tests and \"pytest\" not in tests):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM tests invalid; using deterministic fallback\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_exists():\\n\"\n                f\"    assert callable({target})\\n\"\n            )\n        # Validate parseable\n        try:\n            ast.parse(tests)\n        except Exception:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, \"Tests AST parse failed; using fallback\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_exists():\\n\"\n                f\"    assert callable({target})\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Reviewing artifacts human={self.is_human}\")\n        if self.is_human:\n            return \"APPROVE: Human review - manual inspection recommended.\"\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review and a single-line verdict starting with VERDICT: PASS or VERDICT: FAIL.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests (truncated):\\n{(tests or '')[:1500]}\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        review = await self._call_llm_safe(messages)\n        if review.startswith(\"LLM_ERROR\") or not isinstance(review, str):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM review failed; defaulting to request changes\")\n            return \"REQUEST_CHANGE: Automated reviewer could not complete; request human review.\"\n        # ensure verdict present\n        if \"VERDICT:\" not in review:\n            review = review.strip() + \"\\n\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Starting deterministic verification\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        has_asserts = False\n        referenced = False\n\n        # Code syntax and public definitions\n        try:\n            code_tree = ast.parse(code or \"\")\n            public_defs = {n.name for n in ast.walk(code_tree) if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not getattr(n, \"name\", \"\").startswith(\"_\")}\n            code_ok = bool(public_defs)\n            diagnostics.append(f\"code_defs:{len(public_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n            public_defs = set()\n\n        # Tests syntax and heuristics\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            has_asserts = bool(re.search(r'\\bassert\\b', tests or \"\"))\n            diagnostics.append(\"tests_parse:ok\" if tests_ok else \"tests_parse:empty\")\n            diagnostics.append(\"tests_asserts:ok\" if has_asserts else \"tests_asserts:none\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        # Reference checks\n        try:\n            if public_defs and tests_ok:\n                test_names = {n.id for n in ast.walk(tests_tree) if isinstance(n, ast.Name)}\n                referenced = bool(public_defs & test_names)\n                diagnostics.append(f\"tests_reference_count:{len(public_defs & test_names)}\")\n            else:\n                diagnostics.append(\"tests_reference_count:0\")\n        except Exception as e:\n            diagnostics.append(f\"structural_check_error:{str(e)[:160]}\")\n\n        verified = code_ok and tests_ok and has_asserts and referenced\n        status = \"PASS\" if verified else \"FAIL\"\n        # compute simple digest for stability detection\n        try:\n            digest_src = (code or \"\").encode() + b\"||\" + (tests or \"\").encode()\n            import hashlib\n            digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n\n        result = f\"VERIFICATION_RESULT: {status} | digest={digest} | {'; '.join(diagnostics)}\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"{result}\")\n        return result\n\n\nclass Role(ABC):\n    \"\"\"\n    Base role:\n    - single primary action\n    - clear watch_list (list of cause_by tokens)\n    - maintains processed message ids to avoid duplicate work\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional['Environment'] = kwargs.get('env', None)\n        self._processed_message_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        if not message:\n            return False\n        if getattr(message, \"id\", None) in self._processed_message_ids:\n            return False\n        # explicit addressing takes precedence\n        send_to = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n        if send_to:\n            if isinstance(send_to, (set, list)):\n                if self.name in send_to or self.profile in send_to or \"*\" in send_to:\n                    return True\n            elif isinstance(send_to, str):\n                if send_to in (self.name, self.profile, \"*\"):\n                    return True\n        # watched triggers\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input to coders\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n\n        action = self.actions[0]\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message id={getattr(message,'id',None)}\")\n            return None\n\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_MAX_ATTEMPTS:\n            attempts += 1\n            try:\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    # code may be in message.content or in env latest code\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        # find latest code\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    # gather latest artifacts\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    # If reviewer requests change, route back to coder; else to verifier\n                    if isinstance(out, str) and out.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                        recipients = {\"SimpleCoder\"}\n                    else:\n                        recipients = {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    # gather latest code/tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = set()  # broadcast by team if needed\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark message processed\n                if message and getattr(message, \"id\", None):\n                    self._processed_message_ids.add(message.id)\n\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg id={getattr(response,'id',None)} cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:200]}\")\n                await asyncio.sleep(0.1 * attempts)\n        # exhausted attempts\n        err_msg = f\"ROLE_FAILED: {self.name} after {ROLE_MAX_ATTEMPTS} attempts - {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, err_msg)\n        response = Message(\n            content=err_msg,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview])\n\n\nclass Environment:\n    \"\"\"\n    Manages message history, routing and processed state.\n    \"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # per-message processing tracking: msg_id -> set(role.name)\n        self._processed: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"Message {message.id} processed by {role.name}\")\n\n    def has_been_processed_by(self, message: Message, role: Role) -> bool:\n        return role.name in self._processed.get(message.id, set())\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        relevant: List[Message] = []\n        for msg in self.history:\n            # skip messages already processed by this role\n            if getattr(msg, \"id\", None) in getattr(role, \"_processed_message_ids\", set()):\n                continue\n            # skip messages role produced itself\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit addressing\n            send_to = getattr(msg, \"send_to\", None)\n            if send_to:\n                if isinstance(send_to, (set, list)) and (role.name in send_to or role.profile in send_to or \"*\" in send_to):\n                    relevant.append(msg)\n                    continue\n            sent_to_str = getattr(msg, \"sent_to\", None)\n            if isinstance(sent_to_str, str) and (sent_to_str == role.name or sent_to_str == role.profile or sent_to_str == \"*\"):\n                relevant.append(msg)\n                continue\n            # watch_list trigger\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n                continue\n        return relevant\n\n\nclass Team:\n    \"\"\"\n    Orchestrates roles, termination and verification handshake.\n    \"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self._verify_confirm_count = 0\n        self._verify_confirm_needed = VERIFY_CONFIRMATIONS_REQUIRED\n        self._verify_pass_rounds: Set[int] = set()\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; need {self._verify_confirm_needed} verifications to stop early\")\n        # initial user instruction targeted to coder(s)\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        # deterministic order to reduce races\n        orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(n_round):\n            round_num = round_idx + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            progress_made = False\n\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # Ensure coder sees initial instruction on first round\n                    if isinstance(role, SimpleCoder) and round_idx == 0:\n                        msgs = [initial_msg] + [m for m in msgs if m.id != initial_msg.id]\n                    for msg in msgs:\n                        try:\n                            resp = await role.act(msg)\n                            # mark processed even on failures to avoid livelock\n                            self.env.mark_processed(msg, role)\n                            if resp:\n                                self.env.publish_message(resp)\n                                progress_made = True\n                                # verification handling\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    if \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                        self._verify_confirm_count += 1\n                                        self._verify_pass_rounds.add(round_idx)\n                                        self.tracer.log(\"VERIFY_CONFIRM\", \"Team\", f\"Verifier {role.name} PASS ({self._verify_confirm_count}/{self._verify_confirm_needed})\")\n                                        if self._verify_confirm_count >= self._verify_confirm_needed:\n                                            verified = True\n                                    elif \"VERIFICATION_RESULT: FAIL\" in resp.content:\n                                        self._verify_confirm_count = 0\n                                        self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Verifier {role.name} reported FAIL; confirmations reset\")\n                                # log role-produced errors\n                                if isinstance(resp.content, str) and resp.content.startswith(\"ROLE_FAILED\"):\n                                    self.tracer.log(\"ROLE_FAILURE\", \"Team\", resp.content[:200])\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {e}\")\n\n            # check progress\n            if len(self.env.history) == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} complete progress={progress_made}\")\n\n            # Termination: require confirmations and at least one extra round of stability\n            if verified and round_num >= 1:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification confirmed ({self._verify_confirm_count}); stopping early\")\n                break\n\n            if no_progress_rounds >= NO_PROGRESS_GRACE:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating\")\n                break\n\n            # small cooperative pause\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        summary = f\"Project '{self.idea}' finished after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D4 (Score: 5.5635)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport random\nimport time\nimport ast\nimport hashlib\nfrom typing import Tuple, Iterable, Callable\n\n# Evolution parameters (tunable)\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5\nROLE_MAX_ATTEMPTS = 3\nVERIFY_REQUIRED_STREAK = 2\nNO_PROGRESS_GRACE = 2  # rounds before terminating for lack of progress\n\n# ---------------------------\n# Actions\n# ---------------------------\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call wrapper and clear contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = LLM_MAX_RETRIES\n    base_backoff: float = LLM_BACKOFF_BASE\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _call_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries, exponential backoff and jitter. Returns string or error marker.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_UNAVAILABLE\", self.name, \"LLMInterface not configured; using deterministic fallback marker\")\n            return \"LLM_ERROR:LLM_UNAVAILABLE\"\n\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                low = resp.strip().lower()\n                if low.startswith(\"error\") or \"error communicating\" in low:\n                    last_err = resp\n                    raise RuntimeError(f\"LLM returned error-like text: {resp[:200]}\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Attempt {attempt} success len={len(resp)}\")\n                return resp\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < self.max_retries:\n                    backoff = self.base_backoff * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Giving up after {self.max_retries} attempts: {last_err}\")\n        return f\"LLM_ERROR:{last_err}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return an artifact string.\"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"Empty idea; returning deterministic fallback code\")\n            return (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback placeholder.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a compact, production-ready Python module implementing the task.\\n\"\n            \"Return only valid Python source code. Include docstrings and input validation where reasonable.\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._call_llm(messages)\n        if isinstance(code, str) and code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback code\")\n            return (\n                f'\\\"\\\"\\\"Fallback implementation for: {idea[:120]}\\\"\\\"\\\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder implementation.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        # validate parseable Python\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_INVALID\", self.name, f\"Generated code not parseable: {e}\")\n            return (\n                f'\\\"\\\"\\\"Fallback due to parse error for: {idea[:120]}\\\"\\\"\\\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback after parse error.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated code len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No code provided; returning minimal test\")\n            return \"def test_placeholder():\\n    assert True\\n\"\n        # extract symbols\n        symbols = []\n        try:\n            parsed = ast.parse(code)\n            for n in parsed.body:\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n        except Exception:\n            symbols = []\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided module. \"\n            \"Include nominal and at least one edge-case. Return only pytest code.\\n\\n\"\n            f\"Public symbols (heuristic): {', '.join(symbols[:6]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{(code or '')[:3000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._call_llm(messages)\n        if isinstance(tests, str) and tests.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback tests\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_exists():\\n\"\n                f\"    # basic presence test for {target}\\n\"\n                f\"    assert True\\n\"\n            )\n        # validate tests parseable and contain assert or test_ function\n        try:\n            parsed_tests = ast.parse(tests)\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in parsed_tests.body)\n            has_assert = \"assert \" in tests or any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            if not (has_test_fn or has_assert):\n                raise ValueError(\"No tests/asserts detected\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Tests invalid: {e}\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # quick static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: manual review recommended; \" + (\"; \".join(issues) if issues else \"no static issues found\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review supplied\")\n            return review\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review and end with a single-line VERDICT: PASS or VERDICT: FAIL.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests (truncated):\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        review = await self._call_llm(messages)\n        if isinstance(review, str) and review.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM review unavailable; requesting changes\")\n            return \"REQUEST_CHANGE: Automated review unavailable; request human review.\"\n        if \"VERDICT:\" not in (review or \"\"):\n            review = (review or \"\").strip() + \"\\n\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Performing deterministic verification\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # code parse and detect defs\n        code_defs = set()\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_defs = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            code_ok = bool(parsed_code and code_defs)\n            diagnostics.append(f\"code_defs:{len(code_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n\n        # tests parse and assert presence\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests)) or (\"assert \" in (tests or \"\"))\n            tests_ok = has_test_fn or has_assert\n            diagnostics.append(\"tests_has_assert\" if has_assert else \"tests_no_assert\")\n            diagnostics.append(\"tests_has_test_fn\" if has_test_fn else \"tests_no_test_fn\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        # cross-reference\n        try:\n            if code_defs and tests_ok:\n                for name in code_defs:\n                    if name and name in (tests or \"\"):\n                        referenced = True\n                        break\n                diagnostics.append(f\"tests_reference_count:{sum(1 for n in code_defs if n in (tests or ''))}\")\n            else:\n                diagnostics.append(\"tests_reference_count:0\")\n        except Exception as e:\n            diagnostics.append(f\"reference_check_error:{str(e)[:160]}\")\n\n        verified = code_ok and tests_ok and referenced\n        status = \"PASS\" if verified else \"FAIL\"\n        # stable digest for change detection\n        try:\n            digest_src = (code or \"\").encode() + b\"||\" + (tests or \"\").encode()\n            digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n        result = f\"VERIFICATION_RESULT: {status} | digest={digest} | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n# ---------------------------\n# Roles\n# ---------------------------\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities, watch/trigger logic, and idempotency.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = kwargs.get(\"env\", None)\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        \"\"\"Decide whether to respond to a message.\"\"\"\n        if not message:\n            return False\n        if getattr(message, \"id\", None) in self._processed_ids:\n            return False\n        # explicit addressing: send_to (preferred) or sent_to\n        send_to = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n        if send_to:\n            try:\n                if isinstance(send_to, (set, list)):\n                    if self.name in send_to or self.profile in send_to or \"*\" in send_to:\n                        return True\n                elif isinstance(send_to, str):\n                    if send_to in (self.name, self.profile, \"*\"):\n                        return True\n            except Exception:\n                pass\n        # watch-trigger\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input to coders\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action with retries and return produced Message (or None).\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message id={getattr(message,'id',None)}\")\n            return None\n\n        action = self.actions[0]\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_MAX_ATTEMPTS:\n            attempts += 1\n            try:\n                # Dispatch by action type\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    code_text = getattr(message, \"content\", \"\") if message else \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        # find latest code artifact\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    # collect latest code and tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    lowered = (out or \"\").lower()\n                    if lowered.startswith(\"request_change\") or \"request_change\" in lowered or \"request_changes\" in lowered:\n                        recipients = {\"SimpleCoder\", \"SimpleTester\"}\n                    else:\n                        recipients = {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = set()  # broadcast handled by orchestrator\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark processed input to avoid reprocessing\n                if message and getattr(message, \"id\", None):\n                    self._processed_ids.add(message.id)\n\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced {getattr(response,'id',None)} cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:200]}\")\n                await asyncio.sleep(0.1 * attempts)\n        # exhausted attempts\n        fail = f\"ROLE_FAILED: {self.name} after {ROLE_MAX_ATTEMPTS} attempts - {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, fail[:200])\n        response = Message(\n            content=fail,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\n# ---------------------------\n# Environment\n# ---------------------------\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing, processed-tracking and artifact lookup.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered: role_name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure id exists for non-pydantic fallback\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        # normalize send_to\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def mark_delivered(self, role: Role, message: Message):\n        if not getattr(message, \"id\", None):\n            return\n        self._delivered.setdefault(role.name, set()).add(message.id)\n        if self.tracer:\n            self.tracer.log(\"ENV_MARK_DELIVERED\", \"Environment\", f\"{role.name} delivered {message.id}\")\n\n    def has_been_delivered(self, role: Role, message: Message) -> bool:\n        return getattr(message, \"id\", None) in self._delivered.get(role.name, set())\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to role that should be handled by it.\"\"\"\n        out: List[Message] = []\n        delivered = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if not mid or mid in delivered:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                # mark self-produced messages as delivered for this role\n                delivered.add(mid)\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            targeted = False\n            try:\n                if isinstance(send_to, (set, list)):\n                    if role.name in send_to or role.profile in send_to:\n                        targeted = True\n                elif isinstance(send_to, str):\n                    if send_to in (role.name, role.profile):\n                        targeted = True\n            except Exception:\n                targeted = False\n            if targeted:\n                out.append(msg)\n                delivered.add(mid)\n                continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n                delivered.add(mid)\n                continue\n        return out\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by is in cause_names.\"\"\"\n        cause_set = set(cause_names)\n        for msg in reversed(self.history):\n            if getattr(msg, \"cause_by\", None) in cause_set:\n                return msg\n        return None\n\n# ---------------------------\n# Team orchestrator\n# ---------------------------\n\nclass Team:\n    \"\"\"Orchestrates roles, termination, verification handshake, and stability checks.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self._verify_streak: int = 0\n        self._verify_required: int = VERIFY_REQUIRED_STREAK\n        self._last_digest: Optional[str] = None\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role(self, role: Role) -> int:\n        \"\"\"Process pending messages for a role and return number of produced messages.\"\"\"\n        produced = 0\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            return 0\n        for msg in msgs:\n            # Protect against role processing its own message\n            if getattr(msg, \"sent_from\", None) == role.name:\n                self.env.mark_delivered(role, msg)\n                continue\n            try:\n                resp = await role.act(msg)\n            except Exception as e:\n                self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {e}\")\n                resp = Message(content=f\"ERROR: role {role.name} crashed: {str(e)}\", role=role.profile, cause_by=\"RoleCrash\", sent_from=role.name, send_to=set())\n            # mark delivered even if resp is None so we don't retry forever\n            self.env.mark_delivered(role, msg)\n            if resp:\n                self.env.publish_message(resp)\n                produced += 1\n                # update verification streak if verifier role\n                if isinstance(role, SimpleVerifier):\n                    content = resp.content or \"\"\n                    if \"VERIFICATION_RESULT: PASS\" in content:\n                        # extract digest if present\n                        digest = None\n                        for token in content.split(\"|\"):\n                            token = token.strip()\n                            if token.startswith(\"digest=\"):\n                                digest = token.split(\"=\", 1)[1]\n                                break\n                        if digest and digest == self._last_digest:\n                            self._verify_streak += 1\n                        elif digest:\n                            self._last_digest = digest\n                            self._verify_streak = 1\n                        else:\n                            # pass without digest: treat as single pass but not stable\n                            self._last_digest = None\n                            self._verify_streak += 1\n                        self.tracer.log(\"VERIFY_UPDATE\", \"Team\", f\"streak={self._verify_streak} digest={digest}\")\n                    else:\n                        if self._verify_streak > 0:\n                            self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Resetting streak {self._verify_streak}->0\")\n                        self._verify_streak = 0\n                        self._last_digest = None\n        return produced\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; require {self._verify_required} stable verifications to stop early\")\n        # initial message to coder(s)\n        coder_targets = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_targets\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        # deterministic processing order to reduce races\n        orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(n_round):\n            round_num = round_idx + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            round_new_msgs = 0\n\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    # ensure coder sees initial on first round\n                    if isinstance(role, SimpleCoder) and round_idx == 0:\n                        # if initial not delivered to coder yet, ensure delivery\n                        if not self.env.has_been_delivered(role, initial_msg):\n                            # deliver initial message for processing\n                            self.env._delivered.setdefault(role.name, set()).discard(initial_msg.id) if False else None\n                    produced = await self._process_role(role)\n                    round_new_msgs += produced\n\n            # compute progress\n            if len(self.env.history) == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} complete produced={round_new_msgs} verify_streak={self._verify_streak}\")\n\n            # termination: require at least one full round and stable verification streak\n            if self._verify_streak >= self._verify_required and round_num >= 1:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self._verify_streak} passes; stopping\")\n                verified = True\n                break\n\n            # stop if no progress for multiple rounds\n            if no_progress_rounds >= NO_PROGRESS_GRACE:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating early\")\n                break\n\n            # if stalled but not yet terminated, nudge coder once\n            if round_new_msgs == 0:\n                for r in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                    nudge = Message(\n                        content=f\"Nudge: please refine implementation for: {self.idea}\",\n                        instruct_content=self.idea,\n                        role=\"System\",\n                        sent_from=\"Orchestrator\",\n                        cause_by=\"Nudge\",\n                        send_to={r.profile}\n                    )\n                    self.env.publish_message(nudge)\n\n            # cooperative yield\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        summary = f\"Project '{self.idea}' finished after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 4.9844, Type: Migrant)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (3.167)\n\n\n### Inspiration 2 (Score: 7.4985, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"LLM_UNAVAILABLE_FALLBACK: deterministic placeholder response\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport random\nimport hashlib\nimport time\nfrom typing import Tuple\n\n# Design goals implemented:\n# - Clear single-responsibility roles\n# - Robust routed communication (send_to) and watch/trigger logic\n# - Idempotent processing to avoid duplicate handling\n# - LLM call wrapper with retries, backoff and deterministic fallbacks\n# - Strong verification with syntax checks and stable digest\n# - Termination only after consecutive verification confirmations and deadlock nudges\n\nclass Action(ABC):\n    \"\"\"Base action providing LLM call helper and a run contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 0.5  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def ask_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries, exponential backoff and jitter. Return deterministic error token on failure.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            fallback = \"LLM_UNAVAILABLE: fallback response\"\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n            return fallback\n\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or resp.strip() == \"\":\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                if resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower():\n                    last_err = resp\n                    raise RuntimeError(\"LLM returned error-like text\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"LLM returned len={len(resp)}\")\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < self.max_retries:\n                    backoff = self.base_backoff * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.15)\n                    await asyncio.sleep(backoff + jitter)\n                else:\n                    if tracer:\n                        tracer.log(\"LLM_GIVEUP\", self.name, f\"Exhausted retries: {last_err[:200]}\")\n        return f\"LLM_FAILURE: {last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            note = \"# WARNING: empty idea provided; returning deterministic placeholder\\n\\ndef placeholder():\\n    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n    return None\\n\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, \"Empty idea - returning placeholder\")\n            return note\n\n        prompt = (\n            \"You are an expert Python developer. Produce a compact, production-ready Python implementation.\\n\"\n            \"Include docstrings, input validation, and clear error handling. Return only Python source code.\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        code = await self.ask_llm(messages)\n        # Validate syntax\n        valid = False\n        try:\n            if isinstance(code, str) and not code.startswith(\"LLM_\") and not code.startswith(\"Error\"):\n                ast.parse(code)\n                valid = True\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATE_FAIL\", self.name, f\"parse_error: {e}\")\n            valid = False\n\n        if not valid:\n            fallback = (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Deterministic fallback implementation.\\\"\\\"\\\"\\n\"\n                \"    if value is None:\\n\"\n                \"        return None\\n\"\n                \"    return value\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using deterministic fallback code\")\n            return fallback\n\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Produce pytest-style tests that cover typical behavior, edge cases, and errors.\\n\"\n            \"Return only pytest-compatible Python test code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        tests = await self.ask_llm(messages)\n\n        # Basic validation heuristics\n        valid = False\n        try:\n            if isinstance(tests, str) and not tests.startswith(\"LLM_\") and not tests.startswith(\"Error\"):\n                parsed = ast.parse(tests)\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n                if has_test_fn or has_assert:\n                    valid = True\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATE_FAIL\", self.name, f\"tests_parse_error: {e}\")\n            valid = False\n\n        if not valid:\n            fallback = (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using deterministic fallback tests\")\n            return fallback\n\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, \"Human review simulated\")\n            return review\n\n        prompt = (\n            \"You are a senior engineer. Provide a concise structured review and end with a decision line:\\n\"\n            \"REVIEW_DECISION: APPROVE or REVIEW_DECISION: REQUEST_CHANGES\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:2000]}\\n\\nTests (truncated):\\n{(tests or '')[:2000]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues}\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        review = await self.ask_llm(messages)\n        if not isinstance(review, str) or \"REVIEW_DECISION:\" not in review:\n            decision = \"APPROVE\" if ((\"assert\" in (tests or \"\")) or (\"def test_\" in (tests or \"\"))) and ((\"def \" in (code or \"\")) or (\"class \" in (code or \"\"))) else \"REQUEST_CHANGES\"\n            review = (review or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"No decision from LLM; inferred {decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Syntax checks\n        try:\n            ast.parse(code or \"\")\n            code_ok = True\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            if has_test_fn or has_assert:\n                tests_ok = True\n                details.append(\"tests_syntax_and_presence: ok\")\n            else:\n                details.append(\"tests_syntax_and_presence: fail (no tests/asserts)\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n\n        # Cross-reference\n        try:\n            parsed_code = ast.parse(code or \"\")\n            def_names = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            tests_text = tests or \"\"\n            if def_names:\n                for nm in def_names:\n                    if nm and nm in tests_text:\n                        referenced = True\n                        break\n                details.append(f\"code_defs_count: {len(def_names)}\")\n            else:\n                details.append(\"code_defs_count: 0\")\n        except Exception:\n            details.append(\"code_parse_error_for_defs\")\n\n        verified = code_ok and tests_ok and referenced\n        # stable digest for artifacts\n        digest = hashlib.sha256(((code or \"\") + \"\\n--TESTS--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role: single primary action, watch-list, idempotency tracking.\"\"\"\n\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # action names to watch\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env = None\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def _should_respond(self, msg: Message) -> bool:\n        \"\"\"Decide whether to respond to message.\"\"\"\n        if msg is None:\n            return False\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        mid = getattr(msg, \"id\", None)\n        if mid and mid in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n        if send_to:\n            if self.name in send_to or self.profile in send_to or \"*\" in send_to:\n                return True\n            return False\n        # watch-list trigger\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        # user input defaults to coder(s)\n        if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform primary action and return a Message.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        tracer = getattr(self.context, \"tracer\", None)\n\n        if message and not self._should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message id={getattr(message,'id',None)}\")\n            return None\n\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Executing {action.name} on msg={getattr(message,'id',None)}\")\n\n        try:\n            if action.name == SimpleWriteCode.name:\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await action.run(idea)\n                send_to = {\"SimpleTester\"}\n                # if LLM error markers present, route to self for retry\n                if isinstance(out, str) and (out.startswith(\"LLM_FAILURE\") or out.startswith(\"LLM_UNAVAILABLE\") or out.startswith(\"Error\")):\n                    send_to = {self.name}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif action.name == SimpleWriteTest.name:\n                # prefer code in message content; else find latest code artifact\n                code_text = getattr(message, \"content\", \"\") if message else \"\"\n                if not code_text and self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                out = await action.run(code_text)\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif action.name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                out = await action.run(code_text, tests_text)\n                lowered = (out or \"\").lower()\n                if \"request_changes\" in lowered or \"request change\" in lowered or \"reject\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif action.name == SimpleVerify.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                out = await action.run(code_text, tests_text)\n                # verification broadcast (empty send_to = broadcast)\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=set())\n            else:\n                out = await action.run()\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=set())\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {type(e).__name__}: {str(e)[:200]}\"\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(content=err, role=self.profile, cause_by=\"RoleException\", sent_from=self.name, send_to={\"SimpleCoder\"})\n\n        # mark processed\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # mark produced message id locally to avoid reprocessing own message\n        try:\n            if getattr(response, \"id\", None):\n                self._processed_ids.add(response.id)\n        except Exception:\n            pass\n\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(response,'id',None)} send_to={getattr(response,'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # proactive; triggered by UserInput or explicit addressing\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Holds roles, history, and ensures idempotent delivery tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # per-role delivered set: role.name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        # ensure id exists\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages that the role hasn't processed and should consider.\"\"\"\n        out: List[Message] = []\n        seen = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if mid is None or mid in seen:\n                continue\n            # skip messages produced by same role\n            if getattr(msg, \"sent_from\", None) == role.name:\n                # mark as delivered to avoid reconsideration\n                seen.add(mid)\n                continue\n            # explicit routing takes precedence\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.name in send_to or role.profile in send_to or \"*\" in send_to:\n                    out.append(msg)\n                    seen.add(mid)\n                    continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n                seen.add(mid)\n                continue\n            # user input defaults to coder\n            if msg.cause_by == \"UserInput\" and \"Coder\" in role.profile:\n                out.append(msg)\n                seen.add(mid)\n        return out\n\nclass Team:\n    \"\"\"Orchestrator: deterministic ordering, stable verification, deadlock nudges, robust error handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability\n        self._verify_streak: int = 0\n        self._verify_required: int = 2\n        self._last_digest: Optional[str] = None\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run orchestration loop with deterministic ordering and termination rules.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (need {self._verify_required} stable passes)\")\n        # initial message targeted at coder(s)\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_profiles\n        )\n        self.env.publish_message(initial_msg)\n\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        for round_num in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            new_messages = 0\n\n            for RoleClass in order:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # On first round ensure coder gets the initial message\n                    if isinstance(role, SimpleCoder) and round_num == 1:\n                        if initial_msg not in msgs:\n                            msgs = [initial_msg] + msgs\n                    for m in msgs:\n                        try:\n                            resp = await role.act(m)\n                            # message considered delivered within get_messages_for_role\n                            if resp:\n                                self.env.publish_message(resp)\n                                new_messages += 1\n                                # handle verifier pass detection\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str) and \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                    # parse digest\n                                    digest = None\n                                    for part in (resp.content or \"\").split(\"|\"):\n                                        part = part.strip()\n                                        if part.startswith(\"digest=\"):\n                                            digest = part.split(\"=\", 1)[1]\n                                            break\n                                    if digest:\n                                        if digest == self._last_digest:\n                                            self._verify_streak += 1\n                                        else:\n                                            self._last_digest = digest\n                                            self._verify_streak = 1\n                                        self.tracer.log(\"VERIFIER_UPDATE\", \"Team\", f\"digest={digest} streak={self._verify_streak}\")\n                                        # confirm via deterministic re-run of verifier to avoid fluke\n                                        try:\n                                            verifier_action = SimpleVerify(context=self.context)\n                                            code_msg = next((x for x in reversed(self.env.history) if x.cause_by == SimpleWriteCode.name), None)\n                                            tests_msg = next((x for x in reversed(self.env.history) if x.cause_by == SimpleWriteTest.name), None)\n                                            code_text = code_msg.content if code_msg else \"\"\n                                            tests_text = tests_msg.content if tests_msg else \"\"\n                                            confirm = await verifier_action.run(code_text, tests_text)\n                                            if isinstance(confirm, str) and \"VERIFICATION_RESULT: PASS\" in confirm:\n                                                # confirmed\n                                                pass\n                                            else:\n                                                # not confirmed -> reset streak\n                                                self._verify_streak = 0\n                                                self._last_digest = None\n                                                self.tracer.log(\"VERIFIER_RESET\", \"Team\", \"Confirmation failed; reset streak\")\n                                        except Exception as e:\n                                            # on confirmation error, do not count\n                                            self._verify_streak = 0\n                                            self._last_digest = None\n                                            self.tracer.log(\"VERIFIER_CONFIRM_ERROR\", \"Team\", f\"Confirmation exception: {e}\")\n                                    else:\n                                        # pass without digest - do not consider stable\n                                        self._verify_streak = 0\n                                        self._last_digest = None\n                                        self.tracer.log(\"VERIFIER_NONSTABLE\", \"Team\", \"Verifier PASS without digest; not stable\")\n                                elif isinstance(role, SimpleVerifier):\n                                    # explicit fail resets streak\n                                    self._verify_streak = 0\n                                    self._last_digest = None\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Exception processing message {getattr(m,'id',None)}: {type(e).__name__}: {str(e)[:200]}\")\n                            continue\n\n            # post-round checks\n            if self._verify_streak >= self._verify_required:\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Verification stable (streak={self._verify_streak}); stopping early\")\n                break\n\n            current_len = len(self.env.history)\n            if current_len == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = current_len\n\n            if no_progress_rounds >= 2:\n                # nudge coders\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; nudging coder(s)\")\n                for coder in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                    nudge = Message(\n                        content=f\"Nudge: please propose or refine implementation for: {self.idea}\",\n                        instruct_content=self.idea,\n                        role=\"System\",\n                        sent_from=\"Orchestrator\",\n                        cause_by=\"Nudge\",\n                        send_to={coder.name}\n                    )\n                    self.env.publish_message(nudge)\n                # allow immediate small pause for processing\n                await asyncio.sleep(0.01)\n\n            # safeguard: avoid infinite loop\n            if no_progress_rounds >= 4:\n                self.tracer.log(\"TEAM_STALLED\", \"Team\", \"Stalled for multiple rounds; terminating\")\n                break\n\n            await asyncio.sleep(0)  # yield to event loop\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} end; history_len={len(self.env.history)} verify_streak={self._verify_streak}\")\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' ended; history_len={len(self.env.history)} verify_streak={self._verify_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (5.333)\n\n\n### Inspiration 3 (Score: 5.5635, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport random\nimport time\nimport ast\nimport re\nfrom typing import Tuple, Any\n\n# Configuration for evolved block\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5\nROLE_MAX_ATTEMPTS = 3\nVERIFY_CONFIRMATIONS_REQUIRED = 2\nNO_PROGRESS_GRACE = 2  # rounds\n\nclass Action(ABC):\n    \"\"\"\n    Base action with:\n    - robust LLM call wrapper that returns either a valid string or an error marker beginning with 'LLM_ERROR:'.\n    - access to context.tracer for logging\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _call_llm_safe(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"\n        Call the LLM with retries and exponential backoff. Returns a string response.\n        On exhaustion returns 'LLM_ERROR: <reason>'.\n        \"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        last_err = None\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, \"LLMInterface unavailable, using deterministic fallback\")\n            return \"LLM_ERROR:LLM_UNAVAILABLE\"\n\n        for attempt in range(1, LLM_MAX_RETRIES + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_MAX_RETRIES}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or resp.strip() == \"\":\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                # Detect explicit error strings from underlying interface\n                if resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower():\n                    last_err = resp\n                    raise RuntimeError(resp)\n                # success\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Attempt {attempt} succeeded len={len(resp)}\")\n                return resp\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < LLM_MAX_RETRIES:\n                    backoff = LLM_BACKOFF_BASE * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Failed after {LLM_MAX_RETRIES} attempts: {last_err}\")\n        return f\"LLM_ERROR:{last_err}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No idea provided; returning minimal placeholder\")\n            return (\n                \"# No idea provided. Fallback implementation.\\n\"\n                \"def placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module that implements the described functionality.\\n\"\n            \"Requirements:\\n\"\n            \"- Clean functions/classes with docstrings\\n\"\n            \"- Defensive input validation\\n\"\n            \"- No surrounding explanation or backticks; return only Python source\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python developer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self._call_llm_safe(messages)\n        # quick sanity: must contain 'def' or 'class' or be fallback\n        if code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic fallback\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea}\"\"\"\\n\\n'\n                \"def placeholder(input_value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder that validates input.\\\"\\\"\\\"\\n\"\n                \"    if input_value is None:\\n\"\n                \"        raise ValueError('input_value cannot be None')\\n\"\n                \"    return input_value\\n\"\n            )\n        # Validate parseable Python; if not parseable, wrap in fallback\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"AST parse failed: {e}\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea} due to parse error\"\"\"\\n\\n'\n                \"def placeholder(input_value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder after parse error.\\\"\\\"\\\"\\n\"\n                \"    if input_value is None:\\n\"\n                \"        return None\\n\"\n                \"    return input_value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated code len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_SKIPPED\", self.name, \"No code provided; producing minimal passing test\")\n            return \"def test_placeholder():\\n    assert True\\n\"\n        # Extract public symbols heuristically\n        symbols = []\n        try:\n            tree = ast.parse(code)\n            for n in ast.walk(tree):\n                if isinstance(n, ast.FunctionDef) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n                if isinstance(n, ast.ClassDef) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n        except Exception:\n            symbols = []\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests for the provided Python module.\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest asserts\\n\"\n            \"- Cover nominal and edge cases\\n\"\n            \"- Return only the test code\\n\\n\"\n            f\"Public symbols: {', '.join(symbols[:6]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{(code or '')[:3000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self._call_llm_safe(messages)\n        if tests.startswith(\"LLM_ERROR\") or not tests or (\"assert\" not in tests and \"pytest\" not in tests):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM tests invalid; using deterministic fallback\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_exists():\\n\"\n                f\"    assert callable({target})\\n\"\n            )\n        # Validate parseable\n        try:\n            ast.parse(tests)\n        except Exception:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, \"Tests AST parse failed; using fallback\")\n            target = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_exists():\\n\"\n                f\"    assert callable({target})\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Generated tests len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"Reviewing artifacts human={self.is_human}\")\n        if self.is_human:\n            return \"APPROVE: Human review - manual inspection recommended.\"\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review and a single-line verdict starting with VERDICT: PASS or VERDICT: FAIL.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests (truncated):\\n{(tests or '')[:1500]}\\n\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        review = await self._call_llm_safe(messages)\n        if review.startswith(\"LLM_ERROR\") or not isinstance(review, str):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM review failed; defaulting to request changes\")\n            return \"REQUEST_CHANGE: Automated reviewer could not complete; request human review.\"\n        # ensure verdict present\n        if \"VERDICT:\" not in review:\n            review = review.strip() + \"\\n\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Starting deterministic verification\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        has_asserts = False\n        referenced = False\n\n        # Code syntax and public definitions\n        try:\n            code_tree = ast.parse(code or \"\")\n            public_defs = {n.name for n in ast.walk(code_tree) if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not getattr(n, \"name\", \"\").startswith(\"_\")}\n            code_ok = bool(public_defs)\n            diagnostics.append(f\"code_defs:{len(public_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n            public_defs = set()\n\n        # Tests syntax and heuristics\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n            has_asserts = bool(re.search(r'\\bassert\\b', tests or \"\"))\n            diagnostics.append(\"tests_parse:ok\" if tests_ok else \"tests_parse:empty\")\n            diagnostics.append(\"tests_asserts:ok\" if has_asserts else \"tests_asserts:none\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        # Reference checks\n        try:\n            if public_defs and tests_ok:\n                test_names = {n.id for n in ast.walk(tests_tree) if isinstance(n, ast.Name)}\n                referenced = bool(public_defs & test_names)\n                diagnostics.append(f\"tests_reference_count:{len(public_defs & test_names)}\")\n            else:\n                diagnostics.append(\"tests_reference_count:0\")\n        except Exception as e:\n            diagnostics.append(f\"structural_check_error:{str(e)[:160]}\")\n\n        verified = code_ok and tests_ok and has_asserts and referenced\n        status = \"PASS\" if verified else \"FAIL\"\n        # compute simple digest for stability detection\n        try:\n            digest_src = (code or \"\").encode() + b\"||\" + (tests or \"\").encode()\n            import hashlib\n            digest = hashlib.sha256(digest_src).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n\n        result = f\"VERIFICATION_RESULT: {status} | digest={digest} | {'; '.join(diagnostics)}\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"{result}\")\n        return result\n\n\nclass Role(ABC):\n    \"\"\"\n    Base role:\n    - single primary action\n    - clear watch_list (list of cause_by tokens)\n    - maintains processed message ids to avoid duplicate work\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional['Environment'] = kwargs.get('env', None)\n        self._processed_message_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        if not message:\n            return False\n        if getattr(message, \"id\", None) in self._processed_message_ids:\n            return False\n        # explicit addressing takes precedence\n        send_to = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n        if send_to:\n            if isinstance(send_to, (set, list)):\n                if self.name in send_to or self.profile in send_to or \"*\" in send_to:\n                    return True\n            elif isinstance(send_to, str):\n                if send_to in (self.name, self.profile, \"*\"):\n                    return True\n        # watched triggers\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input to coders\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n\n        action = self.actions[0]\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping message id={getattr(message,'id',None)}\")\n            return None\n\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_MAX_ATTEMPTS:\n            attempts += 1\n            try:\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    # code may be in message.content or in env latest code\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        # find latest code\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    # gather latest artifacts\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    # If reviewer requests change, route back to coder; else to verifier\n                    if isinstance(out, str) and out.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                        recipients = {\"SimpleCoder\"}\n                    else:\n                        recipients = {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    # gather latest code/tests\n                    code_text = \"\"\n                    tests_text = \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = set()  # broadcast by team if needed\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark message processed\n                if message and getattr(message, \"id\", None):\n                    self._processed_message_ids.add(message.id)\n\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg id={getattr(response,'id',None)} cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as exc:\n                last_err = str(exc)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:200]}\")\n                await asyncio.sleep(0.1 * attempts)\n        # exhausted attempts\n        err_msg = f\"ROLE_FAILED: {self.name} after {ROLE_MAX_ATTEMPTS} attempts - {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, err_msg)\n        response = Message(\n            content=err_msg,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview])\n\n\nclass Environment:\n    \"\"\"\n    Manages message history, routing and processed state.\n    \"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # per-message processing tracking: msg_id -> set(role.name)\n        self._processed: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        self._processed.setdefault(message.id, set()).add(role.name)\n        if self.tracer:\n            self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"Message {message.id} processed by {role.name}\")\n\n    def has_been_processed_by(self, message: Message, role: Role) -> bool:\n        return role.name in self._processed.get(message.id, set())\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        relevant: List[Message] = []\n        for msg in self.history:\n            # skip messages already processed by this role\n            if getattr(msg, \"id\", None) in getattr(role, \"_processed_message_ids\", set()):\n                continue\n            # skip messages role produced itself\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit addressing\n            send_to = getattr(msg, \"send_to\", None)\n            if send_to:\n                if isinstance(send_to, (set, list)) and (role.name in send_to or role.profile in send_to or \"*\" in send_to):\n                    relevant.append(msg)\n                    continue\n            sent_to_str = getattr(msg, \"sent_to\", None)\n            if isinstance(sent_to_str, str) and (sent_to_str == role.name or sent_to_str == role.profile or sent_to_str == \"*\"):\n                relevant.append(msg)\n                continue\n            # watch_list trigger\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n                continue\n        return relevant\n\n\nclass Team:\n    \"\"\"\n    Orchestrates roles, termination and verification handshake.\n    \"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self._verify_confirm_count = 0\n        self._verify_confirm_needed = VERIFY_CONFIRMATIONS_REQUIRED\n        self._verify_pass_rounds: Set[int] = set()\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; need {self._verify_confirm_needed} verifications to stop early\")\n        # initial user instruction targeted to coder(s)\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n\n        # deterministic order to reduce races\n        orchestration = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_idx in range(n_round):\n            round_num = round_idx + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num}/{n_round}\")\n            progress_made = False\n\n            for RoleClass in orchestration:\n                for role in [r for r in self.env.roles if isinstance(r, RoleClass)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # Ensure coder sees initial instruction on first round\n                    if isinstance(role, SimpleCoder) and round_idx == 0:\n                        msgs = [initial_msg] + [m for m in msgs if m.id != initial_msg.id]\n                    for msg in msgs:\n                        try:\n                            resp = await role.act(msg)\n                            # mark processed even on failures to avoid livelock\n                            self.env.mark_processed(msg, role)\n                            if resp:\n                                self.env.publish_message(resp)\n                                progress_made = True\n                                # verification handling\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    if \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                        self._verify_confirm_count += 1\n                                        self._verify_pass_rounds.add(round_idx)\n                                        self.tracer.log(\"VERIFY_CONFIRM\", \"Team\", f\"Verifier {role.name} PASS ({self._verify_confirm_count}/{self._verify_confirm_needed})\")\n                                        if self._verify_confirm_count >= self._verify_confirm_needed:\n                                            verified = True\n                                    elif \"VERIFICATION_RESULT: FAIL\" in resp.content:\n                                        self._verify_confirm_count = 0\n                                        self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Verifier {role.name} reported FAIL; confirmations reset\")\n                                # log role-produced errors\n                                if isinstance(resp.content, str) and resp.content.startswith(\"ROLE_FAILED\"):\n                                    self.tracer.log(\"ROLE_FAILURE\", \"Team\", resp.content[:200])\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {e}\")\n\n            # check progress\n            if len(self.env.history) == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num} complete progress={progress_made}\")\n\n            # Termination: require confirmations and at least one extra round of stability\n            if verified and round_num >= 1:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification confirmed ({self._verify_confirm_count}); stopping early\")\n                break\n\n            if no_progress_rounds >= NO_PROGRESS_GRACE:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating\")\n                break\n\n            # small cooperative pause\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        summary = f\"Project '{self.idea}' finished after {round_num} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (3.667)\n\n\n### Inspiration 4 (Score: 5.1774, Type: Migrant)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport random\nimport re\nfrom typing import Tuple, Any, Dict\n\n# Goals:\n# - Clear single-responsibility roles with explicit routing and watch logic.\n# - Robust LLM/API calls with retries and jitter.\n# - Deterministic verification with digest and stable consecutive PASS requirement.\n# - Simplified, readable orchestration and environment routing.\n# - Error-tolerant fallbacks that keep the pipeline moving.\n\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5\nROLE_MAX_ATTEMPTS = 2\nREQUIRED_STABLE_PASSES = 2\nNO_PROGRESS_LIMIT = 2  # consecutive rounds\n\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM wrapper and clear run contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Ask LLM with retries/backoff. Returns string or 'LLM_ERROR:<reason>'.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, \"LLM unavailable; returning deterministic error\")\n            return \"LLM_ERROR:unavailable\"\n\n        last_err = None\n        for attempt in range(1, LLM_MAX_RETRIES + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_MAX_RETRIES}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response\")\n                low = resp.strip().lower()\n                if low.startswith(\"error\") or \"error communicating\" in low:\n                    last_err = resp\n                    raise RuntimeError(\"Error response\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"len={len(resp)}\")\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:160]}\")\n                if attempt < LLM_MAX_RETRIES:\n                    backoff = LLM_BACKOFF_BASE * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.15)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Exhausted retries: {last_err}\")\n        return f\"LLM_ERROR:{last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return text output.\"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        if not idea or not idea.strip():\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Empty idea -> placeholder code\")\n            return (\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback placeholder implementation.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a single Python module implementing the task.\\n\"\n            \"Constraints:\\n- Only Python code (no backticks)\\n- Include docstrings and input validation\\n- Keep functions small and testable\\n\\n\"\n            f\"Task: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        code = await self._ask_llm(messages)\n        if code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM error -> deterministic fallback code\")\n            return (\n                f'\"\"\"Fallback implementation for: {idea[:200]}\"\"\"\\n\\n'\n                \"def placeholder(input_value=None):\\n\"\n                \"    \\\"\\\"\\\"Echo-like fallback for when code generation fails.\\\"\\\"\\\"\\n\"\n                \"    if input_value is None:\\n\"\n                \"        return None\\n\"\n                \"    return input_value\\n\"\n            )\n        # syntax validation\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, f\"Parse error: {e}\")\n            return (\n                f'\"\"\"Fallback due to parse error for: {idea[:200]}\"\"\"\\n\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback after parse error.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        if not code or not code.strip():\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"No code -> minimal test\")\n            return \"def test_placeholder():\\n    assert True\\n\"\n\n        # Extract top-level names for reference\n        names: List[str] = []\n        try:\n            tree = ast.parse(code)\n            for n in tree.body:\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\"):\n                    names.append(n.name)\n        except Exception:\n            names = []\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module.\\n\"\n            \"- Use def test_* functions and assert statements.\\n\"\n            \"- Cover typical and edge cases.\\n\"\n            \"- Return only test code.\\n\\n\"\n            f\"Public symbols: {', '.join(names[:8]) or '(none detected)'}\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:3000]}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        tests = await self._ask_llm(messages)\n        # validate tests\n        def _fallback_tests(target: str) -> str:\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{target}_sanity():\\n\"\n                \"    \\\"\\\"\\\"Fallback sanity test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n\n        if tests.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM error -> fallback tests\")\n            return _fallback_tests(names[0] if names else \"placeholder\")\n        try:\n            parsed = ast.parse(tests)\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed)) or (\"assert\" in (tests or \"\"))\n            if not (has_test_fn or has_assert):\n                raise ValueError(\"No tests/asserts found\")\n        except Exception:\n            if tracer:\n                tracer.log(\"ACTION_VALIDATION_FAIL\", self.name, \"Tests invalid -> fallback\")\n            return _fallback_tests(names[0] if names else \"placeholder\")\n\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        # Static checks\n        issues: List[str] = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:120]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:120]}\")\n\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"OK\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review.\\n\"\n            \"End with a single line: VERDICT: PASS or VERDICT: FAIL.\\n\\n\"\n            f\"Code:\\n{(code or '')[:1500]}\\n\\n\"\n            f\"Tests:\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues or 'none'}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        review = await self._ask_llm(messages)\n        if review.startswith(\"LLM_ERROR\") or not isinstance(review, str) or not review.strip():\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Review LLM error -> request change\")\n            return \"REQUEST_CHANGE: Automated reviewer failed. Please perform manual review.\\nVERDICT: FAIL\"\n        if \"VERDICT:\" not in review:\n            review = review.rstrip() + \"\\nVERDICT: FAIL\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Code syntax and public definitions\n        public_defs: Set[str] = set()\n        try:\n            code_tree = ast.parse(code or \"\")\n            public_defs = {n.name for n in ast.walk(code_tree) if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\")}\n            code_ok = True\n            diagnostics.append(f\"code_defs:{len(public_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:120]}\")\n\n        # Tests syntax and presence\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(tests_tree))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(tests_tree)) or (\"assert\" in (tests or \"\"))\n            tests_ok = bool(has_test_fn or has_assert)\n            diagnostics.append(\"tests_presence:ok\" if tests_ok else \"tests_presence:none\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:120]}\")\n\n        # Cross-reference: tests mention code symbols\n        try:\n            if public_defs and tests_ok:\n                name_refs = {n.id for n in ast.walk(ast.parse(tests or \"\")) if isinstance(n, ast.Name)}\n                referenced = bool(public_defs & name_refs)\n                diagnostics.append(\"tests_reference:ok\" if referenced else \"tests_reference:none\")\n            else:\n                diagnostics.append(\"tests_reference:skip\")\n        except Exception as e:\n            diagnostics.append(f\"reference_check_error:{str(e)[:120]}\")\n\n        verified = bool(code_ok and tests_ok and (referenced or not public_defs))\n\n        # Stable digest to confirm successive identical pass\n        try:\n            import hashlib\n            digest = hashlib.sha256(((code or \"\") + \"\\n--TESTS--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"\n    Base role with single-responsibility action, explicit watch/routing, and idempotent processing.\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # action names\n    env: Optional[\"Environment\"] = None\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self.env = kwargs.get(\"env\", None)\n        # Local processed to avoid repeated handling of same msg by a role instance\n        self._processed_message_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_respond(self, message: Message) -> bool:\n        \"\"\"Decide whether to respond based on explicit routing, watch triggers, and prior processing.\"\"\"\n        if not message:\n            return False\n        # Skip if we already processed this message\n        if getattr(message, \"id\", None) in self._processed_message_ids:\n            return False\n        # Skip self-authored\n        if getattr(message, \"sent_from\", None) == self.name:\n            return False\n        # Prefer explicit routing (send_to supports set/list or string)\n        targets = getattr(message, \"send_to\", None) or getattr(message, \"sent_to\", None)\n        if targets:\n            if isinstance(targets, (set, list)):\n                if self.name in targets or self.profile in targets or \"*\" in targets:\n                    return True\n            elif isinstance(targets, str):\n                if targets in (self.name, self.profile, \"*\"):\n                    return True\n            # if targets specified but not for us, don't respond\n            return False\n        # Watch-list by cause_by\n        if getattr(message, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # Default route: initial user input goes to coder\n        if getattr(message, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the single action for this role and produce a routed Message.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n\n        action = self.actions[0]\n        if message is not None and not self.should_respond(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skip msg id={getattr(message,'id',None)}\")\n            return None\n\n        attempts = 0\n        last_err = None\n        while attempts < ROLE_MAX_ATTEMPTS:\n            attempts += 1\n            try:\n                if isinstance(action, SimpleWriteCode):\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                    out = await action.run(idea)\n                    recipients = {\"SimpleTester\"}\n                elif isinstance(action, SimpleWriteTest):\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                    if not code_text and getattr(self, \"env\", None):\n                        # Find latest code artifact\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name:\n                                code_text = m.content\n                                break\n                    out = await action.run(code_text)\n                    recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                elif isinstance(action, SimpleWriteReview):\n                    code_text, tests_text = \"\", \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = {\"SimpleVerifier\", \"SimpleCoder\"} if \"REQUEST_CHANGE\" in (out or \"\").upper() else {\"SimpleVerifier\"}\n                elif isinstance(action, SimpleVerify):\n                    code_text, tests_text = \"\", \"\"\n                    if getattr(self, \"env\", None):\n                        for m in reversed(self.env.history):\n                            if m.cause_by == SimpleWriteCode.name and not code_text:\n                                code_text = m.content\n                            if m.cause_by == SimpleWriteTest.name and not tests_text:\n                                tests_text = m.content\n                            if code_text and tests_text:\n                                break\n                    out = await action.run(code_text, tests_text)\n                    recipients = set()  # broadcast semantics\n                else:\n                    out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                    recipients = set()\n\n                # mark input as processed\n                if message and getattr(message, \"id\", None):\n                    self._processed_message_ids.add(message.id)\n\n                response = Message(\n                    content=out,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=recipients\n                )\n                if tracer:\n                    tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg cause_by={response.cause_by} send_to={recipients}\")\n                return response\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"ROLE_ERROR\", self.name, f\"Attempt {attempts} failed: {last_err[:160]}\")\n                await asyncio.sleep(0.05 * attempts)\n\n        # Exhausted attempts -> return failure message\n        failure = f\"ROLE_FAILED: {self.name} after {ROLE_MAX_ATTEMPTS} attempts - {last_err}\"\n        if tracer:\n            tracer.log(\"ROLE_FAIL\", self.name, failure)\n        return Message(\n            content=failure,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"Unknown\"),\n            sent_from=self.name,\n            send_to={\"Team\"}\n        )\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview])\n\n\nclass Environment:\n    \"\"\"\n    Message bus with routing and per-role processed tracking.\n    - history: ordered messages\n    - _processed: msg_id -> set(role.name) to avoid duplicate handling\n    \"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        self._processed: Dict[str, Set[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        self._processed.setdefault(message.id, set())\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"from={message.sent_from} cause_by={message.cause_by} send_to={getattr(message,'send_to',None)} preview={preview}\")\n\n    def mark_processed(self, message: Message, role: Role):\n        if getattr(message, \"id\", None):\n            self._processed.setdefault(message.id, set()).add(role.name)\n            if self.tracer:\n                self.tracer.log(\"ENV_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_been_processed_by(self, message: Message, role: Role) -> bool:\n        return role.name in self._processed.get(getattr(message, \"id\", \"\"), set())\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Relevant messages for role: explicit routing first, then watch triggers. Skip processed/self-authored.\"\"\"\n        relevant: List[Message] = []\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if not mid:\n                continue\n            if self.has_been_processed_by(msg, role):\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit addressing\n            send_to = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None)\n            matched = False\n            if send_to:\n                if isinstance(send_to, (set, list)) and (role.name in send_to or role.profile in send_to or \"*\" in send_to):\n                    relevant.append(msg)\n                    matched = True\n                elif isinstance(send_to, str) and send_to in (role.name, role.profile, \"*\"):\n                    relevant.append(msg)\n                    matched = True\n                if matched:\n                    continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n        return relevant\n\n\nclass Team:\n    \"\"\"\n    Orchestrates roles with deterministic ordering and stable verification-based termination.\n    - Requires REQUIRED_STABLE_PASSES consecutive PASS with the same digest.\n    - Nudges coder on stalls before terminating for no progress.\n    \"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self._last_digest: Optional[str] = None\n        self._pass_streak: int = 0\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Run up to {n_round} rounds; require {REQUIRED_STABLE_PASSES} stable passes\")\n        # Initial user instruction to coder(s)\n        initial = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial)\n\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        no_progress_rounds = 0\n        last_history_len = len(self.env.history)\n        rounds_ran = 0\n\n        for r in range(n_round):\n            rounds_ran = r + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rounds_ran}/{n_round}\")\n            progress = False\n\n            for RoleClass in order:\n                for role in [ro for ro in self.env.roles if isinstance(ro, RoleClass)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # Guarantee coder sees initial message in first round\n                    if isinstance(role, SimpleCoder) and r == 0 and initial not in msgs:\n                        msgs = [initial] + msgs\n                    for msg in msgs:\n                        try:\n                            resp = await role.act(msg)\n                            # mark processed regardless of result to avoid loops\n                            self.env.mark_processed(msg, role)\n                            if resp:\n                                self.env.publish_message(resp)\n                                progress = True\n                                # verification tracking\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    content = resp.content\n                                    if \"VERIFICATION_RESULT: PASS\" in content:\n                                        # extract digest if present\n                                        digest = None\n                                        for part in content.split(\"|\"):\n                                            p = part.strip()\n                                            if p.startswith(\"digest=\"):\n                                                digest = p.split(\"=\", 1)[1]\n                                                break\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._pass_streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._pass_streak = 1\n                                            self.tracer.log(\"VERIFY_PASS\", \"Team\", f\"digest={digest} streak={self._pass_streak}\")\n                                        else:\n                                            # pass without digest counts as 1 but cannot be stable across rounds\n                                            self._last_digest = None\n                                            self._pass_streak = 1\n                                    elif \"VERIFICATION_RESULT: FAIL\" in content:\n                                        if self._pass_streak > 0:\n                                            self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Reset streak {self._pass_streak}->0 due to FAIL\")\n                                        self._pass_streak = 0\n                                        self._last_digest = None\n                            # note role failures\n                            if resp and isinstance(resp.content, str) and resp.content.startswith(\"ROLE_FAILED\"):\n                                self.tracer.log(\"TEAM_NOTE\", \"Team\", f\"{resp.content[:160]}\")\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {type(e).__name__}: {str(e)[:160]}\")\n\n            # Termination and stall handling\n            current_len = len(self.env.history)\n            if current_len == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = current_len\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"progress={progress} streak={self._pass_streak} history={len(self.env.history)}\")\n\n            # Verified if stable streak achieved\n            if self._pass_streak >= REQUIRED_STABLE_PASSES:\n                self.tracer.log(\"TEAM_VERIFIED\", \"Team\", f\"Stable verification streak={self._pass_streak}; stopping\")\n                break\n\n            # Nudge coder on first stall, then terminate if persists\n            if no_progress_rounds == 1:\n                nudge = Message(\n                    content=f\"Please refine or improve the implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n            elif no_progress_rounds >= NO_PROGRESS_LIMIT:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; stopping\")\n                break\n\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project run finished\")\n        verified = self._pass_streak >= REQUIRED_STABLE_PASSES\n        summary = f\"Project '{self.idea}' finished after {rounds_ran} rounds with {len(self.env.history)} messages. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (3.333)\n\n\n### Inspiration 5 (Score: 6.3368, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# Evolved multi-agent logic to reduce failure modes (MAST-focused)\n# Focus:\n# - Clear role responsibilities & single-action roles\n# - Robust inter-agent communication: explicit send_to routing and watch/trigger logic\n# - Deterministic orchestration and idempotent processing\n# - Strong verification & validation (syntax, tests presence, cross-reference)\n# - LLM/API error handling with retries/backoff and deterministic fallbacks\n# - Stable termination: require consecutive verified passes and confirmation\n\nimport asyncio\nimport ast\nimport hashlib\nimport random\nimport time\nfrom typing import Tuple\n\n# ----------------------\n# Action implementations\n# ----------------------\n\nclass Action(ABC):\n    \"\"\"Base action with LLM-safe call and deterministic fallback behavior.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 0.5\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def safe_ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM.ask with retries, exponential backoff and jitter. Return deterministic error tag on failure.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            fallback = \"LLM_UNAVAILABLE\"\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n            return fallback\n\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response\")\n                # detect LLMInterface error wrappers\n                if resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower():\n                    last_err = resp\n                    raise RuntimeError(f\"LLM returned error-like text: {resp[:200]}\")\n                if tracer:\n                    tracer.log(\"LLM_OK\", self.name, f\"Received len={len(resp)}\")\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                # backoff + jitter\n                if attempt < self.max_retries:\n                    backoff = self.base_backoff * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.1)\n                    await asyncio.sleep(backoff + jitter)\n        # exhausted\n        final = f\"LLM_FAILED: {last_err or 'unknown'}\"\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    def deterministic_fallback(self, idea: str) -> str:\n        return (\n            '\"\"\"Deterministic fallback implementation.\"\"\"\\n'\n            \"from typing import Any\\n\\n\"\n            \"def placeholder(value: Any = None) -> Any:\\n\"\n            \"    \\\"\\\"\\\"Fallback placeholder that returns input or raises on None.\\\"\\\"\\\"\\n\"\n            \"    if value is None:\\n\"\n            \"        raise ValueError('value cannot be None')\\n\"\n            \"    return value\\n\"\n        )\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(idea or '')}\")\n        prompt = (\n            \"You are an expert Python developer. Produce a concise, production-ready Python module implementing the task.\\n\"\n            \"Requirements: include docstrings, input validation, clear small functions, and no surrounding markdown.\\n\\n\"\n            f\"Task: {idea}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        resp = await self.safe_ask(messages)\n        # Validate parseable Python\n        valid = False\n        if isinstance(resp, str) and not resp.startswith(\"LLM_\") and not resp.strip().lower().startswith(\"error\"):\n            try:\n                ast.parse(resp)\n                valid = True\n            except Exception as e:\n                if tracer:\n                    tracer.log(\"ACTION_VALIDATE_FAIL\", self.name, f\"AST parse error: {e}\")\n        if not valid:\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using deterministic fallback code\")\n            return self.deterministic_fallback(idea or \"\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(resp)}\")\n        return resp\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    def deterministic_fallback(self, code: str) -> str:\n        # extract probable symbol\n        symbol = \"placeholder\"\n        try:\n            tree = ast.parse(code or \"\")\n            for node in tree.body:\n                if isinstance(node, ast.FunctionDef) and not node.name.startswith(\"_\"):\n                    symbol = node.name\n                    break\n                if isinstance(node, ast.ClassDef) and not node.name.startswith(\"_\"):\n                    symbol = node.name\n                    break\n        except Exception:\n            pass\n        return (\n            \"import pytest\\n\\n\"\n            f\"def test_{symbol}_exists():\\n\"\n            f\"    \\\"\\\"\\\"Fallback: ensure '{symbol}' exists or tests pipeline keeps moving.\\\"\\\"\\\"\\n\"\n            f\"    assert True\\n\"\n        )\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code or '')}\")\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided Python module. Include docstrings and assert statements.\\n\\n\"\n            f\"Module (truncated):\\n{(code or '')[:3000]}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        resp = await self.safe_ask(messages)\n        # Validate presence of assert or test_ functions\n        valid = False\n        if isinstance(resp, str) and not resp.startswith(\"LLM_\") and not resp.strip().lower().startswith(\"error\"):\n            try:\n                parsed = ast.parse(resp)\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed))\n                if has_test_fn or has_assert:\n                    valid = True\n            except Exception:\n                valid = False\n        if not valid:\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"Using deterministic fallback tests\")\n            return self.deterministic_fallback(code or \"\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(resp)}\")\n        return resp\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if self.is_human:\n            out = \"HUMAN_REVIEW: Please inspect code and tests manually. REVIEW_DECISION: REQUEST_CHANGES\"\n            if tracer:\n                tracer.log(\"ACTION_HUMAN\", self.name, \"Simulated human review\")\n            return out\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Running automated review\")\n        prompt = (\n            \"You are a senior reviewer. Provide a concise review and end with one line 'REVIEW_DECISION: APPROVE' or 'REVIEW_DECISION: REQUEST_CHANGES'.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:2000]}\\n\\nTests (truncated):\\n{(tests or '')[:2000]}\\n\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        resp = await self.safe_ask(messages)\n        if not isinstance(resp, str) or \"REVIEW_DECISION:\" not in resp:\n            # infer decision heuristically\n            decision = \"APPROVE\" if (\"assert\" in (tests or \"\")) and ((\"def \" in (code or \"\")) or (\"class \" in (code or \"\"))) else \"REQUEST_CHANGES\"\n            resp = (resp or \"Automated review.\") + f\"\\n\\nREVIEW_DECISION: {decision}\"\n            if tracer:\n                tracer.log(\"ACTION_WARN\", self.name, f\"Inferred decision {decision}\")\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(resp)}\")\n        return resp\n\nclass SimpleVerify(Action):\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        details: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Code syntax\n        try:\n            parsed_code = ast.parse(code or \"\")\n            code_ok = True if (code and code.strip()) else False\n            details.append(\"code_syntax: ok\")\n        except Exception as e:\n            details.append(f\"code_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n            parsed_code = None\n\n        # Tests syntax and presence\n        try:\n            parsed_tests = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n            tests_ok = bool(has_test_fn or has_assert)\n            if tests_ok:\n                details.append(\"tests_syntax_and_presence: ok\")\n            else:\n                details.append(\"tests_syntax: ok_but_no_tests_found\")\n        except Exception as e:\n            details.append(f\"tests_syntax: fail ({type(e).__name__}: {str(e)[:160]})\")\n            parsed_tests = None\n\n        # Cross-reference: tests reference code symbols\n        if parsed_code and parsed_tests:\n            defs = {n.name for n in parsed_code.body if isinstance(n, (ast.FunctionDef, ast.ClassDef))}\n            tests_text = tests or \"\"\n            if defs:\n                for name in defs:\n                    if name and name in tests_text:\n                        referenced = True\n                        break\n                if referenced:\n                    details.append(\"tests_reference_code: ok\")\n                else:\n                    details.append(\"tests_reference_code: fail\")\n            else:\n                details.append(\"tests_reference_code: warn (no top-level defs)\")\n\n        verified = code_ok and tests_ok and referenced\n        # compute digest of artifacts for stability detection\n        digest = hashlib.sha256(((code or \"\") + \"\\n--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(details)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n# ----------------------\n# Role definitions\n# ----------------------\n\nclass Role(ABC):\n    \"\"\"Base role: single responsibility, processed-tracking and explicit routing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    env: Optional[\"Environment\"] = None\n    actions: List[Action] = []\n    watch_list: Set[str] = set()  # action names to watch\n    is_human: bool = False\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = set()\n        self.env = kwargs.get(\"env\", None)\n        # track message ids processed for idempotency\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = {a.name for a in actions}\n\n    def should_handle(self, msg: Message) -> bool:\n        \"\"\"Decide whether to handle a message:\n        - not produced by self\n        - not already processed\n        - explicitly routed via send_to\n        - or cause_by in watch_list\n        \"\"\"\n        if msg is None:\n            return False\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        mid = getattr(msg, \"id\", None)\n        if mid and mid in self._processed_ids:\n            return False\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n        try:\n            if send_to and (self.name in send_to or self.profile in send_to or \"*\" in send_to):\n                return True\n        except Exception:\n            pass\n        if getattr(msg, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: user input to coder(s)\n        if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute single primary action and return Message with explicit routing (send_to).\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        tracer = getattr(self.context, \"tracer\", None)\n        if message and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skipping msg={getattr(message,'id',None)}\")\n            return None\n        if tracer:\n            tracer.log(\"ROLE_ACT\", self.name, f\"Executing action={action.name} on msg={getattr(message,'id',None)}\")\n        try:\n            if isinstance(action, SimpleWriteCode):\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                out = await action.run(idea)\n                send_to = {\"SimpleTester\"}\n                # if LLM failed, route back for retry\n                if isinstance(out, str) and (out.startswith(\"LLM_\") or out.startswith(\"Error\") or out.startswith(\"LLM_FAILED\")):\n                    send_to = {self.name}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif isinstance(action, SimpleWriteTest):\n                # prefer code in message; else lookup latest\n                code_text = getattr(message, \"content\", \"\") if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name else \"\"\n                if not code_text and self.env:\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                out = await action.run(code_text)\n                send_to = {\"SimpleReviewer\", \"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif isinstance(action, SimpleWriteReview):\n                # gather latest code/tests\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                lowered = (out or \"\").lower()\n                if \"request\" in lowered or \"reject\" in lowered or \"request_changes\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            elif isinstance(action, SimpleVerify):\n                code_msg = self.env.get_latest_artifact([SimpleWriteCode.name]) if self.env else None\n                tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name]) if self.env else None\n                code_text = code_msg.content if code_msg else \"\"\n                tests_text = tests_msg.content if tests_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # broadcast verification to all roles for trace\n                send_to = set(r.profile for r in (self.env.roles if self.env else []))\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=send_to)\n            else:\n                out = await action.run()\n                response = Message(content=out, role=self.profile, cause_by=action.name, sent_from=self.name, send_to=set())\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {type(e).__name__}: {str(e)[:200]}\"\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(content=err, role=self.profile, cause_by=\"RoleException\", sent_from=self.name, send_to={\"SimpleCoder\"})\n\n        # mark processed\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # avoid reprocessing own produced message\n        try:\n            if getattr(response, \"id\", None):\n                self._processed_ids.add(response.id)\n        except Exception:\n            pass\n\n        if tracer:\n            tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={getattr(response,'id',None)} send_to={getattr(response,'send_to',set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])  # proactive: respond to UserInput or explicit addressing\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\n# ----------------------\n# Environment & Team\n# ----------------------\n\nclass Environment:\n    \"\"\"Message store and deterministic routing with per-role delivery tracking.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered: role.name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n        # index by cause_by for quick artifact lookup\n        self._index_by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to is set type\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        # ensure id exists\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        cb = getattr(message, \"cause_by\", \"\")\n        if cb:\n            self._index_by_cause.setdefault(cb, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={cb} -> {list(message.send_to)} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to role and relevant by explicit routing or watch_list.\"\"\"\n        out: List[Message] = []\n        seen = self._delivered.setdefault(role.name, set())\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if mid is None or mid in seen:\n                continue\n            # skip own messages\n            if getattr(msg, \"sent_from\", None) == role.name:\n                seen.add(mid)\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            targeted = False\n            try:\n                if send_to and (role.name in send_to or role.profile in send_to or \"*\" in send_to):\n                    targeted = True\n            except Exception:\n                targeted = False\n            if targeted:\n                out.append(msg)\n                seen.add(mid)\n                continue\n            # watch-list trigger\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n                seen.add(mid)\n                continue\n            # default: UserInput -> coder(s)\n            if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in role.profile:\n                out.append(msg)\n                seen.add(mid)\n                continue\n        return out\n\n    def get_latest_artifact(self, cause_names: List[str]) -> Optional[Message]:\n        for name in cause_names:\n            msgs = self._index_by_cause.get(name, [])\n            if msgs:\n                return msgs[-1]\n        return None\n\nclass Team:\n    \"\"\"Orchestrator with deterministic order, verification stability checks, error handling and nudges.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        # verification stability\n        self._last_digest: Optional[str] = None\n        self._streak: int = 0\n        self._required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            r.context = self.context\n            r.env = self.env\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _confirm_verification(self) -> bool:\n        \"\"\"Run deterministic local verifier to confirm PASS (reduce false positives).\"\"\"\n        verifier = SimpleVerify(context=self.context)\n        code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n        tests_msg = self.env.get_latest_artifact([SimpleWriteTest.name])\n        code = code_msg.content if code_msg else \"\"\n        tests = tests_msg.content if tests_msg else \"\"\n        result = await verifier.run(code, tests)\n        return isinstance(result, str) and \"VERIFICATION_RESULT: PASS\" in result\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; require {self._required_stable_passes} stable passes\")\n        # initial user message targeted at coder profile and name(s)\n        coder_profiles = {r.profile for r in self.env.roles if isinstance(r, SimpleCoder)} or {\"SimpleCoder\"}\n        initial = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=coder_profiles\n        )\n        self.env.publish_message(initial)\n\n        for round_idx in range(1, n_round + 1):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_idx}/{n_round}\")\n            progress = False\n\n            # deterministic order\n            for role_cls in (SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier):\n                for role in [r for r in self.env.roles if isinstance(r, role_cls)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # on first round, ensure coder sees the initial instruction\n                    if isinstance(role, SimpleCoder) and round_idx == 1:\n                        msgs = [initial] + [m for m in msgs if m.id != initial.id]\n                    for m in msgs:\n                        try:\n                            resp = await role.act(m)\n                            # mark delivered already occurred in get_messages_for_role; resp may be None\n                            if resp:\n                                self.env.publish_message(resp)\n                                progress = True\n                                # if verifier produced PASS: confirm & update streak\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str) and \"VERIFICATION_RESULT: PASS\" in resp.content:\n                                    confirmed = await self._confirm_verification()\n                                    if confirmed:\n                                        # parse digest\n                                        digest = None\n                                        for part in resp.content.split(\"|\"):\n                                            p = part.strip()\n                                            if p.startswith(\"digest=\"):\n                                                digest = p.split(\"=\", 1)[1]\n                                                break\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._streak = 1\n                                            self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"digest={digest} streak={self._streak}\")\n                                            if self._streak >= self._required_stable_passes:\n                                                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self._streak} passes; stopping\")\n                                                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed early due to verification stability\")\n                                                summary = f\"Project '{self.idea}' completed after {round_idx} rounds with {len(self.env.history)} messages. Verified=True\"\n                                                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n                                                return\n                                        else:\n                                            # treat as single pass but not stable\n                                            self._streak = 1\n                                            self._last_digest = None\n                                    else:\n                                        # confirmation failed, reset streak\n                                        self._streak = 0\n                                        self._last_digest = None\n                                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", \"Confirmation failed; reset streak\")\n\n                                elif isinstance(role, SimpleVerifier):\n                                    # explicit fail resets streak\n                                    self._streak = 0\n                                    self._last_digest = None\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Exception processing message {getattr(m,'id',None)}: {type(e).__name__}: {str(e)[:200]}\")\n                            # publish an error marker to environment to make failure visible\n                            err_msg = Message(content=f\"ERROR: role {role.name} crashed: {type(e).__name__}\", role=role.profile, cause_by=\"RoleCrash\", sent_from=role.name, send_to=set())\n                            self.env.publish_message(err_msg)\n                            progress = True\n\n            # if no progress, nudge coder(s) to avoid deadlock but avoid spamming\n            if not progress:\n                self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", \"No progress this round; nudging coder(s)\")\n                for coder in [r for r in self.env.roles if isinstance(r, SimpleCoder)]:\n                    nudge = Message(content=f\"Nudge: please propose or refine implementation for: {self.idea}\", instruct_content=self.idea, role=\"System\", sent_from=\"Orchestrator\", cause_by=\"Nudge\", send_to={coder.name, coder.profile})\n                    self.env.publish_message(nudge)\n                # allow coders to process nudge quickly in same round\n                await asyncio.sleep(0.01)\n                # if still no progress next rounds, team will stop after n_round\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_idx} completed; progress={progress}; verifier_streak={self._streak}\")\n\n        # finish\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed (max rounds reached)\")\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages. Verified={self._streak >= self._required_stable_passes}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative combined_score approach, Excellent avg_failures_per_task (4.333)\n\n\n\n# Current Program\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\nfrom typing import Tuple\n\n# Evolution goals:\n# - Clear role responsibilities\n# - Robust inter-agent communication with explicit routing (send_to) and watch/trigger logic\n# - Deterministic orchestration and processed-tracking to avoid duplicate processing\n# - Strong verification with syntactic and structural checks\n# - Error handling and retry for LLM/API failures\n# - Stable termination: require consecutive verification passes before stopping early\n\nclass Action(ABC):\n    \"\"\"Base action class with LLM retry handling and standardized contract.\n\n    Responsibilities:\n    - Provide run(...) coroutine returning a text result.\n    - Manage LLM calls with retries/backoff and robust error detection.\n    \"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    base_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        try:\n            if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def _ask_with_retry(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call the LLM with retries and exponential backoff. Returns a string (or clear error).\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{self.max_retries}\")\n                if not self.llm:\n                    # deterministic fallback to avoid transient dependency failure\n                    fallback = \"LLM_UNAVAILABLE: fallback response\"\n                    if self.context and self.context.tracer:\n                        self.context.tracer.log(\"LLM_FALLBACK\", self.name, fallback)\n                    return fallback\n                resp = await self.llm.ask(messages)\n                # treat responses beginning with \"Error\" as failure\n                if isinstance(resp, str) and resp.strip().lower().startswith(\"error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_ERROR\", self.name, f\"Attempt {attempt} failed: {last_err}\")\n                # backoff before next attempt\n                await asyncio.sleep(self.base_backoff * (2 ** (attempt - 1)))\n        # exhausted retries\n        final = f\"LLM_FAILED_AFTER_RETRIES: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FINAL_FAILURE\", self.name, final)\n        return final\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an initial implementation from an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Idea len={len(idea or '')}\")\n        prompt = (\n            \"You are a professional Python developer. Produce a compact, production-ready Python implementation \"\n            \"for the described task. Include docstrings, input validation, and error handling. \"\n            \"Return only the Python source code.\"\n            f\"\\n\\nTask: {idea}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated len={len(result)}\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for a given code snippet.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Code len={len(code or '')}\")\n        snippet = (code or \"\")[:4000]\n        prompt = (\n            \"You are a QA engineer. Given the implementation below, produce pytest tests that cover normal behavior, \"\n            \"edge cases, and error conditions. Use clear test names and docstrings. Return only pytest code.\\n\\n\"\n            f\"Implementation:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._ask_with_retry(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Tests len={len(result)}\")\n        return result\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce actionable items.\"\"\"\n\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Human={self.is_human}\")\n        # Static checks\n        issues = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error: {str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error: {str(e)[:160]}\")\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"ok\")\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise, structured review (VERDICT: PASS/FAIL) and actionable items. \"\n                \"Include any static issues found.\\n\\n\"\n                f\"Code:\\n{(code or '')[:2000]}\\n\\nTests:\\n{(tests or '')[:2000]}\\n\\n\"\n                f\"STATIC_ISSUES: {issues}\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            llm_resp = await self._ask_with_retry(messages)\n            # fall back to static-only if llm failed\n            if isinstance(llm_resp, str) and llm_resp.startswith(\"LLM_FAILED_AFTER_RETRIES\"):\n                review = \"REVIEW_FAIL: \" + \"; \".join(issues) if issues else \"REVIEW_PASS: minimal\"\n            else:\n                review = llm_resp\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review len={len(review)}\")\n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Perform strong verification: syntax, tests presence, assertions, and references.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code/tests\")\n        status = []\n        code_ok = False\n        tests_ok = False\n        references_ok = False\n\n        # Check code syntax\n        if not code or not code.strip():\n            status.append(\"code: empty\")\n        else:\n            try:\n                parsed_code = ast.parse(code)\n                code_ok = True\n                status.append(\"code_syntax: ok\")\n            except Exception as e:\n                status.append(f\"code_syntax: fail ({str(e)[:160]})\")\n                parsed_code = None\n\n        # Check tests syntax and assertions\n        if not tests or not tests.strip():\n            status.append(\"tests: empty\")\n        else:\n            try:\n                parsed_tests = ast.parse(tests)\n                # heuristic: look for pytest functions or assert statements\n                has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed_tests))\n                has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed_tests))\n                if has_test_fn or has_assert:\n                    tests_ok = True\n                    status.append(\"tests_syntax_and_asserts: ok\")\n                else:\n                    status.append(\"tests_syntax: ok_but_no_tests_found\")\n                parsed_tests = parsed_tests\n            except Exception as e:\n                status.append(f\"tests_syntax: fail ({str(e)[:160]})\")\n                parsed_tests = None\n\n        # Check tests reference functions in code\n        if code_ok and tests_ok and parsed_code and parsed_tests:\n            func_names = {n.name for n in ast.walk(parsed_code) if isinstance(n, ast.FunctionDef)}\n            tests_text = tests or \"\"\n            if func_names:\n                for fn in func_names:\n                    if fn in tests_text:\n                        references_ok = True\n                        break\n                if references_ok:\n                    status.append(\"tests_reference_functions: ok\")\n                else:\n                    status.append(\"tests_reference_functions: fail (no references)\")\n            else:\n                status.append(\"tests_reference_functions: warn (no top-level functions in code)\")\n\n        verified = code_ok and tests_ok and references_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role with clear responsibilities and processed-tracking to avoid duplicates.\n\n    Responsibilities:\n    - Decide whether to handle a message (match send_to or watch_list)\n    - Execute its single main action and produce a Message with routing metadata (send_to)\n    \"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.env: Optional[\"Environment\"] = None\n        # track processed (message ids) per role to avoid reprocessing\n        self._processed_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        # store names for robust matching\n        self.watch_list = [a.name for a in actions]\n\n    def _should_handle(self, msg: Message) -> bool:\n        # never handle messages produced by self or already processed\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        if getattr(msg, \"id\", None) in self._processed_ids:\n            return False\n        # explicit routing\n        send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", None) or set())\n        if send_to:\n            if self.profile in send_to or self.name in send_to:\n                return True\n            return False\n        # watch-list matching by cause_by\n        if getattr(msg, \"cause_by\", None) in self.watch_list:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        # if message provided but not intended for this role, skip\n        if message and not self._should_handle(message):\n            return None\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Handling msg={getattr(message, 'id', 'none')} cause_by={getattr(message, 'cause_by', '')}\")\n        try:\n            # Dispatch by action name (explicit)\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or (message.content or \"\")\n                result_text = await action.run(idea)\n                # route to tester primarily, and reviewer optionally\n                send_to = {\"SimpleTester\"}\n                if \"ERROR\" in result_text or result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"LLM_UNAVAILABLE\"):\n                    # if generation failed, route back to coder (self) for retry later and to reviewer for context\n                    send_to = {self.profile}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteTest.name:\n                # expect code text in message.content, otherwise look up latest code in env\n                code_text = \"\"\n                if message and message.content:\n                    code_text = message.content\n                elif self.env:\n                    # find most recent code message\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name:\n                            code_text = m.content\n                            break\n                result_text = await action.run(code_text)\n                send_to = {\"SimpleReviewer\"}\n                if result_text.startswith(\"LLM_FAILED\") or result_text.startswith(\"ERROR\"):\n                    send_to = {\"SimpleTester\", \"SimpleCoder\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleWriteReview.name:\n                # collect latest code and tests from env\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # If review indicates issues, route back to coder/tester; else route to verifier\n                lowered = (result_text or \"\").lower()\n                if \"fail\" in lowered or \"error\" in lowered or \"syntax\" in lowered:\n                    send_to = {\"SimpleCoder\", \"SimpleTester\"}\n                else:\n                    send_to = {\"SimpleVerifier\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            elif action.name == SimpleVerify.name:\n                # collect latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    for m in reversed(self.env.history):\n                        if m.cause_by == SimpleWriteCode.name and not code_text:\n                            code_text = m.content\n                        if m.cause_by == SimpleWriteTest.name and not tests_text:\n                            tests_text = m.content\n                        if code_text and tests_text:\n                            break\n                result_text = await action.run(code_text, tests_text)\n                # verification is terminal but still broadcast to reviewer and coder for trace\n                send_to = {\"SimpleReviewer\", \"SimpleCoder\", \"SimpleTester\"}\n                response = Message(\n                    content=result_text,\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name,\n                    send_to=send_to\n                )\n            else:\n                response = Message(\n                    content=\"NO_OP\",\n                    role=self.profile,\n                    cause_by=action.name,\n                    sent_from=self.name\n                )\n        except Exception as e:\n            err = f\"ROLE_EXCEPTION: {str(e)}\"\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_EXCEPTION\", self.name, err)\n            response = Message(\n                content=err,\n                role=self.profile,\n                cause_by=\"RoleException\",\n                sent_from=self.name,\n                send_to={\"SimpleCoder\"}\n            )\n\n        # mark input message as processed for this role to avoid duplicate processing\n        if message and getattr(message, \"id\", None):\n            self._processed_ids.add(message.id)\n        # also mark produced message id as processed locally to avoid reprocessing self-produced messages\n        if getattr(response, \"id\", None):\n            self._processed_ids.add(response.id)\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={getattr(response, 'send_to', set())}\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteCode])\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\nclass Environment:\n    \"\"\"Tracks roles, history and ensures idempotent processing via processed set.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # processed pairs of (role_name, msg_id)\n        self.processed: Set[Tuple[str, str]] = set()\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # ensure send_to exists as set for compatibility\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        self.history.append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:140].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def mark_processed(self, role: Role, message: Message):\n        if getattr(message, \"id\", None):\n            self.processed.add((role.name, message.id))\n            if self.tracer:\n                self.tracer.log(\"ENV_MARK_PROCESSED\", \"Environment\", f\"{role.name} processed {message.id}\")\n\n    def has_processed(self, role: Role, message: Message) -> bool:\n        if not getattr(message, \"id\", None):\n            return False\n        return (role.name, message.id) in self.processed\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages relevant to the role (explicit routing or watch_list).\"\"\"\n        out: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"id\", None) is None:\n                continue\n            if (role.name, msg.id) in self.processed:\n                continue\n            if getattr(msg, \"sent_from\", None) == role.name:\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or set(getattr(msg, \"sent_to\", set()) or set())\n            if send_to:\n                if role.profile in send_to or role.name in send_to:\n                    out.append(msg)\n                    continue\n            # watch-list\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                out.append(msg)\n        # maintain chronological order\n        return out\n\nclass Team:\n    \"\"\"Orchestrates multi-agent collaboration with deterministic ordering, retries, and stable verification.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability tracking\n        self.verifier_streak: int = 0\n        self.required_stable_passes: int = 2\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def _process_role_messages(self, role: Role):\n        msgs = self.env.get_messages_for_role(role)\n        if not msgs:\n            # allow role to act proactively (e.g., coder on initial round) if there is no directed message\n            # but guard against spamming by checking recent history\n            proactive_msg = None\n            # coder proactive behavior is controlled from the orchestrator\n            return\n        for m in msgs:\n            # call role\n            resp = await role.act(m)\n            # mark processed whether or not action succeeded to avoid infinite loops\n            self.env.mark_processed(role, m)\n            if resp:\n                self.env.publish_message(resp)\n                # if verifier produced PASS, update streak\n                if isinstance(role, SimpleVerifier) and \"VERIFICATION_RESULT: PASS\" in (resp.content or \"\"):\n                    self.verifier_streak += 1\n                    self.tracer.log(\"VERIFIER_STREAK\", \"Team\", f\"streak={self.verifier_streak}\")\n                elif isinstance(role, SimpleVerifier):\n                    # reset on non-pass\n                    if self.verifier_streak > 0:\n                        self.tracer.log(\"VERIFIER_RESET\", \"Team\", f\"resetting streak {self.verifier_streak}->0\")\n                    self.verifier_streak = 0\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds (stable_passes={self.required_stable_passes})\")\n        # initial message targeted at coder\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num+1}/{n_round}\")\n            # For each role in order, process relevant messages\n            for role_cls in order:\n                roles = [r for r in self.env.roles if isinstance(r, role_cls)]\n                for role in roles:\n                    # special-case: allow proactive coder run on first round if not yet produced code\n                    if isinstance(role, SimpleCoder) and round_num == 0:\n                        # check if coder has processed the initial user message\n                        user_msgs = [m for m in self.env.history if getattr(m, \"cause_by\", \"\") == \"UserInput\"]\n                        need_init = False\n                        for um in user_msgs:\n                            if not self.env.has_processed(role, um):\n                                need_init = True\n                                break\n                        if need_init:\n                            await self._process_role_messages(role)\n                            # continue to next role\n                            continue\n                    await self._process_role_messages(role)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num+1} completed; verifier_streak={self.verifier_streak}; history_len={len(self.env.history)}\")\n\n            # termination: require 'required_stable_passes' consecutive PASS results\n            if self.verifier_streak >= self.required_stable_passes:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification stable for {self.verifier_streak} passes; stopping\")\n                break\n\n            # If no messages were produced in this round (no progress), nudge coder proactively once per stalled round\n            # Determine whether new messages were added this round by looking at history length changes is complex here;\n            # simpler heuristic: if the last messages are not tests/verifier/reviewer, nudge coder.\n            last_msgs = self.env.history[-4:] if len(self.env.history) >= 4 else self.env.history[:]\n            if not any((m.cause_by == SimpleWriteTest.name or m.cause_by == SimpleWriteCode.name or m.cause_by == SimpleWriteReview.name) for m in last_msgs):\n                # send a gentle nudge to coder to refine\n                nudge = Message(\n                    content=f\"Please refine and re-run implementation for: {self.idea}\",\n                    instruct_content=self.idea,\n                    role=\"System\",\n                    sent_from=\"Orchestrator\",\n                    cause_by=\"Nudge\",\n                    send_to={\"SimpleCoder\"}\n                )\n                self.env.publish_message(nudge)\n                # process coder nudge immediately\n                coder_roles = [r for r in self.env.roles if isinstance(r, SimpleCoder)]\n                for coder in coder_roles:\n                    await self._process_role_messages(coder)\n\n        # finalization: log summary\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num+1} rounds with {len(self.env.history)} messages. verifier_streak={self.verifier_streak}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"LLM_UNAVAILABLE_FALLBACK: deterministic placeholder response\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport ast\nimport hashlib\nimport random\nfrom typing import Tuple, Iterable\n\n# Goals implemented (MAST-oriented):\n# - Clear role definitions and single-responsibility actions\n# - Robust communication: explicit send_to + watch/trigger logic\n# - Idempotent routing: per-role delivery tracking\n# - Strong verification with syntax, tests presence, cross-reference, and digest\n# - Error handling with LLM/API retries/backoff + deterministic fallbacks\n# - Safe termination: require consecutive verified passes with stable digest; stall detection and nudges\n\n# Tunables\nLLM_MAX_RETRIES = 3\nLLM_BACKOFF_BASE = 0.5  # seconds\nROLE_MAX_ATTEMPTS = 2\nREQUIRED_STABLE_PASSES = 2\nNO_PROGRESS_GRACE = 2  # rounds without new messages before stopping\n\n# ---------------------------\n# Actions\n# ---------------------------\n\nclass Action(ABC):\n    \"\"\"Base action with robust LLM call helper and simple contract.\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get(\"context\")\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    async def ask_llm(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries/backoff/jitter. On failure return 'LLM_ERROR:<reason>'.\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.llm:\n            if tracer:\n                tracer.log(\"LLM_FALLBACK\", self.name, \"LLM not configured; using deterministic error\")\n            return \"LLM_ERROR:unavailable\"\n        last_err = None\n        for attempt in range(1, LLM_MAX_RETRIES + 1):\n            try:\n                if tracer:\n                    tracer.log(\"LLM_CALL\", self.name, f\"Attempt {attempt}/{LLM_MAX_RETRIES}\")\n                resp = await self.llm.ask(messages)\n                if not isinstance(resp, str) or not resp.strip():\n                    last_err = \"empty_response\"\n                    raise RuntimeError(\"Empty response from LLM\")\n                if resp.strip().lower().startswith(\"error\") or \"error communicating\" in resp.lower():\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = str(e)\n                if tracer:\n                    tracer.log(\"LLM_RETRY\", self.name, f\"Attempt {attempt} failed: {last_err[:200]}\")\n                if attempt < LLM_MAX_RETRIES:\n                    backoff = LLM_BACKOFF_BASE * (2 ** (attempt - 1))\n                    jitter = random.uniform(0, backoff * 0.15)\n                    await asyncio.sleep(backoff + jitter)\n        if tracer:\n            tracer.log(\"LLM_GIVEUP\", self.name, f\"Exhausted retries: {last_err}\")\n        return f\"LLM_ERROR:{last_err or 'unknown'}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError()\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce an implementation from an idea (fallbacks ensure parseable code).\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        text = idea or \"\"\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"idea_len={len(text)}\")\n        if not text.strip():\n            # deterministic placeholder\n            return (\n                '\"\"\"Fallback implementation (empty idea).\"\"\"\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Return the input; placeholder for missing idea.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        prompt = (\n            \"You are an expert Python developer. Produce a compact, production-ready Python module implementing the task.\\n\"\n            \"Return only valid Python code (no backticks). Include docstrings and input validation where reasonable.\\n\\n\"\n            f\"Task: {text}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        code = await self.ask_llm(messages)\n        if code.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using deterministic code\")\n            return (\n                f'\"\"\"Fallback implementation for: {text[:160]}\"\"\"\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback function when generation fails.\\\"\\\"\\\"\\n\"\n                \"    if value is None:\\n\"\n                \"        return None\\n\"\n                \"    return value\\n\"\n            )\n        # ensure parseable\n        try:\n            ast.parse(code)\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_PARSE_FAIL\", self.name, f\"Generated code not parseable: {e}\")\n            return (\n                f'\"\"\"Fallback due to parse error for: {text[:160]}\"\"\"\\n'\n                \"def placeholder(value=None):\\n\"\n                \"    \\\"\\\"\\\"Fallback after parse error.\\\"\\\"\\\"\\n\"\n                \"    return value\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"code_len={len(code)}\")\n        return code\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests with minimal guarantees.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        snippet = (code or \"\")[:3000]\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"code_len={len(snippet)}\")\n        # Extract public symbols\n        symbols: List[str] = []\n        try:\n            tree = ast.parse(code or \"\")\n            for n in tree.body:\n                if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\"):\n                    symbols.append(n.name)\n        except Exception:\n            symbols = []\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided module.\\n\"\n            \"- Use def test_* functions and assert statements.\\n\"\n            \"- Cover normal and at least one edge case.\\n\"\n            \"- Return only valid test code.\\n\\n\"\n            f\"Public symbols (heuristic): {', '.join(symbols[:8]) or '(none detected)'}\\n\\n\"\n            f\"Code:\\n{snippet}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        tests = await self.ask_llm(messages)\n        # validate minimal structure\n        if tests.startswith(\"LLM_ERROR\"):\n            if tracer:\n                tracer.log(\"ACTION_FALLBACK\", self.name, \"LLM failed; using fallback tests\")\n            name = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"import pytest\\n\\n\"\n                f\"def test_{name}_exists():\\n\"\n                \"    # Fallback presence test\\n\"\n                \"    assert True\\n\"\n            )\n        try:\n            parsed = ast.parse(tests)\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(parsed))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(parsed)) or (\"assert \" in tests)\n            if not (has_test_fn or has_assert):\n                raise ValueError(\"No test functions or asserts found\")\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ACTION_PARSE_FAIL\", self.name, f\"Tests invalid: {e}\")\n            name = symbols[0] if symbols else \"placeholder\"\n            return (\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Fallback test when generation invalid.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"tests_len={len(tests)}\")\n        return tests\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code/tests and emit a verdict line for routing.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, f\"human={self.is_human}\")\n        # quick static analysis\n        issues: List[str] = []\n        try:\n            ast.parse(code or \"\")\n        except Exception as e:\n            issues.append(f\"code_syntax_error:{str(e)[:160]}\")\n        try:\n            ast.parse(tests or \"\")\n        except Exception as e:\n            issues.append(f\"tests_syntax_error:{str(e)[:160]}\")\n\n        if self.is_human:\n            review = \"HUMAN_REVIEW: \" + (\"; \".join(issues) if issues else \"OK\") + \"\\nVERDICT: \" + (\"FAIL\" if issues else \"PASS\")\n            if tracer:\n                tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review. End with a single line 'VERDICT: PASS' or 'VERDICT: FAIL'.\\n\\n\"\n            f\"Code (truncated):\\n{(code or '')[:1500]}\\n\\nTests (truncated):\\n{(tests or '')[:1500]}\\n\\n\"\n            f\"STATIC_ISSUES: {issues or 'none'}\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code reviews.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        review = await self.ask_llm(messages)\n        if review.startswith(\"LLM_ERROR\") or \"VERDICT:\" not in (review or \"\"):\n            # Fall back to static issues heuristic\n            verdict = \"FAIL\" if issues else \"PASS\"\n            review = (review if isinstance(review, str) else \"Automated review unavailable.\") + f\"\\nVERDICT: {verdict}\"\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, f\"review_len={len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Deterministic verification: syntax + test presence + cross-reference + digest.\"\"\"\n    name = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            tracer.log(\"ACTION_START\", self.name, \"Verifying artifacts\")\n        diagnostics: List[str] = []\n        code_ok = False\n        tests_ok = False\n        referenced = False\n\n        # Code parse + collect definitions\n        public_defs: Set[str] = set()\n        try:\n            code_tree = ast.parse(code or \"\")\n            public_defs = {n.name for n in ast.walk(code_tree) if isinstance(n, (ast.FunctionDef, ast.ClassDef)) and not n.name.startswith(\"_\")}\n            code_ok = True\n            diagnostics.append(f\"code_defs:{len(public_defs)}\")\n        except Exception as e:\n            diagnostics.append(f\"code_parse_error:{str(e)[:160]}\")\n\n        # Tests parse + presence\n        try:\n            tests_tree = ast.parse(tests or \"\")\n            has_test_fn = any(isinstance(n, ast.FunctionDef) and n.name.startswith(\"test_\") for n in ast.walk(tests_tree))\n            has_assert = any(isinstance(n, ast.Assert) for n in ast.walk(tests_tree)) or (\"assert \" in (tests or \"\"))\n            tests_ok = bool(has_test_fn or has_assert)\n            diagnostics.append(\"tests_presence:ok\" if tests_ok else \"tests_presence:none\")\n        except Exception as e:\n            diagnostics.append(f\"tests_parse_error:{str(e)[:160]}\")\n\n        # Cross-reference\n        try:\n            if public_defs and tests_ok:\n                test_names = {n.id for n in ast.walk(ast.parse(tests or \"\")) if isinstance(n, ast.Name)}\n                referenced = bool(public_defs & test_names)\n                diagnostics.append(\"tests_reference:ok\" if referenced else \"tests_reference:none\")\n            else:\n                diagnostics.append(\"tests_reference:skip\")\n        except Exception as e:\n            diagnostics.append(f\"reference_check_error:{str(e)[:160]}\")\n\n        verified = bool(code_ok and tests_ok and (referenced or not public_defs))\n        # Stable digest for early-stop confirmation\n        try:\n            digest = hashlib.sha256(((code or \"\") + \"\\n--TESTS--\\n\" + (tests or \"\")).encode(\"utf-8\")).hexdigest()[:12]\n        except Exception:\n            digest = \"nodigest\"\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | digest={digest} | \" + \"; \".join(diagnostics)\n        if tracer:\n            tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n# ---------------------------\n# Roles\n# ---------------------------\n\nclass Role(ABC):\n    \"\"\"Single-responsibility role with watch/trigger logic and idempotent processing.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    env: Optional[\"Environment\"] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # action names this role watches\n    is_human: bool = False\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get(\"name\", self.name)\n        self.profile = kwargs.get(\"profile\", self.profile)\n        self.context = kwargs.get(\"context\")\n        self.env = kwargs.get(\"env\", None)\n        self.is_human = kwargs.get(\"is_human\", False)\n        self.actions = []\n        self.watch_list = []\n        self._processed_message_ids: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions\n\n    def watch_actions(self, actions: List[Type[Action]]):\n        self.watch_list = [a.name for a in actions]\n\n    def should_handle(self, msg: Message) -> bool:\n        if not msg:\n            return False\n        # avoid reprocessing and self-authored\n        if getattr(msg, \"id\", None) in self._processed_message_ids:\n            return False\n        if getattr(msg, \"sent_from\", None) == self.name:\n            return False\n        # explicit routing (send_to set/list or string)\n        targets = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None)\n        if targets:\n            try:\n                if isinstance(targets, (set, list)):\n                    if self.name in targets or self.profile in targets or \"*\" in targets:\n                        return True\n                elif isinstance(targets, str):\n                    if targets in (self.name, self.profile, \"*\"):\n                        return True\n            except Exception:\n                pass\n            return False\n        # watch/trigger based on cause_by (action name)\n        if getattr(msg, \"cause_by\", \"\") in self.watch_list:\n            return True\n        # default: allow coder to act on initial user input\n        if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in self.profile:\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        tracer = getattr(self.context, \"tracer\", None)\n        if not self.actions:\n            if tracer:\n                tracer.log(\"ROLE_NO_ACTION\", self.name, \"No actions configured\")\n            return None\n        action = self.actions[0]\n        if message is not None and not self.should_handle(message):\n            if tracer:\n                tracer.log(\"ROLE_SKIP\", self.name, f\"Skip msg id={getattr(message,'id',None)}\")\n            return None\n\n        # Dispatch by action type; keep simple and deterministic\n        try:\n            if isinstance(action, SimpleWriteCode):\n                idea = (getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\")\n                out = await action.run(idea)\n                recipients = {\"SimpleTester\"}\n            elif isinstance(action, SimpleWriteTest):\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = message.content or \"\"\n                if not code_text and getattr(self, \"env\", None):\n                    latest_code = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    code_text = latest_code.content if latest_code else \"\"\n                out = await action.run(code_text)\n                recipients = {\"SimpleReviewer\", \"SimpleVerifier\"}\n            elif isinstance(action, SimpleWriteReview):\n                code_text, tests_text = \"\", \"\"\n                if getattr(self, \"env\", None):\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    test_msg = self.env.get_latest_artifact([SimpleWriteTest.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                    tests_text = test_msg.content if test_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                # Use verdict for routing\n                verdict_line = (out or \"\").lower()\n                recipients = {\"SimpleVerifier\"} if \"verdict: pass\" in verdict_line else {\"SimpleCoder\", \"SimpleTester\"}\n            elif isinstance(action, SimpleVerify):\n                code_text, tests_text = \"\", \"\"\n                if getattr(self, \"env\", None):\n                    code_msg = self.env.get_latest_artifact([SimpleWriteCode.name])\n                    test_msg = self.env.get_latest_artifact([SimpleWriteTest.name])\n                    code_text = code_msg.content if code_msg else \"\"\n                    tests_text = test_msg.content if test_msg else \"\"\n                out = await action.run(code_text, tests_text)\n                recipients = set()  # broadcast/record only\n            else:\n                out = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n                recipients = set()\n        except Exception as e:\n            if tracer:\n                tracer.log(\"ROLE_EXCEPTION\", self.name, f\"Exception during act: {type(e).__name__}: {str(e)[:160]}\")\n            out = f\"ROLE_EXCEPTION: {type(e).__name__}: {str(e)[:160]}\"\n            recipients = {\"SimpleCoder\"}\n\n        # mark processed input to avoid duplicates\n        if message and getattr(message, \"id\", None):\n            self._processed_message_ids.add(message.id)\n\n        response = Message(\n            content=out,\n            role=self.profile,\n            cause_by=action.name,\n            sent_from=self.name,\n            send_to=recipients\n        )\n        # avoid handling own response\n        self._processed_message_ids.add(response.id)\n        if tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Produced msg={response.id} send_to={list(recipients)}\")\n        return response\n\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self.watch_actions([])\n\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self.watch_actions([SimpleWriteCode])\n\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self.watch_actions([SimpleWriteTest])\n\n\nclass SimpleVerifier(Role):\n    name = \"Dana\"\n    profile = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self.watch_actions([SimpleWriteTest, SimpleWriteReview, SimpleWriteCode])\n\n# ---------------------------\n# Environment\n# ---------------------------\n\nclass Environment:\n    \"\"\"Message bus with deterministic routing, per-role delivery tracking, and artifact lookup.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # delivered: role.name -> set(message.id)\n        self._delivered: Dict[str, Set[str]] = {}\n        # index for quick artifact lookup by cause_by\n        self._by_cause: Dict[str, List[Message]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._delivered.setdefault(role.name, set())\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        # normalize send_to type and ensure id\n        if getattr(message, \"send_to\", None) is None:\n            try:\n                message.send_to = set(getattr(message, \"sent_to\", set()) or set())\n            except Exception:\n                message.send_to = set()\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        cb = getattr(message, \"cause_by\", \"\")\n        if cb:\n            self._by_cause.setdefault(cb, []).append(message)\n        if self.tracer:\n            preview = (message.content or \"\")[:160].replace(\"\\n\", \" \")\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Msg {message.id} from {message.sent_from} cause_by={message.cause_by} -> {list(message.send_to)} preview={preview}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages not yet delivered to the role and relevant by routing or watch triggers.\"\"\"\n        relevant: List[Message] = []\n        delivered = self._delivered.setdefault(role.name, set())\n\n        for msg in self.history:\n            mid = getattr(msg, \"id\", None)\n            if not mid or mid in delivered:\n                continue\n            # never re-deliver own message\n            if getattr(msg, \"sent_from\", None) == role.name:\n                delivered.add(mid)\n                continue\n            # explicit routing\n            send_to = getattr(msg, \"send_to\", None) or getattr(msg, \"sent_to\", None)\n            routed = False\n            if send_to:\n                try:\n                    if isinstance(send_to, (set, list)):\n                        routed = role.name in send_to or role.profile in send_to or \"*\" in send_to\n                    elif isinstance(send_to, str):\n                        routed = send_to in (role.name, role.profile, \"*\")\n                except Exception:\n                    routed = False\n            if routed:\n                relevant.append(msg)\n                delivered.add(mid)\n                continue\n            # watch-list by cause_by\n            if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                relevant.append(msg)\n                delivered.add(mid)\n                continue\n            # user input defaults for coder(s)\n            if getattr(msg, \"cause_by\", \"\") == \"UserInput\" and \"Coder\" in role.profile:\n                relevant.append(msg)\n                delivered.add(mid)\n                continue\n        return relevant\n\n    def get_latest_artifact(self, cause_names: Iterable[str]) -> Optional[Message]:\n        \"\"\"Fetch most recent message for any cause_by in cause_names.\"\"\"\n        for name in cause_names:\n            bucket = self._by_cause.get(name, [])\n            if bucket:\n                return bucket[-1]\n        return None\n\n# ---------------------------\n# Team Orchestrator\n# ---------------------------\n\nclass Team:\n    \"\"\"Deterministic orchestrator with robust verification streak and stall handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        # verification stability\n        self._last_digest: Optional[str] = None\n        self._pass_streak: int = 0\n\n    def hire(self, roles: List[Role]):\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds; need {REQUIRED_STABLE_PASSES} stable passes\")\n        # Initial directive to coder(s)\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to={\"SimpleCoder\"}\n        )\n        self.env.publish_message(initial_msg)\n\n        order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n        last_history_len = len(self.env.history)\n        no_progress_rounds = 0\n        rounds_ran = 0\n\n        for r in range(n_round):\n            rounds_ran = r + 1\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rounds_ran}/{n_round}\")\n            new_msgs = 0\n\n            for RoleClass in order:\n                for role in [x for x in self.env.roles if isinstance(x, RoleClass)]:\n                    msgs = self.env.get_messages_for_role(role)\n                    # Ensure coder sees the initial prompt on first round\n                    if isinstance(role, SimpleCoder) and r == 0 and initial_msg not in msgs:\n                        msgs = [initial_msg] + msgs\n                    for msg in msgs:\n                        try:\n                            # Role-level retry around act to catch transient internal issues\n                            attempts = 0\n                            resp: Optional[Message] = None\n                            while attempts < ROLE_MAX_ATTEMPTS:\n                                attempts += 1\n                                resp = await role.act(msg)\n                                if resp is not None:\n                                    break\n                                await asyncio.sleep(0.05 * attempts)\n                            if resp:\n                                self.env.publish_message(resp)\n                                new_msgs += 1\n                                # track verification stability if verifier produced PASS\n                                if isinstance(role, SimpleVerifier) and isinstance(resp.content, str):\n                                    text = resp.content\n                                    if \"VERIFICATION_RESULT: PASS\" in text:\n                                        # extract digest\n                                        digest = None\n                                        for part in text.split(\"|\"):\n                                            part = part.strip()\n                                            if part.startswith(\"digest=\"):\n                                                digest = part.split(\"=\", 1)[1]\n                                                break\n                                        if digest:\n                                            if digest == self._last_digest:\n                                                self._pass_streak += 1\n                                            else:\n                                                self._last_digest = digest\n                                                self._pass_streak = 1\n                                        else:\n                                            # treat PASS without digest as non-stable\n                                            self._pass_streak = 1\n                                            self._last_digest = None\n                                        self.tracer.log(\"VERIFY_STREAK\", \"Team\", f\"streak={self._pass_streak} digest={digest}\")\n                                    elif \"VERIFICATION_RESULT: FAIL\" in text:\n                                        if self._pass_streak > 0:\n                                            self.tracer.log(\"VERIFY_RESET\", \"Team\", f\"Reset streak {self._pass_streak}->0\")\n                                        self._pass_streak = 0\n                                        self._last_digest = None\n                        except Exception as e:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception during act: {type(e).__name__}: {str(e)[:160]}\")\n\n            # Round summary and progress checks\n            current_len = len(self.env.history)\n            if current_len == last_history_len:\n                no_progress_rounds += 1\n            else:\n                no_progress_rounds = 0\n            last_history_len = current_len\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"new_msgs={new_msgs} streak={self._pass_streak} history={len(self.env.history)}\")\n\n            # Termination: stable verification streak\n            if self._pass_streak >= REQUIRED_STABLE_PASSES:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Stable verification streak={self._pass_streak}; stopping\")\n                break\n\n            # Stall handling: nudge coder then stop if persists\n            if new_msgs == 0:\n                if no_progress_rounds == 1:\n                    nudge = Message(\n                        content=f\"Please refine or improve the implementation for: {self.idea}\",\n                        instruct_content=self.idea,\n                        role=\"System\",\n                        sent_from=\"Orchestrator\",\n                        cause_by=\"Nudge\",\n                        send_to={\"SimpleCoder\"}\n                    )\n                    self.env.publish_message(nudge)\n                elif no_progress_rounds >= NO_PROGRESS_GRACE:\n                    self.tracer.log(\"TEAM_NO_PROGRESS\", \"Team\", f\"No progress for {no_progress_rounds} rounds; terminating\")\n                    break\n\n            await asyncio.sleep(0.01)\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' finished after {rounds_ran} rounds with {len(self.env.history)} messages. Verified={self._pass_streak >= REQUIRED_STABLE_PASSES}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}