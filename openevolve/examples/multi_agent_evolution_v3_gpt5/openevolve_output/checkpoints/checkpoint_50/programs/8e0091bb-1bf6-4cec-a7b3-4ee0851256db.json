{"id": "8e0091bb-1bf6-4cec-a7b3-4ee0851256db", "code": "# -*- coding: utf-8 -*-\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\n\nclass Action(ABC):\n    \"\"\"Base action class with clear responsibilities and LLM retry logic\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    retry_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _call_llm_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries and exponential backoff. Return text or raise.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # deterministic fallback\n                    return \"LLM_FALLBACK_RESPONSE\"\n                resp = await self.llm.ask(messages)\n                # Treat responses starting with \"Error\" as failures\n                if isinstance(resp, str) and resp.startswith(\"Error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = e\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_RETRY\", self.name,\n                                            f\"Attempt {attempt} failed: {str(e)}\")\n                # Backoff before next try\n                await asyncio.sleep(self.retry_backoff * attempt)\n        # After retries\n        err_msg = f\"LLM failed after {self.max_retries} attempts: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FAIL\", self.name, err_msg)\n        # Return a structured error string instead of raising to allow graceful downstream handling\n        return f\"ERROR: {err_msg}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        raise NotImplementedError\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea. Returns code or an ERROR string.\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:120]}\")\n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n- Write clean, functional Python code\n- Include proper error handling where appropriate\n- Add comments explaining the logic\n- Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Produced {len(result)} characters\")\n        return result\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code. Returns tests or an ERROR string.\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Generating tests for code\")\n        truncated = code[:2000] if code else \"\"\n        prompt = f\"\"\"You are a QA engineer. Write comprehensive pytest tests for the following code.\n\nCode:\n{truncated}\n\nRequirements:\n- Write pytest-style test cases\n- Cover edge cases and error conditions\n- Include both positive and negative tests\n- Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Produced {len(result)} characters of tests\")\n        return result\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests and request changes if needed\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review code and tests. Returns review text (may include 'REQUEST_CHANGE').\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Looks OK but consider extra edge-case tests.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests.\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nDeliverables:\n1) A concise review focusing on correctness, style, and coverage.\n2) If critical issues found, prepend 'REQUEST_CHANGE:' and explain required changes.\n3) Otherwise, prepend 'APPROVE:' and give short rationale.\n\nKeep the response concise.\"\"\"\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            review = await self._call_llm_with_retries(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length {len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness (deterministic checks + LLM optional)\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Perform static verification: syntax + basic heuristics. Returns standardized VERIFICATION_RESULT.\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Starting verification\")\n        status = []\n        code_ok = False\n        tests_ok = False\n\n        # Syntax checks\n        try:\n            if not code or not code.strip():\n                raise SyntaxError(\"No code provided\")\n            ast.parse(code)\n            code_ok = True\n            status.append(\"code_syntax: ok\")\n        except Exception as e:\n            status.append(f\"code_syntax: fail ({str(e)[:120]})\")\n\n        try:\n            if not tests or not tests.strip():\n                raise SyntaxError(\"No tests provided\")\n            ast.parse(tests)\n            # Basic heuristic: ensure tests contain 'assert' or 'pytest'\n            if (\"assert \" in tests) or (\"pytest\" in tests) or (\"unittest\" in tests):\n                tests_ok = True\n                status.append(\"tests_syntax: ok\")\n            else:\n                status.append(\"tests_syntax: fail (no assertions found)\")\n        except Exception as e:\n            status.append(f\"tests_syntax: fail ({str(e)[:120]})\")\n\n        # Additional quality checks\n        heuristics = []\n        if code_ok:\n            if \"def \" not in code:\n                heuristics.append(\"no_def_found\")\n            if \"TODO\" in code or \"FIXME\" in code:\n                heuristics.append(\"todo_found\")\n        if tests_ok:\n            if \"assert\" not in tests and \"pytest\" not in tests:\n                heuristics.append(\"weak_tests\")\n\n        if heuristics:\n            status.append(\"heuristics: \" + \",\".join(heuristics))\n\n        verified = code_ok and tests_ok and (\"todo_found\" not in heuristics)\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with explicit trigger/watch and responsibilities\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # list of action names this role listens for\n    # explicit responsibility description\n    responsibility: str = \"Undefined\"\n    # maximum consecutive failures allowed before escalating\n    max_failures_before_escalation: int = 2\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.responsibility = kwargs.get('responsibility', self.responsibility)\n        self.failure_count = 0\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform (instances)\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for. Accepts classes or names.\"\"\"\n        names: List[str] = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                # fallback: use class attribute 'name' if exists\n                names.append(getattr(a, \"name\", a.__name__))\n            else:\n                names.append(str(a))\n        self.watch_list = names\n\n    def should_act_on(self, message: Optional[Message]) -> bool:\n        \"\"\"Decide whether to act on a message. Default: act if message.cause_by is in watch_list.\"\"\"\n        if message is None:\n            # allow initiator roles (like coder) to act without message\n            return False\n        if getattr(message, \"cause_by\", None) in self.watch_list:\n            return True\n        # also respond to direct 'send_to' addressing\n        send_to = getattr(message, \"send_to\", None)\n        if send_to and (self.profile in send_to or self.name in send_to):\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action and return a Message. Handles retries and error escalation.\"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name,\n                                    f\"Attempting action {action.name} on message {getattr(message,'id',None)}\")\n\n        try:\n            # Map action-specific inputs\n            if isinstance(action, SimpleWriteCode):\n                # Coder uses instruct_content if present (initial idea)\n                idea = getattr(message, \"instruct_content\", None) or (message.content if message else \"\")\n                result = await action.run(idea)\n            elif isinstance(action, SimpleWriteTest):\n                # Tester expects code content\n                code_src = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(code_src)\n            elif isinstance(action, SimpleWriteReview):\n                # Reviewer expects code + tests; attempt to gather from environment history if possible\n                code_text = \"\"\n                tests_text = \"\"\n                env = getattr(self, \"env\", None)\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    # message likely contains tests; get code from recent history\n                    tests_text = message.content\n                    if env:\n                        for msg in reversed(env.history):\n                            if getattr(msg, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = msg.content\n                                break\n                else:\n                    # generic attempt to fetch latest code/tests\n                    env = getattr(self, \"env\", None)\n                    if env:\n                        for msg in reversed(env.history):\n                            if getattr(msg, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = msg.content\n                            if getattr(msg, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = msg.content\n                            if code_text and tests_text:\n                                break\n                result = await action.run(code_text, tests_text)\n            elif isinstance(action, SimpleVerify):\n                # Verifier aggregates latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                env = getattr(self, \"env\", None)\n                if env:\n                    for msg in reversed(env.history):\n                        if getattr(msg, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                            tests_text = msg.content\n                        if getattr(msg, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                            code_text = msg.content\n                        if code_text and tests_text:\n                            break\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic action call\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n\n            # Reset failure count on success (heuristic: non-empty result)\n            if result and not (isinstance(result, str) and result.startswith(\"ERROR:\")):\n                self.failure_count = 0\n            else:\n                # treat as failure and increment\n                self.failure_count += 1\n\n            # Build outgoing message\n            out_msg = Message(\n                content=result,\n                role=self.profile,\n                cause_by=action.name,\n                sent_from=self.name,\n                send_to=set()\n            )\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_COMPLETE\", self.name,\n                                        f\"Produced message {out_msg.id} cause_by={out_msg.cause_by}\")\n            # Escalation if repeated failures\n            if self.failure_count > self.max_failures_before_escalation:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ESCALATION\", self.name,\n                                            f\"Failure count {self.failure_count} exceeded threshold\")\n            return out_msg\n        except Exception as e:\n            # Capture unexpected exceptions and return an error message rather than crashing\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, f\"Exception: {str(e)}\")\n            err_msg = Message(\n                content=f\"ERROR: Role {self.name} encountered exception: {str(e)}\",\n                role=self.profile,\n                cause_by=action.name,\n                sent_from=self.name\n            )\n            return err_msg\n\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code. Responsible for turning idea into code artifacts.\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    responsibility = \"Produce initial code artifact from idea\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder acts on user input (UserInput) or explicit 'REQUEST_CHANGE' triggers\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests. Responsible for generating tests from code artifacts.\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    responsibility = \"Produce tests ensuring coverage and edge cases\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Tester watches for new code artifacts\n        self._watch([SimpleWriteCode.name])\n\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests. Responsible for giving actionable feedback.\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    responsibility = \"Provide review and request changes if necessary\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Reviewer watches new tests (so it can evaluate coverage)\n        self._watch([SimpleWriteTest.name])\n\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests. Responsible for final verification and approval.\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n    responsibility = \"Verify artifacts (syntax + heuristics) and declare pass/fail\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        # Verifier watches tests and code to perform verification\n        self._watch([SimpleWriteTest.name, SimpleWriteCode.name])\n\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with robust routing and explicit triggers.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment and give it an env reference\"\"\"\n        self.roles.append(role)\n        setattr(role, \"env\", self)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment and log it. Messages are routed to watching roles.\"\"\"\n        # Normalize message fields if necessary\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\",\n                          f\"Message {getattr(message,'id', '')} from {message.sent_from}: {message.content[:120]} (cause_by={message.cause_by})\")\n        # Immediately notify roles that watch this message (non-blocking)\n        # Note: actual invocation of role.act is orchestrated by Team to keep control flow deterministic.\n        return\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages relevant to the role based on its watch_list and explicit addressing.\"\"\"\n        relevant_messages: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                relevant_messages.append(msg)\n                continue\n            # check addressing\n            send_to = getattr(msg, \"send_to\", None)\n            if send_to and (role.profile in send_to or role.name in send_to):\n                relevant_messages.append(msg)\n        return relevant_messages\n\n\nclass Team:\n    \"\"\"Team of agents working together with robust orchestration, explicit triggers and termination checks.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self.max_rounds_without_progress = 3  # to avoid infinite loops\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team and ensure they reference context and env\"\"\"\n        for role in roles:\n            role.context = self.context\n            setattr(role, \"env\", self.env)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for up to n_round rounds with deterministic orchestration.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # Initial message with the idea (explicitly cause_by 'UserInput')\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=set([r.profile for r in self.env.roles])  # broadcast by default\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        rounds_since_progress = 0\n        last_history_len = len(self.env.history)\n\n        # Orchestrated pipeline order (deterministic)\n        pipeline_order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            progress_this_round = False\n\n            # For each role type in pipeline, invoke all roles of that type in deterministic order\n            for role_type in pipeline_order:\n                for role in [r for r in self.env.roles if isinstance(r, role_type)]:\n                    # Determine incoming messages relevant to this role\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    msg_to_process = None\n\n                    # Prioritize the most recent relevant message\n                    if relevant_msgs:\n                        msg_to_process = relevant_msgs[-1]\n                    else:\n                        # For coder only, allow acting on initial idea even if not in watch_list\n                        if isinstance(role, SimpleCoder):\n                            # find initial user input\n                            for msg in reversed(self.env.history):\n                                if getattr(msg, \"cause_by\", \"\") == \"UserInput\":\n                                    msg_to_process = msg\n                                    break\n\n                    # Only act if we have a trigger or the role is allowed to act without a message\n                    if msg_to_process is None and not isinstance(role, SimpleCoder):\n                        # nothing to do for this role\n                        continue\n\n                    # Guard: do not act on messages that the role itself produced\n                    if msg_to_process and getattr(msg_to_process, \"sent_from\", None) == role.name:\n                        continue\n\n                    # Perform action with basic error handling and retries at role level\n                    try:\n                        response_msg = await role.act(msg_to_process)\n                    except Exception as e:\n                        # catch unexpected errors from role.act\n                        self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Unexpected exception: {str(e)}\")\n                        response_msg = Message(\n                            content=f\"ERROR: Unexpected exception in role {role.name}: {str(e)}\",\n                            role=role.profile,\n                            cause_by=\"EXCEPTION\",\n                            sent_from=role.name\n                        )\n\n                    # If role produced a message, publish it to environment\n                    if response_msg:\n                        # Provide addressing hints to guide next role(s)\n                        if isinstance(role, SimpleCoder):\n                            response_msg.send_to = set([SimpleTester.profile])\n                        elif isinstance(role, SimpleTester):\n                            response_msg.send_to = set([SimpleReviewer.profile, SimpleVerifier.profile])\n                        elif isinstance(role, SimpleReviewer):\n                            # If reviewer requested change, target coder; otherwise, send to verifier\n                            if isinstance(response_msg.content, str) and response_msg.content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                                response_msg.send_to = set([SimpleCoder.profile])\n                                response_msg.cause_by = \"REQUEST_CHANGE\"\n                            else:\n                                response_msg.send_to = set([SimpleVerifier.profile])\n                        elif isinstance(role, SimpleVerifier):\n                            # verdict goes to all\n                            response_msg.send_to = set([r.profile for r in self.env.roles])\n\n                        # publish\n                        self.env.publish_message(response_msg)\n                        progress_this_round = True\n\n                        # Check verification result explicitly to determine termination\n                        if isinstance(role, SimpleVerifier) and isinstance(response_msg.content, str):\n                            if \"VERIFICATION_RESULT: PASS\" in response_msg.content:\n                                verified = True\n\n            # Round end checks\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification passed in round {round_num + 1}, stopping early\")\n                break\n\n            # Detect progress stagnation\n            if len(self.env.history) == last_history_len:\n                rounds_since_progress += 1\n            else:\n                rounds_since_progress = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed. Progress={progress_this_round}, HistoryLen={len(self.env.history)}\")\n\n            if rounds_since_progress >= self.max_rounds_without_progress:\n                self.tracer.log(\"TEAM_HANG_DETECT\", \"Team\", f\"No progress for {rounds_since_progress} rounds, stopping to avoid livelock\")\n                break\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "3d91acaf-bcc7-43c5-88af-7196dafaee82", "generation": 1, "timestamp": 1754655188.4594138, "iteration_found": 2, "metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "overall_score": 0.5, "combined_score": 0.16666666666666666, "avg_failures_per_task": 5.0, "total_failures": 30.0, "successful_runs": 6.0}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes per the MAST taxonomy.\n\nFocus on:\n- Clear role definitions and responsibilities\n- Robust inter-agent communication patterns and explicit watch/trigger logic\n- Termination conditions (avoid premature termination; stop once verified)\n- Strong verification and validation steps\n- Error handling and retry on LLM/API failures\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 1.0000\n- overall_score: 0.5000\n- combined_score: 0.1667\n- avg_failures_per_task: 5.0000\n- total_failures: 30.0000\n- successful_runs: 6.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 1.0000, overall_score: 0.5000, combined_score: 0.1667, avg_failures_per_task: 5.0000, total_failures: 30.0000, successful_runs: 6.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 7.1111)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    \n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            code = await self.llm.ask(messages)\n        else:\n            code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} characters of code\")\n        \n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code[:2000]}  # Truncate if too long\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            tests = await self.llm.ask(messages)\n        else:\n            tests = f\"# Tests for the implementation\\n# [Tests would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} characters of tests\")\n        \n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        if self.is_human:\n            # Simulate human review\n            review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n            \n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            \n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review completed: {len(review)} characters\")\n        \n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n        try:\n            ast.parse(code)\n            code_ok = True\n        except Exception as e:\n            code_ok = False\n            code_err = str(e)\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n        except Exception as e:\n            tests_ok = False\n            tests_err = str(e)\n        status = []\n        if code_ok:\n            status.append(\"code_syntax: ok\")\n        else:\n            status.append(f\"code_syntax: fail ({code_err[:120]})\")\n        if tests_ok:\n            status.append(\"tests_syntax: ok\")\n        else:\n            status.append(f\"tests_syntax: fail ({(tests_err if 'tests_err' in locals() else 'empty')[:120]})\")\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        if not self.actions:\n            return None\n        \n        # Execute the first action (simplified)\n        action = self.actions[0]\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Executing action: {action.name}\")\n        \n        # Execute action based on type\n        if isinstance(action, SimpleWriteCode):\n            if message and hasattr(message, 'instruct_content'):\n                result = await action.run(message.instruct_content or message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteTest):\n            if message:\n                result = await action.run(message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteReview):\n            # For review, we need both code and tests\n            if message:\n                # Extract code and tests from previous messages (simplified)\n                result = await action.run(message.content, \"\")\n            else:\n                result = await action.run(\"\", \"\")\n        elif isinstance(action, SimpleVerify):\n            # For verification, try to find latest code and tests from history\n            env = getattr(self, 'env', None)\n            code_msg = None\n            tests_msg = None\n            if env:\n                for msg in reversed(env.history):\n                    if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                        code_msg = msg\n                    if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                        tests_msg = msg\n                    if code_msg and tests_msg:\n                        break\n            result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n        else:\n            result = \"Action completed\"\n        \n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed, message created\")\n        \n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", \n                          f\"Message from {message.sent_from}: {message.content[:100]}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            # Check if this message is from an action the role watches\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        verified = False\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Orchestrated sequence: Coder -> Tester -> Reviewer -> Verifier\n            for role in self.env.roles:\n                if isinstance(role, SimpleCoder):\n                    response = await role.act(initial_msg if round_num == 0 else None)\n                    if response:\n                        self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleTester):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleReviewer):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleVerifier):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n                            if \"VERIFICATION_RESULT: PASS\" in response.content:\n                                verified = True\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                break\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on overall_score (0.5000), Performs well on combined_score (0.1667), Performs well on avg_failures_per_task (5.0000), Performs well on total_failures (30.0000), Performs well on successful_runs (6.0000)\n\n\n\n\n# Current Program\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    \n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            code = await self.llm.ask(messages)\n        else:\n            code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} characters of code\")\n        \n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code[:2000]}  # Truncate if too long\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            tests = await self.llm.ask(messages)\n        else:\n            tests = f\"# Tests for the implementation\\n# [Tests would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} characters of tests\")\n        \n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        if self.is_human:\n            # Simulate human review\n            review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n            \n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            \n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review completed: {len(review)} characters\")\n        \n        return review\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        import ast\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Verifying code and tests\")\n        try:\n            ast.parse(code)\n            code_ok = True\n        except Exception as e:\n            code_ok = False\n            code_err = str(e)\n        try:\n            ast.parse(tests or \"\")\n            tests_ok = bool(tests and tests.strip())\n        except Exception as e:\n            tests_ok = False\n            tests_err = str(e)\n        status = []\n        if code_ok:\n            status.append(\"code_syntax: ok\")\n        else:\n            status.append(f\"code_syntax: fail ({code_err[:120]})\")\n        if tests_ok:\n            status.append(\"tests_syntax: ok\")\n        else:\n            status.append(f\"tests_syntax: fail ({(tests_err if 'tests_err' in locals() else 'empty')[:120]})\")\n        verified = code_ok and tests_ok\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        if not self.actions:\n            return None\n        \n        # Execute the first action (simplified)\n        action = self.actions[0]\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Executing action: {action.name}\")\n        \n        # Execute action based on type\n        if isinstance(action, SimpleWriteCode):\n            if message and hasattr(message, 'instruct_content'):\n                result = await action.run(message.instruct_content or message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteTest):\n            if message:\n                result = await action.run(message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteReview):\n            # For review, we need both code and tests\n            if message:\n                # Extract code and tests from previous messages (simplified)\n                result = await action.run(message.content, \"\")\n            else:\n                result = await action.run(\"\", \"\")\n        elif isinstance(action, SimpleVerify):\n            # For verification, try to find latest code and tests from history\n            env = getattr(self, 'env', None)\n            code_msg = None\n            tests_msg = None\n            if env:\n                for msg in reversed(env.history):\n                    if msg.cause_by == SimpleWriteCode.name and code_msg is None:\n                        code_msg = msg\n                    if msg.cause_by == SimpleWriteTest.name and tests_msg is None:\n                        tests_msg = msg\n                    if code_msg and tests_msg:\n                        break\n            result = await action.run(code_msg.content if code_msg else \"\", tests_msg.content if tests_msg else \"\")\n        else:\n            result = \"Action completed\"\n        \n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed, message created\")\n        \n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", \n                          f\"Message from {message.sent_from}: {message.content[:100]}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            # Check if this message is from an action the role watches\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            # Provide env reference for roles that need to look back at history\n            setattr(role, 'env', self.env)\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        verified = False\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Orchestrated sequence: Coder -> Tester -> Reviewer -> Verifier\n            for role in self.env.roles:\n                if isinstance(role, SimpleCoder):\n                    response = await role.act(initial_msg if round_num == 0 else None)\n                    if response:\n                        self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleTester):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleReviewer):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n            for role in self.env.roles:\n                if isinstance(role, SimpleVerifier):\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])\n                        if response:\n                            self.env.publish_message(response)\n                            if \"VERIFICATION_RESULT: PASS\" in response.content:\n                                verified = True\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", \"Verification passed, stopping early\")\n                break\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# -*- coding: utf-8 -*-\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-5\"\n        self.api_key = None\n        self.base_url = os.getenv(\"OPENAI_API_BASE\", \"https://api.openai.com/v1\")\n        self.proxy = \"\"\n        self.temperature = 0.35\n        self.max_token = 8192\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_token\n        }\n        try:\n            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=120)) as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nimport asyncio\nimport time\nimport ast\n\nclass Action(ABC):\n    \"\"\"Base action class with clear responsibilities and LLM retry logic\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    max_retries: int = 3\n    retry_backoff: float = 1.0  # seconds\n\n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and getattr(self.context, \"config\", None) and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n\n    async def _call_llm_with_retries(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Call LLM with retries and exponential backoff. Return text or raise.\"\"\"\n        last_err = None\n        for attempt in range(1, self.max_retries + 1):\n            try:\n                if not self.llm:\n                    # deterministic fallback\n                    return \"LLM_FALLBACK_RESPONSE\"\n                resp = await self.llm.ask(messages)\n                # Treat responses starting with \"Error\" as failures\n                if isinstance(resp, str) and resp.startswith(\"Error\"):\n                    last_err = resp\n                    raise RuntimeError(resp)\n                return resp\n            except Exception as e:\n                last_err = e\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"LLM_RETRY\", self.name,\n                                            f\"Attempt {attempt} failed: {str(e)}\")\n                # Backoff before next try\n                await asyncio.sleep(self.retry_backoff * attempt)\n        # After retries\n        err_msg = f\"LLM failed after {self.max_retries} attempts: {last_err}\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"LLM_FAIL\", self.name, err_msg)\n        # Return a structured error string instead of raising to allow graceful downstream handling\n        return f\"ERROR: {err_msg}\"\n\n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        raise NotImplementedError\n\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea. Returns code or an ERROR string.\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:120]}\")\n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n- Write clean, functional Python code\n- Include proper error handling where appropriate\n- Add comments explaining the logic\n- Make it production-ready\n\nProvide only the Python code with no surrounding backticks or explanations.\"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Produced {len(result)} characters\")\n        return result\n\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code. Returns tests or an ERROR string.\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Generating tests for code\")\n        truncated = code[:2000] if code else \"\"\n        prompt = f\"\"\"You are a QA engineer. Write comprehensive pytest tests for the following code.\n\nCode:\n{truncated}\n\nRequirements:\n- Write pytest-style test cases\n- Cover edge cases and error conditions\n- Include both positive and negative tests\n- Add docstrings to explain what each test does\n\nProvide only the Python test code with no surrounding backticks or explanations.\"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        result = await self._call_llm_with_retries(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Produced {len(result)} characters of tests\")\n        return result\n\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests and request changes if needed\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review code and tests. Returns review text (may include 'REQUEST_CHANGE').\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Looks OK but consider extra edge-case tests.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests.\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nDeliverables:\n1) A concise review focusing on correctness, style, and coverage.\n2) If critical issues found, prepend 'REQUEST_CHANGE:' and explain required changes.\n3) Otherwise, prepend 'APPROVE:' and give short rationale.\n\nKeep the response concise.\"\"\"\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            review = await self._call_llm_with_retries(messages)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review length {len(review)}\")\n        return review\n\n\nclass SimpleVerify(Action):\n    \"\"\"Action to verify code and tests and decide readiness (deterministic checks + LLM optional)\"\"\"\n    name: str = \"SimpleVerify\"\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Perform static verification: syntax + basic heuristics. Returns standardized VERIFICATION_RESULT.\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Starting verification\")\n        status = []\n        code_ok = False\n        tests_ok = False\n\n        # Syntax checks\n        try:\n            if not code or not code.strip():\n                raise SyntaxError(\"No code provided\")\n            ast.parse(code)\n            code_ok = True\n            status.append(\"code_syntax: ok\")\n        except Exception as e:\n            status.append(f\"code_syntax: fail ({str(e)[:120]})\")\n\n        try:\n            if not tests or not tests.strip():\n                raise SyntaxError(\"No tests provided\")\n            ast.parse(tests)\n            # Basic heuristic: ensure tests contain 'assert' or 'pytest'\n            if (\"assert \" in tests) or (\"pytest\" in tests) or (\"unittest\" in tests):\n                tests_ok = True\n                status.append(\"tests_syntax: ok\")\n            else:\n                status.append(\"tests_syntax: fail (no assertions found)\")\n        except Exception as e:\n            status.append(f\"tests_syntax: fail ({str(e)[:120]})\")\n\n        # Additional quality checks\n        heuristics = []\n        if code_ok:\n            if \"def \" not in code:\n                heuristics.append(\"no_def_found\")\n            if \"TODO\" in code or \"FIXME\" in code:\n                heuristics.append(\"todo_found\")\n        if tests_ok:\n            if \"assert\" not in tests and \"pytest\" not in tests:\n                heuristics.append(\"weak_tests\")\n\n        if heuristics:\n            status.append(\"heuristics: \" + \",\".join(heuristics))\n\n        verified = code_ok and tests_ok and (\"todo_found\" not in heuristics)\n\n        result = f\"VERIFICATION_RESULT: {'PASS' if verified else 'FAIL'} | \" + \"; \".join(status)\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, result)\n        return result\n\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with explicit trigger/watch and responsibilities\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[str] = []  # list of action names this role listens for\n    # explicit responsibility description\n    responsibility: str = \"Undefined\"\n    # maximum consecutive failures allowed before escalating\n    max_failures_before_escalation: int = 2\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n        self.responsibility = kwargs.get('responsibility', self.responsibility)\n        self.failure_count = 0\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform (instances)\"\"\"\n        self.actions = actions\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for. Accepts classes or names.\"\"\"\n        names: List[str] = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                # fallback: use class attribute 'name' if exists\n                names.append(getattr(a, \"name\", a.__name__))\n            else:\n                names.append(str(a))\n        self.watch_list = names\n\n    def should_act_on(self, message: Optional[Message]) -> bool:\n        \"\"\"Decide whether to act on a message. Default: act if message.cause_by is in watch_list.\"\"\"\n        if message is None:\n            # allow initiator roles (like coder) to act without message\n            return False\n        if getattr(message, \"cause_by\", None) in self.watch_list:\n            return True\n        # also respond to direct 'send_to' addressing\n        send_to = getattr(message, \"send_to\", None)\n        if send_to and (self.profile in send_to or self.name in send_to):\n            return True\n        return False\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action and return a Message. Handles retries and error escalation.\"\"\"\n        if not self.actions:\n            return None\n\n        action = self.actions[0]\n\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name,\n                                    f\"Attempting action {action.name} on message {getattr(message,'id',None)}\")\n\n        try:\n            # Map action-specific inputs\n            if isinstance(action, SimpleWriteCode):\n                # Coder uses instruct_content if present (initial idea)\n                idea = getattr(message, \"instruct_content\", None) or (message.content if message else \"\")\n                result = await action.run(idea)\n            elif isinstance(action, SimpleWriteTest):\n                # Tester expects code content\n                code_src = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(code_src)\n            elif isinstance(action, SimpleWriteReview):\n                # Reviewer expects code + tests; attempt to gather from environment history if possible\n                code_text = \"\"\n                tests_text = \"\"\n                env = getattr(self, \"env\", None)\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    # message likely contains tests; get code from recent history\n                    tests_text = message.content\n                    if env:\n                        for msg in reversed(env.history):\n                            if getattr(msg, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = msg.content\n                                break\n                else:\n                    # generic attempt to fetch latest code/tests\n                    env = getattr(self, \"env\", None)\n                    if env:\n                        for msg in reversed(env.history):\n                            if getattr(msg, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                                tests_text = msg.content\n                            if getattr(msg, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                                code_text = msg.content\n                            if code_text and tests_text:\n                                break\n                result = await action.run(code_text, tests_text)\n            elif isinstance(action, SimpleVerify):\n                # Verifier aggregates latest code and tests\n                code_text = \"\"\n                tests_text = \"\"\n                env = getattr(self, \"env\", None)\n                if env:\n                    for msg in reversed(env.history):\n                        if getattr(msg, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                            tests_text = msg.content\n                        if getattr(msg, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                            code_text = msg.content\n                        if code_text and tests_text:\n                            break\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic action call\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n\n            # Reset failure count on success (heuristic: non-empty result)\n            if result and not (isinstance(result, str) and result.startswith(\"ERROR:\")):\n                self.failure_count = 0\n            else:\n                # treat as failure and increment\n                self.failure_count += 1\n\n            # Build outgoing message\n            out_msg = Message(\n                content=result,\n                role=self.profile,\n                cause_by=action.name,\n                sent_from=self.name,\n                send_to=set()\n            )\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_COMPLETE\", self.name,\n                                        f\"Produced message {out_msg.id} cause_by={out_msg.cause_by}\")\n            # Escalation if repeated failures\n            if self.failure_count > self.max_failures_before_escalation:\n                if self.context and self.context.tracer:\n                    self.context.tracer.log(\"ESCALATION\", self.name,\n                                            f\"Failure count {self.failure_count} exceeded threshold\")\n            return out_msg\n        except Exception as e:\n            # Capture unexpected exceptions and return an error message rather than crashing\n            if self.context and self.context.tracer:\n                self.context.tracer.log(\"ROLE_ERROR\", self.name, f\"Exception: {str(e)}\")\n            err_msg = Message(\n                content=f\"ERROR: Role {self.name} encountered exception: {str(e)}\",\n                role=self.profile,\n                cause_by=action.name,\n                sent_from=self.name\n            )\n            return err_msg\n\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code. Responsible for turning idea into code artifacts.\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    responsibility = \"Produce initial code artifact from idea\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder acts on user input (UserInput) or explicit 'REQUEST_CHANGE' triggers\n        self._watch([\"UserInput\", \"REQUEST_CHANGE\"])\n\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests. Responsible for generating tests from code artifacts.\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    responsibility = \"Produce tests ensuring coverage and edge cases\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Tester watches for new code artifacts\n        self._watch([SimpleWriteCode.name])\n\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests. Responsible for giving actionable feedback.\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    responsibility = \"Provide review and request changes if necessary\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Reviewer watches new tests (so it can evaluate coverage)\n        self._watch([SimpleWriteTest.name])\n\n\nclass SimpleVerifier(Role):\n    \"\"\"Role that verifies code and tests. Responsible for final verification and approval.\"\"\"\n    name: str = \"Dana\"\n    profile: str = \"SimpleVerifier\"\n    responsibility = \"Verify artifacts (syntax + heuristics) and declare pass/fail\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleVerify(context=self.context)])\n        # Verifier watches tests and code to perform verification\n        self._watch([SimpleWriteTest.name, SimpleWriteCode.name])\n\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with robust routing and explicit triggers.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment and give it an env reference\"\"\"\n        self.roles.append(role)\n        setattr(role, \"env\", self)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment and log it. Messages are routed to watching roles.\"\"\"\n        # Normalize message fields if necessary\n        if not getattr(message, \"id\", None):\n            try:\n                message.id = str(uuid.uuid4())\n            except Exception:\n                pass\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\",\n                          f\"Message {getattr(message,'id', '')} from {message.sent_from}: {message.content[:120]} (cause_by={message.cause_by})\")\n        # Immediately notify roles that watch this message (non-blocking)\n        # Note: actual invocation of role.act is orchestrated by Team to keep control flow deterministic.\n        return\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages relevant to the role based on its watch_list and explicit addressing.\"\"\"\n        relevant_messages: List[Message] = []\n        for msg in self.history:\n            if getattr(msg, \"cause_by\", None) in role.watch_list:\n                relevant_messages.append(msg)\n                continue\n            # check addressing\n            send_to = getattr(msg, \"send_to\", None)\n            if send_to and (role.profile in send_to or role.name in send_to):\n                relevant_messages.append(msg)\n        return relevant_messages\n\n\nclass Team:\n    \"\"\"Team of agents working together with robust orchestration, explicit triggers and termination checks.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 20.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n        self.max_rounds_without_progress = 3  # to avoid infinite loops\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team and ensure they reference context and env\"\"\"\n        for role in roles:\n            role.context = self.context\n            setattr(role, \"env\", self.env)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 4):\n        \"\"\"Run the team collaboration for up to n_round rounds with deterministic orchestration.\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running up to {n_round} rounds\")\n        # Initial message with the idea (explicitly cause_by 'UserInput')\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\",\n            send_to=set([r.profile for r in self.env.roles])  # broadcast by default\n        )\n        self.env.publish_message(initial_msg)\n\n        verified = False\n        rounds_since_progress = 0\n        last_history_len = len(self.env.history)\n\n        # Orchestrated pipeline order (deterministic)\n        pipeline_order = [SimpleCoder, SimpleTester, SimpleReviewer, SimpleVerifier]\n\n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n\n            progress_this_round = False\n\n            # For each role type in pipeline, invoke all roles of that type in deterministic order\n            for role_type in pipeline_order:\n                for role in [r for r in self.env.roles if isinstance(r, role_type)]:\n                    # Determine incoming messages relevant to this role\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    msg_to_process = None\n\n                    # Prioritize the most recent relevant message\n                    if relevant_msgs:\n                        msg_to_process = relevant_msgs[-1]\n                    else:\n                        # For coder only, allow acting on initial idea even if not in watch_list\n                        if isinstance(role, SimpleCoder):\n                            # find initial user input\n                            for msg in reversed(self.env.history):\n                                if getattr(msg, \"cause_by\", \"\") == \"UserInput\":\n                                    msg_to_process = msg\n                                    break\n\n                    # Only act if we have a trigger or the role is allowed to act without a message\n                    if msg_to_process is None and not isinstance(role, SimpleCoder):\n                        # nothing to do for this role\n                        continue\n\n                    # Guard: do not act on messages that the role itself produced\n                    if msg_to_process and getattr(msg_to_process, \"sent_from\", None) == role.name:\n                        continue\n\n                    # Perform action with basic error handling and retries at role level\n                    try:\n                        response_msg = await role.act(msg_to_process)\n                    except Exception as e:\n                        # catch unexpected errors from role.act\n                        self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Unexpected exception: {str(e)}\")\n                        response_msg = Message(\n                            content=f\"ERROR: Unexpected exception in role {role.name}: {str(e)}\",\n                            role=role.profile,\n                            cause_by=\"EXCEPTION\",\n                            sent_from=role.name\n                        )\n\n                    # If role produced a message, publish it to environment\n                    if response_msg:\n                        # Provide addressing hints to guide next role(s)\n                        if isinstance(role, SimpleCoder):\n                            response_msg.send_to = set([SimpleTester.profile])\n                        elif isinstance(role, SimpleTester):\n                            response_msg.send_to = set([SimpleReviewer.profile, SimpleVerifier.profile])\n                        elif isinstance(role, SimpleReviewer):\n                            # If reviewer requested change, target coder; otherwise, send to verifier\n                            if isinstance(response_msg.content, str) and response_msg.content.strip().upper().startswith(\"REQUEST_CHANGE\"):\n                                response_msg.send_to = set([SimpleCoder.profile])\n                                response_msg.cause_by = \"REQUEST_CHANGE\"\n                            else:\n                                response_msg.send_to = set([SimpleVerifier.profile])\n                        elif isinstance(role, SimpleVerifier):\n                            # verdict goes to all\n                            response_msg.send_to = set([r.profile for r in self.env.roles])\n\n                        # publish\n                        self.env.publish_message(response_msg)\n                        progress_this_round = True\n\n                        # Check verification result explicitly to determine termination\n                        if isinstance(role, SimpleVerifier) and isinstance(response_msg.content, str):\n                            if \"VERIFICATION_RESULT: PASS\" in response_msg.content:\n                                verified = True\n\n            # Round end checks\n            if verified:\n                self.tracer.log(\"TEAM_EARLY_STOP\", \"Team\", f\"Verification passed in round {round_num + 1}, stopping early\")\n                break\n\n            # Detect progress stagnation\n            if len(self.env.history) == last_history_len:\n                rounds_since_progress += 1\n            else:\n                rounds_since_progress = 0\n            last_history_len = len(self.env.history)\n\n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed. Progress={progress_this_round}, HistoryLen={len(self.env.history)}\")\n\n            if rounds_since_progress >= self.max_rounds_without_progress:\n                self.tracer.log(\"TEAM_HANG_DETECT\", \"Team\", f\"No progress for {rounds_since_progress} rounds, stopping to avoid livelock\")\n                break\n\n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {round_num + 1} rounds with {len(self.env.history)} messages exchanged. Verified={verified}\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 4, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context),\n        SimpleVerifier(context=context)\n    ])\n    \n    team.invest(investment=15.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}