{"id": "e8e9858c-6af3-4308-9593-66b39b992448", "code": "# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Convert to a stable string without raising.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Create a Message object compatible with either pydantic Message or the fallback.\n    Always returns an object with attributes: id, content, instruct_content, role, cause_by, sent_from, sent_to, send_to.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        return Message(content=content, instruct_content=instruct_content, role=role, cause_by=cause_by or \"\", sent_from=sent_from)\n    except Exception:\n        # Fallback minimal message-like object\n        class SimpleMsg:\n            def __init__(self, content, instruct_content, role, cause_by, sent_from):\n                self.id = str(uuid.uuid4())\n                self.content = content\n                self.instruct_content = instruct_content\n                self.role = role\n                self.cause_by = cause_by or \"\"\n                self.sent_from = sent_from\n                self.sent_to = None\n                self.send_to = set()\n            def __str__(self):\n                return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n        return SimpleMsg(content, instruct_content, role, cause_by or \"\", sent_from)\n\nclass Action(ABC):\n    \"\"\"Simplified base action with safe llm access and tracer use.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create an LLMInterface when needed. Fail silently if not possible.\"\"\"\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        try:\n            tracer = getattr(self.context, \"tracer\", None)\n            if tracer:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n        except Exception:\n            # ensure logging never raises\n            pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code for a given idea or instruction.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"code_for_len={len(idea)}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the request below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\nReturn only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n                code = _safe_str(result)\n            else:\n                # deterministic fallback to minimize variability\n                code = (\n                    f\"# Placeholder implementation for: {idea}\\n\"\n                    \"def placeholder_function(*args, **kwargs):\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"code_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"code_len={len(_safe_str(code))}\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for provided code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", f\"tests_for_code_len={len(code)}\")\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation below.\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n- Use pytest\\n- Cover typical and edge cases\\n- Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n                tests = _safe_str(result)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder positive test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"test_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"tests_len={len(_safe_str(tests))}\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide a concise review of code and tests.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)[:1500]\n        tests = _safe_str(tests)[:1500]\n        self._log(\"ACTION_START\", f\"review_code_len={len(code)} tests_len={len(tests)} human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Looks reasonable. Consider additional edge-case tests and clearer docstrings.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Provide a concise review focusing on readability, correctness, and test coverage.\\n\\n\"\n                f\"Code:\\n{code}\\n\\nTests:\\n{tests}\\n\\nKeep the review short and actionable.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            try:\n                if self.llm:\n                    result = await self.llm.ask(messages)\n                    review = _safe_str(result)\n                else:\n                    review = \"Automated review: Structure acceptable. Add more negative tests and clearer error handling.\"\n            except Exception as e:\n                review = f\"Review error: {_safe_str(e)}\"\n                self._log(\"ACTION_ERROR\", f\"review_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"review_len={len(_safe_str(review))}\")\n        return _safe_str(review)\n\nclass Role(ABC):\n    \"\"\"A role that holds a primary action and responds deterministically.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # list of cause_by strings this role is interested in\n        self.watch_list: List[str] = []\n        # environment set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                try:\n                    names.append(getattr(a, \"name\"))\n                except Exception:\n                    continue\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                names.append(a.__name__)\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        try:\n            tracer = getattr(self.context, \"tracer\", None)\n            if tracer:\n                tracer.log(event, self.name, details)\n        except Exception:\n            pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action. Simple deterministic mapping based on message cause.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"no_actions\")\n            return None\n\n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"{action_name} message_id={getattr(message, 'id', None)}\")\n\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea or \"\")\n            elif action_name == SimpleWriteTest.name:\n                # prefer code from the triggering message if present\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code_text or \"\")\n            elif action_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or \"\"\n                if self.env:\n                    if not code_text:\n                        latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code_text = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                    if not tests_text:\n                        latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        tests_text = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                # propagate human flag into the action if possible\n                if isinstance(action, SimpleWriteReview):\n                    action.is_human = self.is_human\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            err = f\"Action error: {_safe_str(e)}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        response = _make_message(content=_safe_str(result), role=self.profile, cause_by=action_name, sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"produced (cause_by={action_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # responds to explicit user instruction\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with simple, robust routing.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        try:\n            role.env = self\n            self.roles.append(role)\n            if self.tracer:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n        except Exception:\n            pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message and log a short preview; don't allow exceptions to escape.\"\"\"\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                preview = (_safe_str(getattr(message, \"content\", \"\")) or \"\")[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From={sender} cause={cause} preview={preview}\")\n        except Exception:\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", \"Failed to publish message (suppressed)\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any entry in role.watch_list (chronological).\"\"\"\n        if not role.watch_list:\n            return []\n        watched = set(role.watch_list)\n        out: List[Message] = []\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    out.append(m)\n            except Exception:\n                continue\n        return out\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Return the most recent message with matching cause_by.\"\"\"\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles with deterministic rounds and minimal failure surface.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        try:\n            # convenience reference\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in (roles or []):\n            try:\n                r.context = r.context or self.context\n                r.env = self.env\n                # ensure actions carry the context\n                for a in getattr(r, \"actions\", []) or []:\n                    try:\n                        a.context = a.context or self.context\n                    except Exception:\n                        pass\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        initial_msg = _make_message(content=f\"Let's work on this project: {self.idea}\", instruct_content=self.idea, role=\"Human\", sent_from=\"User\", cause_by=\"UserInput\")\n        self.env.publish_message(initial_msg)\n\n        for rnum in range(n_round):\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnum + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            # iterate over a stable snapshot to avoid concurrent mutation issues\n            for role in list(self.env.roles):\n                try:\n                    response = None\n                    # On first round, prefer coder(s) to handle user instruction\n                    if rnum == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in getattr(role, \"actions\", [])):\n                        response = await role.act(initial_msg)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1])\n                        else:\n                            continue\n\n                    if response:\n                        # best-effort ensure cause_by exists (some fallback message objects may lack it)\n                        try:\n                            if not getattr(response, \"cause_by\", None):\n                                response.cause_by = getattr(response, \"cause_by\", \"\") or \"\"\n                        except Exception:\n                            pass\n                        self.env.publish_message(response)\n                except Exception as e:\n                    try:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                    except Exception:\n                        pass\n                    continue\n\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnum + 1} completed\")\n            except Exception:\n                pass\n\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        try:\n            if self.tracer:\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "4910fbfc-13ff-485d-a48f-b55232f5ac2b", "generation": 3, "timestamp": 1754648210.5556135, "iteration_found": 61, "metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes.\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 0.5000\n- overall_score: 0.2500\n- combined_score: 0.1000\n- avg_failures_per_task: 12.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"\n    Robust helper to construct Message objects across pydantic/fallback implementations.\n    \"\"\"\n    try:\n        return Message(\n            content=_safe_str(content),\n            role=role,\n            cause_by=cause_by or \"\",\n            sent_from=sent_from,\n            instruct_content=instruct_content\n        )\n    except Exception:\n        # Fallback to minimal object compatible with Environment expectations\n        class _M:\n            pass\n        m = _M()\n        m.id = str(uuid.uuid4())\n        m.content = _safe_str(content)\n        m.instruct_content = instruct_content\n        m.role = role\n        m.cause_by = cause_by or \"\"\n        m.sent_from = sent_from\n        m.sent_to = None\n        m.send_to = set()\n        return m\n\nclass Action(ABC):\n    \"\"\"Base action with safe logging and lazy LLM access\"\"\"\n    name: str = \"Action\"\n    \n    def __init__(self, **kwargs):\n        self.context: Optional[Context] = kwargs.get('context')\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, etype: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(etype, self.name, details)\n            except Exception:\n                pass\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write clean, functional Python code\\n\"\n            \"2. Include proper error handling\\n\"\n            \"3. Add comments explaining the logic\\n\"\n            \"4. Make it production-ready\\n\\n\"\n            \"Please provide only the code without any explanation.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = (\n                    f\"# Implementation for: {idea}\\n\"\n                    \"def solution():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(_safe_str(code))} characters of code\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", \"Writing tests for code\")\n        prompt = (\n            \"You are a QA engineer. Write comprehensive tests for the following code:\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write pytest-style test cases\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Include both positive and negative tests\\n\"\n            \"4. Add docstrings to explain what each test does\\n\\n\"\n            \"Please provide only the test code without any explanation.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(_safe_str(tests))} characters of tests\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = bool(is_human)\n    \n    async def run(self, code: str, tests: str) -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling and more edge-case tests.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Review the following code and tests:\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Provide a brief review focusing on:\\n\"\n                    \"1. Code quality and best practices\\n\"\n                    \"2. Test coverage\\n\"\n                    \"3. Potential bugs or issues\\n\"\n                    \"4. Suggestions for improvement\\n\\n\"\n                    \"Keep your review concise and actionable.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt},\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Structure is reasonable; add more edge-case handling and clearer error messages.\"\n        except Exception as e:\n            review = f\"Error during review: {e}\"\n        self._log(\"ACTION_END\", f\"Review completed: {len(_safe_str(review))} characters\")\n        return _safe_str(review)\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with simplified routing\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context: Optional[Context] = kwargs.get('context')\n        self.is_human: bool = bool(kwargs.get('is_human', False))\n        self.actions: List[Action] = []\n        # watch_list stores cause_by names (strings)\n        self.watch_list: Set[str] = set()\n        # reference to the environment (set when hired)\n        self.env: Optional[\"Environment\"] = None\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform and ensure context alignment\"\"\"\n        self.actions = actions or []\n        for a in self.actions:\n            try:\n                a.context = self.context\n            except Exception:\n                pass\n    \n    def _watch(self, actions: List[Type[Action] or str]):\n        \"\"\"Set the actions this role watches for. Accepts types or names.\"\"\"\n        names: Set[str] = set()\n        for a in (actions or []):\n            try:\n                if isinstance(a, str):\n                    names.add(a)\n                elif hasattr(a, 'name'):\n                    names.add(getattr(a, 'name'))\n                elif isinstance(a, type) and hasattr(a, 'name'):\n                    names.add(getattr(a, 'name'))\n                else:\n                    names.add(str(a))\n            except Exception:\n                continue\n        self.watch_list = names\n    \n    def _log(self, etype: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(etype, self.name, details)\n            except Exception:\n                pass\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message.\"\"\"\n        if not self.actions:\n            return None\n        \n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"Executing action: {action_name}\")\n        \n        result = \"\"\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            elif action_name == SimpleWriteTest.name:\n                code_text = \"\"\n                # Prefer code from triggering message if it was produced by coder\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                # Else use the latest code from environment\n                if not code_text and self.env:\n                    try:\n                        code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        if code_msg:\n                            code_text = getattr(code_msg, \"content\", \"\") or code_text\n                    except Exception:\n                        pass\n                # Fallback: use message content if present\n                if not code_text and message:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(code_text)\n\n            elif action_name == SimpleWriteReview.name:\n                tests_text = \"\"\n                code_text = \"\"\n                # Prefer tests from triggering message if it was produced by tester\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or \"\"\n                # Get latest code/tests from environment as needed\n                if self.env:\n                    try:\n                        if not code_text:\n                            code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                            if code_msg:\n                                code_text = getattr(code_msg, \"content\", \"\") or code_text\n                        if not tests_text:\n                            test_msg = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                            if test_msg:\n                                tests_text = getattr(test_msg, \"content\", \"\") or tests_text\n                    except Exception:\n                        pass\n                result = await action.run(code_text or \"\", tests_text or \"\")\n\n            else:\n                # Generic action: pass message content\n                content = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(content)\n        except Exception as e:\n            err = f\"Error executing action {action_name}: {e}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n        \n        response = _make_message(\n            content=result,\n            role=self.profile,\n            cause_by=action_name,\n            sent_from=self.name\n        )\n        self._log(\"ROLE_COMPLETE\", f\"Action completed, message created (cause_by={action_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        # Ensure back-references\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        try:\n            self.history.append(message)\n        except Exception:\n            # Attempt to normalize and append\n            try:\n                m = _make_message(\n                    content=_safe_str(getattr(message, \"content\", message)),\n                    role=_safe_str(getattr(message, \"role\", \"Unknown\")),\n                    cause_by=_safe_str(getattr(message, \"cause_by\", \"\")),\n                    sent_from=_safe_str(getattr(message, \"sent_from\", \"Unknown\"))\n                )\n                self.history.append(m)\n                message = m\n            except Exception:\n                # Give up silently to prevent crashing\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                content_preview = (getattr(message, \"content\", \"\") or \"\")[:100]\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {sender}: {content_preview}\")\n            except Exception:\n                pass\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages: List[Message] = []\n        watch_names = set(getattr(role, \"watch_list\", []) or [])\n        if not watch_names:\n            return relevant_messages\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watch_names:\n                    relevant_messages.append(msg)\n            except Exception:\n                continue\n        return relevant_messages\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by matches cause_name.\"\"\"\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            try:\n                role.context = self.context\n                # Ensure all existing actions carry updated context\n                for a in getattr(role, \"actions\", []) or []:\n                    try:\n                        a.context = self.context\n                    except Exception:\n                        pass\n            except Exception:\n                pass\n            # Provide environment reference so roles can inspect history\n            role.env = self.env\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Each role acts in sequence\n            for role in self.env.roles:\n                response = None\n                # First round: let the coder respond to the user input explicitly\n                if round_num == 0 and isinstance(role, SimpleCoder):\n                    try:\n                        response = await role.act(initial_msg)\n                    except Exception as e:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {e}\")\n                        response = None\n                else:\n                    # Other roles respond to relevant messages\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        try:\n                            response = await role.act(relevant_msgs[-1])  # Act on most recent relevant message\n                        except Exception as e:\n                            if self.tracer:\n                                self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {e}\")\n                            response = None\n                    else:\n                        # No relevant messages; skip\n                        continue\n                \n                if response:\n                    self.env.publish_message(response)\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n\n### Program 2 (Score: 3.2125)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Stable string conversion without raising.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Create a Message instance in a robust way that works with pydantic Message or fallback Message class.\n    Returns an object with expected attributes.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        # Preferred: named constructor (works with pydantic Message)\n        return Message(content=content, instruct_content=instruct_content, role=role, cause_by=cause_by or \"\", sent_from=sent_from)\n    except Exception:\n        try:\n            # Fallback positional\n            return Message(content, role, instruct_content=instruct_content, cause_by=cause_by or \"\", sent_from=sent_from)\n        except Exception:\n            # Last resort: minimal object\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n            return _M(content, role, cause_by or \"\", sent_from, instruct_content)\n\nclass Action(ABC):\n    \"\"\"Small, predictable action base with lazy LLM init and safe logging.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily instantiate LLMInterface; swallow errors to avoid failure modes.\"\"\"\n        if self._llm is None and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            try:\n                self._llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the request.\\n\\n\"\n            f\"Task:\\n{idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\nReturn only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                code = _safe_str(resp)\n            else:\n                # Deterministic fallback reduces flakiness\n                code = (\n                    f\"# Implementation for: {idea}\\n\\n\"\n                    \"def placeholder_function():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", \"Writing tests for code\")\n        prompt = (\n            \"You are an expert QA engineer. Given the implementation, write pytest-style tests (positive and negative).\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = _safe_str(resp)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"Reviewing (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Looks reasonable. Consider adding more edge-case tests and clearer errors.\"\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise review focusing on code quality, test coverage, and issues.\\n\\n\"\n                f\"Code:\\n{code[:1500]}\\n\\nTests:\\n{tests[:1500]}\\n\\nKeep it concise.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            try:\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = _safe_str(resp)\n                else:\n                    review = \"Automated review: Acceptable structure; consider more edge cases and clearer error handling.\"\n            except Exception as e:\n                review = f\"Error during review: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Review length {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simplified role with deterministic selection and minimal mutable state.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list contains cause_by strings to respond to\n        self.watch_list: List[str] = []\n        # environment reference set when hired\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # Ensure action contexts are consistent\n        prepared = []\n        for a in (actions or []):\n            try:\n                a.context = self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action]]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                try:\n                    names.append(getattr(a, \"name\"))\n                except Exception:\n                    pass\n            elif isinstance(a, type):\n                names.append(getattr(a, \"name\", a.__name__))\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> Optional[Message]:\n        \"\"\"\n        Determine appropriate action and produce a message.\n        Deterministic mapping:\n          - If there is an instruct_content -> SimpleWriteCode\n          - If message.cause_by == SimpleWriteCode -> SimpleWriteTest\n          - If message.cause_by == SimpleWriteTest -> SimpleWriteReview\n          - Otherwise default to first action.\n        \"\"\"\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions available\")\n            return None\n\n        env = env or self.env\n        selected = self.actions[0]\n\n        # Prefer explicit instruction for coder\n        if message and getattr(message, \"instruct_content\", None):\n            for a in self.actions:\n                if getattr(a, \"name\", \"\") == SimpleWriteCode.name:\n                    selected = a\n                    break\n        else:\n            cause = getattr(message, \"cause_by\", \"\") if message else \"\"\n            if cause:\n                if cause == SimpleWriteCode.name:\n                    for a in self.actions:\n                        if getattr(a, \"name\", \"\") == SimpleWriteTest.name:\n                            selected = a\n                            break\n                elif cause == SimpleWriteTest.name:\n                    for a in self.actions:\n                        if getattr(a, \"name\", \"\") == SimpleWriteReview.name:\n                            selected = a\n                            break\n\n        self._log(\"ROLE_ACT\", f\"Executing {getattr(selected, 'name', 'Action')}\")\n\n        try:\n            if getattr(selected, \"name\", \"\") == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await selected.run(idea)\n\n            elif getattr(selected, \"name\", \"\") == SimpleWriteTest.name:\n                # Prefer code in the triggering message; else search env history\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                elif env:\n                    for m in reversed(env.history):\n                        if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                            code_text = getattr(m, \"content\", \"\") or \"\"\n                            break\n                result = await selected.run(code_text)\n\n            elif getattr(selected, \"name\", \"\") == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                # If message is tests or code prefer it\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                        tests_text = getattr(message, \"content\", \"\") or \"\"\n                    elif getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                        code_text = getattr(message, \"content\", \"\") or \"\"\n                # Fill missing pieces from env\n                if env:\n                    if not code_text:\n                        for m in reversed(env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = getattr(m, \"content\", \"\") or \"\"\n                                break\n                    if not tests_text:\n                        for m in reversed(env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name:\n                                tests_text = getattr(m, \"content\", \"\") or \"\"\n                                break\n                # Propagate human flag to action if possible\n                if isinstance(selected, SimpleWriteReview):\n                    selected.is_human = self.is_human\n                result = await selected.run(code_text, tests_text)\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await selected.run(payload)\n        except Exception as e:\n            self._log(\"ROLE_ERROR\", f\"Action failed: {_safe_str(e)}\")\n            result = f\"Error executing action: {_safe_str(e)}\"\n\n        response = _make_message(content=result, role=self.profile, cause_by=getattr(selected, \"name\", \"\"), sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"Produced message (cause_by={getattr(selected, 'name', '')})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # listens to explicit user instruction\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with simple routing rules.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        # Attach environment reference to role for lookups\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message and log a short preview. Never raise.\"\"\"\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                preview = _safe_str(getattr(message, \"content\", \"\"))[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {sender} (cause={cause}): {preview}\")\n        except Exception:\n            # swallow any error to avoid interrupting runs\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", \"Failed to publish message\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        results: List[Message] = []\n        try:\n            watched = set(role.watch_list)\n            for m in self.history:\n                try:\n                    if getattr(m, \"cause_by\", \"\") in watched:\n                        results.append(m)\n                except Exception:\n                    continue\n        except Exception:\n            pass\n        return results\n\nclass Team:\n    \"\"\"Orchestrates roles deterministically with safe error handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        # expose env inside context for convenience\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in (roles or []):\n            try:\n                r.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        # initial user message\n        initial = _make_message(content=f\"Let's work on this project: {self.idea}\", role=\"Human\", cause_by=\"UserInput\", sent_from=\"User\", instruct_content=self.idea)\n        self.env.publish_message(initial)\n\n        for round_num in range(n_round):\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            # Iterate over a stable snapshot of roles\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: coder responds to user input explicitly\n                    if round_num == 0 and role.profile == \"SimpleCoder\":\n                        response = await role.act(initial, env=self.env)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1], env=self.env)\n                        else:\n                            continue\n                except Exception as e:\n                    try:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"{_safe_str(e)}\")\n                    except Exception:\n                        pass\n                    continue\n\n                if response:\n                    # Ensure cause_by present\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            except Exception:\n                pass\n\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n\n        try:\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            if self.tracer:\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type, Union\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(value: Any) -> str:\n    \"\"\"Return a stable string representation without raising.\"\"\"\n    try:\n        if value is None:\n            return \"\"\n        if isinstance(value, str):\n            return value\n        return str(value)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Robustly construct a Message-like object. Tries the project's Message class first,\n    falls back to a minimal object that has the expected attributes.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        return Message(content=content, instruct_content=instruct_content, role=role, cause_by=cause_by or \"\", sent_from=sent_from)\n    except Exception:\n        class Minimal:\n            pass\n        m = Minimal()\n        m.id = str(uuid.uuid4())\n        m.content = content\n        m.instruct_content = instruct_content\n        m.role = role\n        m.cause_by = cause_by or \"\"\n        m.sent_from = sent_from\n        m.sent_to = None\n        m.send_to = set()\n        return m\n\nclass Action(ABC):\n    \"\"\"Base action with lazy LLM init and safe logging to reduce failure modes.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, *, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLMInterface; swallow exceptions.\"\"\"\n        if self._llm is None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                # Do not propagate tracer errors\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code given an idea or instruction.\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"idea_len={len(idea)}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the following task.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short explanatory comments\\n\\nReturn only the code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                code = _safe_str(resp)\n            else:\n                # Deterministic fallback to minimize variability\n                code = (\n                    f\"# Placeholder implementation for: {idea}\\n\\n\"\n                    \"def solution(*args, **kwargs):\\n\"\n                    \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"code_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"code_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for provided code.\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        code_text = _safe_str(code)[:4000]\n        self._log(\"ACTION_START\", f\"code_snip_len={len(code_text)}\")\n        prompt = (\n            \"You are an expert QA engineer. Write pytest tests for the implementation below.\\n\\n\"\n            f\"{code_text}\\n\\n\"\n            \"Requirements:\\n- Use pytest\\n- Cover typical and edge cases\\n- Short docstrings for tests\\n\\nReturn only test code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = _safe_str(resp)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder positive test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"test_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce concise feedback.\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str, tests: str) -> str:\n        code_text = _safe_str(code)[:2000]\n        tests_text = _safe_str(tests)[:2000]\n        self._log(\"ACTION_START\", f\"code_len={len(code_text)} tests_len={len(tests_text)} human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Looks reasonable. Consider adding edge-case tests and more explicit error handling.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Provide a concise, actionable review of the code and tests below.\\n\\n\"\n                f\"Code:\\n{code_text}\\n\\nTests:\\n{tests_text}\\n\\nFocus on readability, correctness, coverage, and improvements. Keep it short.\"\n            )\n            messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                        {\"role\": \"user\", \"content\": prompt}]\n            try:\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = _safe_str(resp)\n                else:\n                    review = \"Automated review: Structure acceptable; add more negative tests and clearer error handling.\"\n            except Exception as e:\n                review = f\"Review error: {_safe_str(e)}\"\n                self._log(\"ACTION_ERROR\", f\"review_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"review_len={len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Agent role: holds actions, reacts deterministically to messages, minimal mutable state.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n\n    def __init__(self, *, name: Optional[str] = None, profile: Optional[str] = None, context: Optional[Context] = None, env: Optional[\"Environment\"] = None, is_human: bool = False):\n        self.name = name or self.name\n        self.profile = profile or self.profile\n        self.context = context\n        self.env = env\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list: names of action outputs (cause_by) this role cares about\n        self.watch_list: List[str] = []\n\n    def set_actions(self, actions: List[Action]):\n        # ensure action context bound\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                if getattr(a, \"context\", None) is None:\n                    a.context = self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Union[Type[Action], str]]):\n        names: List[str] = []\n        for a in (actions or []):\n            try:\n                if isinstance(a, str):\n                    names.append(a)\n                elif hasattr(a, \"name\"):\n                    names.append(getattr(a, \"name\"))\n                elif hasattr(a, \"__name__\"):\n                    names.append(getattr(a, \"__name__\"))\n            except Exception:\n                continue\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Deterministic routing: coder handles user instructions; tester reacts to coder outputs; reviewer reacts to tests.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_NOP\", \"No actions assigned\")\n            return None\n\n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"action={action_name} msg_id={getattr(message, 'id', None)}\")\n\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(idea or \"\")\n            elif action_name == SimpleWriteTest.name:\n                code_text = \"\"\n                # prefer code from message if it's from coder\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code_text or \"\")\n            elif action_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                        tests_text = getattr(message, \"content\", \"\") or \"\"\n                if self.env:\n                    if not code_text:\n                        latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code_text = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                    if not tests_text:\n                        latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        tests_text = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            err = f\"Action {action_name} failed: {_safe_str(e)}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        response = _make_message(content=result, role=self.profile, cause_by=action_name, sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"produced_len={len(_safe_str(getattr(response, 'content', '')))} cause_by={getattr(response, 'cause_by', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # listens to explicit user instruction\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment storing roles and message history with robust operations.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        try:\n            self.history.append(message)\n        except Exception:\n            try:\n                m = _make_message(content=_safe_str(getattr(message, \"content\", message)), role=_safe_str(getattr(message, \"role\", \"System\")), cause_by=_safe_str(getattr(message, \"cause_by\", \"\")), sent_from=_safe_str(getattr(message, \"sent_from\", \"System\")))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                snippet = _safe_str(getattr(message, \"content\", \"\"))[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From={sender} cause={cause} snippet={snippet}\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        if not role.watch_list:\n            return []\n        res: List[Message] = []\n        watched = set(role.watch_list or [])\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    res.append(m)\n            except Exception:\n                continue\n        return res\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles and rounds with deterministic, safe execution to reduce failures.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in (roles or []):\n            try:\n                r.context = self.context\n                for a in getattr(r, \"actions\", []) or []:\n                    if getattr(a, \"context\", None) is None:\n                        a.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        initial = _make_message(content=f\"Let's work on this project: {self.idea}\", instruct_content=self.idea, role=\"Human\", sent_from=\"User\", cause_by=\"UserInput\")\n        self.env.publish_message(initial)\n\n        for rnum in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnum+1}/{n_round}\")\n                except Exception:\n                    pass\n\n            # iterate over a stable snapshot of roles\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # allow coder(s) to respond to initial instruction in first round\n                    if rnum == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, _safe_str(e))\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role.actions[0], \"name\", \"UnknownAction\") if role.actions else \"UnknownAction\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnum+1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n                summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D2 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Lightweight base action with safe LLM access and logging helpers.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, *, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily construct LLMInterface if configuration is present.\"\"\"\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg is not None and getattr(cfg, \"llm\", None) is not None:\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                # never allow tracing issues to propagate\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n    def __init__(self, *, context: Optional[Context] = None):\n        super().__init__(context=context)\n\n    async def run(self, idea: str) -> str:\n        idea = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Preparing code generation (len={len(idea)})\")\n        if not idea:\n            # explicit deterministic fallback: small template that is valid Python\n            fallback = (\n                \"# No idea provided. Placeholder implementation\\n\"\n                \"def solution(*args, **kwargs):\\n\"\n                \"    \\\"\\\"\\\"Placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            self._log(\"ACTION_END\", \"Used deterministic fallback for code\")\n            return fallback\n\n        prompt = (\n            \"You are an expert Python programmer. Produce clear, correct Python code for the task below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, testable code\\n\"\n            \"- Basic error handling when applicable\\n\"\n            \"- Short comments explaining non-obvious parts\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                result = f\"# Implementation for: {idea}\\n# [LLM not available - deterministic stub]\\n\"\n        except Exception as e:\n            result = f\"# Error generating code: {e}\\n\"\n        self._log(\"ACTION_END\", f\"Generated code (len={len(result)})\")\n        return result\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n    def __init__(self, *, context: Optional[Context] = None):\n        super().__init__(context=context)\n\n    async def run(self, code: str) -> str:\n        code = (code or \"\").strip()\n        self._log(\"ACTION_START\", f\"Preparing tests generation (code_len={len(code)})\")\n        if not code:\n            fallback = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    assert True\\n\"\n            )\n            self._log(\"ACTION_END\", \"Used deterministic fallback for tests\")\n            return fallback\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided implementation.\\n\\n\"\n            f\"Code (first 2000 chars):\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest\\n\"\n            \"- Cover typical and edge cases\\n\"\n            \"- Return only test code\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                result = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            result = f\"# Error generating tests: {e}\\n\"\n        self._log(\"ACTION_END\", f\"Generated tests (len={len(result)})\")\n        return result\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str, tests: str) -> str:\n        code = (code or \"\").strip()\n        tests = (tests or \"\").strip()\n        self._log(\"ACTION_START\", f\"Preparing review (code_len={len(code)}, tests_len={len(tests)}, human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Looks good; consider adding more edge-case tests and clearer docstrings.\"\n            self._log(\"ACTION_END\", \"Produced human-like review\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review of the code and tests.\\n\\n\"\n            f\"Code (first 1500 chars):\\n{code[:1500]}\\n\\n\"\n            f\"Tests (first 1500 chars):\\n{tests[:1500]}\\n\\n\"\n            \"Focus on readability, possible bugs, test coverage, and simple suggestions. Keep it short.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                result = \"Automated review: Code structure acceptable. Consider more boundary tests.\"\n        except Exception as e:\n            result = f\"Review error: {e}\"\n        self._log(\"ACTION_END\", f\"Review generated (len={len(result)})\")\n        return result\n\nclass Role(ABC):\n    \"\"\"Simple role that holds one primary action and optional watch list.\"\"\"\n    def __init__(self, *, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = is_human\n        self.actions: List[Action] = []\n        # watch_list contains strings of cause_by values to react to\n        self.watch_list: List[str] = []\n        # env will be set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # Bind context into actions for safety\n        bound: List[Action] = []\n        for a in actions or []:\n            a.context = a.context or self.context\n            bound.append(a)\n        self.actions = bound\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"__name__\"))\n        self.watch_list = [n for n in names if n]\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action deterministically and return a Message.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions assigned\")\n            return None\n\n        action = self.actions[0]\n        self._log(\"ROLE_ACT\", f\"Action={action.name} MessageID={getattr(message, 'id', None)}\")\n\n        try:\n            if action.name == SimpleWriteCode.name:\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n            elif action.name == SimpleWriteTest.name:\n                # prefer code from the provided message; otherwise look up last code in environment\n                code_text = getattr(message, \"content\", \"\") if message else \"\"\n                if not code_text and self.env:\n                    last_code = self.env.get_latest_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(last_code, \"content\", \"\") if last_code else \"\"\n                result = await action.run(code_text)\n            elif action.name == SimpleWriteReview.name:\n                # assemble code and tests from environment history when possible\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    last_code = self.env.get_latest_by_cause(SimpleWriteCode.name)\n                    last_tests = self.env.get_latest_by_cause(SimpleWriteTest.name)\n                    code_text = getattr(last_code, \"content\", \"\") if last_code else \"\"\n                    tests_text = getattr(last_tests, \"content\", \"\") if last_tests else \"\"\n                # message may contain part of this too (use to fill gaps)\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                        code_text = getattr(message, \"content\", \"\")\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                        tests_text = getattr(message, \"content\", \"\")\n                result = await action.run(code_text, tests_text)\n            else:\n                # generic fallback, pass content if available\n                arg = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(arg)\n        except Exception as e:\n            err = f\"Action {action.name} failed: {e}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        # Construct response message safely for both pydantic and plain implementations\n        try:\n            response = Message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n        except Exception:\n            # fallback minimal object\n            class Mini:\n                pass\n            response = Mini()\n            response.content = result\n            response.role = self.profile\n            response.cause_by = action.name\n            response.sent_from = self.name\n\n        self._log(\"ROLE_COMPLETE\", f\"Produced message (len={len(result)})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # coder listens to user input only (handled by Team)\n        self._watch([])\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Tracks roles and message history; provides helper queries used by roles.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        try:\n            self.history.append(message)\n        except Exception:\n            # safe append: wrap into simple message if necessary\n            try:\n                m = Message(content=str(getattr(message, \"content\", \"\")), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                snippet = (getattr(message, \"content\", \"\") or \"\")[:100]\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {sender}: {snippet}\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any entry in role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        watched = set(role.watch_list)\n        relevant: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    relevant.append(msg)\n            except Exception:\n                continue\n        return relevant\n\n    def get_latest_by_cause(self, cause: str) -> Optional[Message]:\n        \"\"\"Return the most recent message with the given cause_by.\"\"\"\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles, environment, and rounds in a deterministic and robust way.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # ensure context tracer reference exists\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            try:\n                r.context = r.context or self.context\n                r.env = self.env\n                # ensure actions have context\n                for a in getattr(r, \"actions\", []):\n                    a.context = a.context or self.context\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea or \"\"\n        try:\n            self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        try:\n            self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        # Initial user message with instruct_content\n        initial = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial)\n\n        for rnum in range(n_round):\n            try:\n                self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnum+1}/{n_round}\")\n            except Exception:\n                pass\n\n            # deterministic order: coder(s) first, then tester(s), then reviewer(s)\n            for role in list(self.env.roles):\n                try:\n                    response = None\n                    # coder responds to initial instruction on first round\n                    if rnum == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial)\n                    else:\n                        candidates = self.env.get_messages_for_role(role)\n                        if not candidates:\n                            continue\n                        response = await role.act(candidates[-1])\n\n                    if response:\n                        # ensure cause_by set\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role.actions[0], \"name\", \"UnknownAction\")\n                        self.env.publish_message(response)\n                except Exception as e:\n                    try:\n                        self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception while acting: {e}\")\n                    except Exception:\n                        pass\n                    continue\n\n            try:\n                self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnum+1} completed\")\n            except Exception:\n                pass\n\n        try:\n            self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D3 (Score: 3.2125)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event: str, agent: str, details: str):\n    \"\"\"Best-effort logging helper that never raises.\"\"\"\n    if not tracer:\n        return\n    try:\n        tracer.log(event, agent, details)\n    except Exception:\n        pass\n\ndef _ensure_str(s: Optional[str]) -> str:\n    \"\"\"Convert possibly None or non-string to a safe string.\"\"\"\n    if s is None:\n        return \"\"\n    try:\n        return str(s)\n    except Exception:\n        return \"\"\n\nclass Action(ABC):\n    \"\"\"Simplified base Action with safe llm access and logging.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg is not None and getattr(cfg, \"llm\", None) is not None:\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        _safe_log(getattr(self.context, \"tracer\", None), event, getattr(self, \"name\", \"Action\"), details)\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate code for the provided idea/requirements.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _ensure_str(idea).strip()\n        self._log(\"ACTION_START\", f\"len_idea={len(idea)}\")\n        if not idea:\n            # Deterministic fallback to reduce variability/failure\n            fallback = (\n                \"# No idea provided. Placeholder implementation\\n\"\n                \"def solution(*args, **kwargs):\\n\"\n                \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            self._log(\"ACTION_END\", \"used_fallback\")\n            return fallback\n\n        prompt = (\n            \"You are an expert Python programmer. Write clean, testable Python code for the task below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, testable code\\n\"\n            \"- Basic error handling\\n\"\n            \"- Short comments for non-obvious parts\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = f\"# Implementation for: {idea}\\n# [LLM unavailable - fallback placeholder]\\n\"\n        except Exception as e:\n            code = f\"# Error generating code: {e}\\n\"\n        self._log(\"ACTION_END\", f\"generated_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for given code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _ensure_str(code)\n        self._log(\"ACTION_START\", f\"code_len={len(code)}\")\n        if not code.strip():\n            fallback = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            self._log(\"ACTION_END\", \"used_fallback\")\n            return fallback\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation below.\\n\\n\"\n            f\"Code (first 2000 chars):\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest\\n\"\n            \"- Cover normal and edge cases\\n\"\n            \"- Include docstrings\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\\n\"\n        self._log(\"ACTION_END\", f\"generated_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide concise human-like or automated review of code and tests.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _ensure_str(code)\n        tests = _ensure_str(tests)\n        self._log(\"ACTION_START\", f\"code_len={len(code)}, tests_len={len(tests)}, human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Looks good overall. Consider adding more edge-case tests and clearer docstrings.\"\n            self._log(\"ACTION_END\", \"human_review\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review of the code and tests.\\n\\n\"\n            f\"Code (first 1500 chars):\\n{code[:1500]}\\n\\n\"\n            f\"Tests (first 1500 chars):\\n{tests[:1500]}\\n\\n\"\n            \"Focus on readability, potential bugs, and test coverage. Be concise.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Automated review: Code structure acceptable. Add more boundary and negative-case tests.\"\n        except Exception as e:\n            review = f\"Review error: {e}\"\n        self._log(\"ACTION_END\", f\"generated_len={len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simple role abstraction with deterministic action selection.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = is_human\n        # single primary action instance per role\n        self.action: Optional[Action] = None\n        # watch_list: cause_by strings this role should respond to\n        self.watch_list: List[str] = []\n        # environment reference set when hired\n        self.env: Optional[\"Environment\"] = None\n\n    def set_action(self, action: Action):\n        # ensure action knows context\n        if getattr(action, \"context\", None) is None:\n            action.context = self.context\n        self.action = action\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"__name__\"))\n        self.watch_list = [n for n in names if n]\n\n    def _log(self, event: str, details: str):\n        _safe_log(getattr(self.context, \"tracer\", None), event, self.name, details)\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action using a small set of explicit, deterministic rules.\"\"\"\n        if not self.action:\n            self._log(\"ROLE_SKIP\", \"no_action\")\n            return None\n\n        self._log(\"ROLE_ACT\", f\"action={getattr(self.action, 'name', 'unknown')}, msg_id={getattr(message, 'id', None)}\")\n\n        try:\n            # Determine inputs in priority: explicit message -> env latest -> fallback\n            if getattr(self.action, \"name\", \"\") == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await self.action.run(idea or \"\")\n            elif getattr(self.action, \"name\", \"\") == SimpleWriteTest.name:\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\")\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await self.action.run(code_text or \"\")\n            elif getattr(self.action, \"name\", \"\") == SimpleWriteReview.name:\n                # prefer tests from triggering message and code from latest code message\n                tests_text = \"\"\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\")\n                if self.env:\n                    latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                    if not tests_text:\n                        latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        tests_text = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                result = await self.action.run(code_text or \"\", tests_text or \"\")\n            else:\n                # Generic fallback: pass message content or empty string\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await self.action.run(payload)\n        except Exception as e:\n            err = f\"Action failed: {e}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        # Construct a Message for response; keep compatible with both pydantic and fallback Message\n        try:\n            response = Message(\n                content=result,\n                role=self.profile,\n                cause_by=getattr(self.action, \"name\", \"\"),\n                sent_from=self.name\n            )\n        except Exception:\n            class _Mini:\n                pass\n            response = _Mini()\n            response.id = str(uuid.uuid4())\n            response.content = result\n            response.instruct_content = None\n            response.role = self.profile\n            response.cause_by = getattr(self.action, \"name\", \"\")\n            response.sent_from = self.name\n\n        self._log(\"ROLE_COMPLETE\", f\"produced_len={len(_ensure_str(result))}\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        super().__init__(name=kwargs.get(\"name\", \"Alice\"), profile=kwargs.get(\"profile\", \"SimpleCoder\"), context=kwargs.get(\"context\"), is_human=kwargs.get(\"is_human\", False))\n        self.set_action(SimpleWriteCode(context=self.context))\n        self._watch([])  # responds to initial user instruction\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        super().__init__(name=kwargs.get(\"name\", \"Bob\"), profile=kwargs.get(\"profile\", \"SimpleTester\"), context=kwargs.get(\"context\"), is_human=kwargs.get(\"is_human\", False))\n        self.set_action(SimpleWriteTest(context=self.context))\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        super().__init__(name=kwargs.get(\"name\", \"Charlie\"), profile=kwargs.get(\"profile\", \"SimpleReviewer\"), context=kwargs.get(\"context\"), is_human=kwargs.get(\"is_human\", False))\n        self.set_action(SimpleWriteReview(is_human=self.is_human, context=self.context))\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Lightweight environment for storing messages and providing simple queries.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role={role.name}\")\n\n    def publish_message(self, message: Message):\n        # Ensure message has id where possible and append; log safely\n        try:\n            if not hasattr(message, \"id\") or getattr(message, \"id\", None) is None:\n                message.id = str(uuid.uuid4())\n        except Exception:\n            pass\n        self.history.append(message)\n        _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"from={getattr(message, 'sent_from', 'Unknown')} cause={getattr(message, 'cause_by', '')} preview={_ensure_str(getattr(message, 'content', ''))[:100]}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by is in role.watch_list (in chronological order).\"\"\"\n        if not role.watch_list:\n            return []\n        watched = set(role.watch_list)\n        result: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    result.append(msg)\n            except Exception:\n                continue\n        return result\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles to collaborate on an idea. Simple, deterministic and robust.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # Ensure context has tracer reference\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            # Bind team context and environment to roles and their actions\n            r.context = r.context or self.context\n            r.env = self.env\n            if getattr(r, \"action\", None):\n                try:\n                    r.action.context = r.action.context or self.context\n                except Exception:\n                    pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = float(investment)\n\n    def run_project(self, idea: str):\n        self.idea = _ensure_str(idea)\n        _safe_log(self.tracer, \"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        _safe_log(self.tracer, \"TEAM_RUN\", \"Team\", f\"Running rounds={n_round}\")\n\n        # Initial user message\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        # Deterministic order: as added\n        for rnum in range(n_round):\n            _safe_log(self.tracer, \"ROUND_START\", \"Team\", f\"round={rnum+1}/{n_round}\")\n            for role in list(self.env.roles):\n                try:\n                    response = None\n                    # Give coder the initial message on first round\n                    if rnum == 0 and getattr(role.action, \"name\", \"\") == SimpleWriteCode.name:\n                        response = await role.act(initial_msg)\n                    else:\n                        candidates = self.env.get_messages_for_role(role)\n                        if not candidates:\n                            continue\n                        # Act on the most recent relevant message\n                        response = await role.act(candidates[-1])\n\n                    if response:\n                        # ensure cause_by present\n                        try:\n                            if not getattr(response, \"cause_by\", None):\n                                response.cause_by = getattr(role.action, \"name\", \"\") or \"\"\n                        except Exception:\n                            pass\n                        self.env.publish_message(response)\n                except Exception as e:\n                    _safe_log(self.tracer, \"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"{e}\")\n                    # continue with next role despite errors\n                    continue\n            _safe_log(self.tracer, \"ROUND_END\", \"Team\", f\"round={rnum+1} completed\")\n\n        _safe_log(self.tracer, \"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        _safe_log(self.tracer, \"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 3.2125, Type: Migrant)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"\n    Robust helper to construct Message objects across pydantic/fallback implementations.\n    \"\"\"\n    try:\n        return Message(\n            content=_safe_str(content),\n            role=role,\n            cause_by=cause_by or \"\",\n            sent_from=sent_from,\n            instruct_content=instruct_content\n        )\n    except Exception:\n        # Fallback to minimal object compatible with Environment expectations\n        class _M:\n            pass\n        m = _M()\n        m.id = str(uuid.uuid4())\n        m.content = _safe_str(content)\n        m.instruct_content = instruct_content\n        m.role = role\n        m.cause_by = cause_by or \"\"\n        m.sent_from = sent_from\n        m.sent_to = None\n        m.send_to = set()\n        return m\n\nclass Action(ABC):\n    \"\"\"Base action with safe logging and lazy LLM access\"\"\"\n    name: str = \"Action\"\n    \n    def __init__(self, **kwargs):\n        self.context: Optional[Context] = kwargs.get('context')\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, etype: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(etype, self.name, details)\n            except Exception:\n                pass\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write clean, functional Python code\\n\"\n            \"2. Include proper error handling\\n\"\n            \"3. Add comments explaining the logic\\n\"\n            \"4. Make it production-ready\\n\\n\"\n            \"Please provide only the code without any explanation.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = (\n                    f\"# Implementation for: {idea}\\n\"\n                    \"def solution():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(_safe_str(code))} characters of code\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", \"Writing tests for code\")\n        prompt = (\n            \"You are a QA engineer. Write comprehensive tests for the following code:\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write pytest-style test cases\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Include both positive and negative tests\\n\"\n            \"4. Add docstrings to explain what each test does\\n\\n\"\n            \"Please provide only the test code without any explanation.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(_safe_str(tests))} characters of tests\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = bool(is_human)\n    \n    async def run(self, code: str, tests: str) -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling and more edge-case tests.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Review the following code and tests:\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Provide a brief review focusing on:\\n\"\n                    \"1. Code quality and best practices\\n\"\n                    \"2. Test coverage\\n\"\n                    \"3. Potential bugs or issues\\n\"\n                    \"4. Suggestions for improvement\\n\\n\"\n                    \"Keep your review concise and actionable.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt},\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Structure is reasonable; add more edge-case handling and clearer error messages.\"\n        except Exception as e:\n            review = f\"Error during review: {e}\"\n        self._log(\"ACTION_END\", f\"Review completed: {len(_safe_str(review))} characters\")\n        return _safe_str(review)\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with simplified routing\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context: Optional[Context] = kwargs.get('context')\n        self.is_human: bool = bool(kwargs.get('is_human', False))\n        self.actions: List[Action] = []\n        # watch_list stores cause_by names (strings)\n        self.watch_list: Set[str] = set()\n        # reference to the environment (set when hired)\n        self.env: Optional[\"Environment\"] = None\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform and ensure context alignment\"\"\"\n        self.actions = actions or []\n        for a in self.actions:\n            try:\n                a.context = self.context\n            except Exception:\n                pass\n    \n    def _watch(self, actions: List[Type[Action] or str]):\n        \"\"\"Set the actions this role watches for. Accepts types or names.\"\"\"\n        names: Set[str] = set()\n        for a in (actions or []):\n            try:\n                if isinstance(a, str):\n                    names.add(a)\n                elif hasattr(a, 'name'):\n                    names.add(getattr(a, 'name'))\n                elif isinstance(a, type) and hasattr(a, 'name'):\n                    names.add(getattr(a, 'name'))\n                else:\n                    names.add(str(a))\n            except Exception:\n                continue\n        self.watch_list = names\n    \n    def _log(self, etype: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(etype, self.name, details)\n            except Exception:\n                pass\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message.\"\"\"\n        if not self.actions:\n            return None\n        \n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"Executing action: {action_name}\")\n        \n        result = \"\"\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            elif action_name == SimpleWriteTest.name:\n                code_text = \"\"\n                # Prefer code from triggering message if it was produced by coder\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                # Else use the latest code from environment\n                if not code_text and self.env:\n                    try:\n                        code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        if code_msg:\n                            code_text = getattr(code_msg, \"content\", \"\") or code_text\n                    except Exception:\n                        pass\n                # Fallback: use message content if present\n                if not code_text and message:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(code_text)\n\n            elif action_name == SimpleWriteReview.name:\n                tests_text = \"\"\n                code_text = \"\"\n                # Prefer tests from triggering message if it was produced by tester\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or \"\"\n                # Get latest code/tests from environment as needed\n                if self.env:\n                    try:\n                        if not code_text:\n                            code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                            if code_msg:\n                                code_text = getattr(code_msg, \"content\", \"\") or code_text\n                        if not tests_text:\n                            test_msg = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                            if test_msg:\n                                tests_text = getattr(test_msg, \"content\", \"\") or tests_text\n                    except Exception:\n                        pass\n                result = await action.run(code_text or \"\", tests_text or \"\")\n\n            else:\n                # Generic action: pass message content\n                content = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(content)\n        except Exception as e:\n            err = f\"Error executing action {action_name}: {e}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n        \n        response = _make_message(\n            content=result,\n            role=self.profile,\n            cause_by=action_name,\n            sent_from=self.name\n        )\n        self._log(\"ROLE_COMPLETE\", f\"Action completed, message created (cause_by={action_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        # Ensure back-references\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        try:\n            self.history.append(message)\n        except Exception:\n            # Attempt to normalize and append\n            try:\n                m = _make_message(\n                    content=_safe_str(getattr(message, \"content\", message)),\n                    role=_safe_str(getattr(message, \"role\", \"Unknown\")),\n                    cause_by=_safe_str(getattr(message, \"cause_by\", \"\")),\n                    sent_from=_safe_str(getattr(message, \"sent_from\", \"Unknown\"))\n                )\n                self.history.append(m)\n                message = m\n            except Exception:\n                # Give up silently to prevent crashing\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                content_preview = (getattr(message, \"content\", \"\") or \"\")[:100]\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {sender}: {content_preview}\")\n            except Exception:\n                pass\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages: List[Message] = []\n        watch_names = set(getattr(role, \"watch_list\", []) or [])\n        if not watch_names:\n            return relevant_messages\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watch_names:\n                    relevant_messages.append(msg)\n            except Exception:\n                continue\n        return relevant_messages\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Return the most recent message whose cause_by matches cause_name.\"\"\"\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            try:\n                role.context = self.context\n                # Ensure all existing actions carry updated context\n                for a in getattr(role, \"actions\", []) or []:\n                    try:\n                        a.context = self.context\n                    except Exception:\n                        pass\n            except Exception:\n                pass\n            # Provide environment reference so roles can inspect history\n            role.env = self.env\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Each role acts in sequence\n            for role in self.env.roles:\n                response = None\n                # First round: let the coder respond to the user input explicitly\n                if round_num == 0 and isinstance(role, SimpleCoder):\n                    try:\n                        response = await role.act(initial_msg)\n                    except Exception as e:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {e}\")\n                        response = None\n                else:\n                    # Other roles respond to relevant messages\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        try:\n                            response = await role.act(relevant_msgs[-1])  # Act on most recent relevant message\n                        except Exception as e:\n                            if self.tracer:\n                                self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {e}\")\n                            response = None\n                    else:\n                        # No relevant messages; skip\n                        continue\n                \n                if response:\n                    self.env.publish_message(response)\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n### Inspiration 2 (Score: 3.2125, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type, Union\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(value: Optional[str]) -> str:\n    \"\"\"Return a safe string (handles None).\"\"\"\n    return \"\" if value is None else str(value)\n\nclass Action(ABC):\n    \"\"\"Base action class with simple, robust LLM handling.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, *, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLM interface if available.\"\"\"\n        if self._llm is None and self.context and getattr(self.context, \"config\", None):\n            try:\n                cfg = self.context.config.llm\n                if cfg:\n                    self._llm = LLMInterface(cfg)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        if self.context and getattr(self.context, \"tracer\", None):\n            try:\n                self.context.tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                # Swallow tracer errors to minimize failure modes\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a string.\"\"\"\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code from a short idea/instruction.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"idea_len={len(idea)}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce a concise, correct Python implementation for the task below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clear, maintainable code\\n\"\n            \"- Basic error handling\\n\"\n            \"- Short comments where helpful\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                # Deterministic fallback to reduce flakiness\n                code = (\"# Placeholder implementation\\n\"\n                        \"def solution():\\n\"\n                        \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                        \"    try:\\n\"\n                        \"        return None\\n\"\n                        \"    except Exception as e:\\n\"\n                        \"        raise\\n\")\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n            self._log(\"ACTION_ERROR\", f\"code_error={e}\")\n        self._log(\"ACTION_END\", f\"code_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest tests for given code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        code_snip = _safe_str(code)[:4000]\n        self._log(\"ACTION_START\", f\"code_snip_len={len(code_snip)}\")\n        prompt = (\n            \"You are a QA engineer. Write pytest tests for the implementation below.\\n\\n\"\n            f\"{code_snip}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest\\n\"\n            \"- Cover common and edge cases\\n\"\n            \"- Provide short docstrings for tests\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\"import pytest\\n\\n\"\n                         \"def test_placeholder():\\n\"\n                         \"    \\\"\\\"\\\"Placeholder positive test.\\\"\\\"\\\"\\n\"\n                         \"    assert True\\n\")\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n            self._log(\"ACTION_ERROR\", f\"test_error={e}\")\n        self._log(\"ACTION_END\", f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and return concise feedback.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str, tests: str) -> str:\n        code_snip = _safe_str(code)[:2000]\n        tests_snip = _safe_str(tests)[:2000]\n        self._log(\"ACTION_START\", f\"code_len={len(code_snip)} tests_len={len(tests_snip)} human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Looks reasonable. Consider adding edge-case tests and more explicit error handling.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Provide a concise review of code and tests below, focusing on:\\n\"\n                \"readability, correctness, test coverage, potential bugs, and improvements.\\n\\n\"\n                f\"Code:\\n{code_snip}\\n\\nTests:\\n{tests_snip}\\n\\n\"\n                \"Keep the review short and actionable.\"\n            )\n            messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                        {\"role\": \"user\", \"content\": prompt}]\n            try:\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Structure looks fine. Add more negative tests and clarify docstrings.\"\n            except Exception as e:\n                review = f\"Review error: {e}\"\n                self._log(\"ACTION_ERROR\", f\"review_error={e}\")\n        self._log(\"ACTION_END\", f\"review_len={len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"General agent role that holds actions and reacts to environment messages.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n\n    def __init__(self, *, name: Optional[str] = None, profile: Optional[str] = None, context: Optional[Context] = None, env: Optional[\"Environment\"] = None, is_human: bool = False):\n        self.name = name or self.name\n        self.profile = profile or self.profile\n        self.context = context\n        self.env = env\n        self.is_human = is_human\n        self.actions: List[Action] = []\n        # watch_list contains cause_by strings this role should respond to\n        self.watch_list: List[str] = []\n\n    def set_actions(self, actions: List[Action]):\n        # bind context to actions for consistent logging/LLM usage\n        for a in actions:\n            if getattr(a, \"context\", None) is None:\n                a.context = self.context\n        self.actions = actions\n\n    def _watch(self, actions: List[Union[Type[Action], str]]):\n        names: List[str] = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"__name__\"):\n                names.append(a.__name__)\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        if self.context and getattr(self.context, \"tracer\", None):\n            try:\n                self.context.tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action for this role using a straightforward, safe policy.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_NOP\", \"No actions assigned\")\n            return None\n\n        action = self.actions[0]\n        self._log(\"ROLE_ACT\", f\"action={action.name} msg_id={getattr(message, 'id', None)}\")\n        try:\n            # Routing by action name keeps behavior explicit and simple\n            if action.name == SimpleWriteCode.name:\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\")\n                result = await action.run(idea or \"\")\n            elif action.name == SimpleWriteTest.name:\n                # Prefer code from the triggering message; fallback to latest code in env\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                elif self.env:\n                    latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                result = await action.run(code_text or \"\")\n            elif action.name == SimpleWriteReview.name:\n                # Gather latest code and tests from environment\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                    code_text = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                    tests_text = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                # allow message to override tests\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or tests_text\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            else:\n                # Generic fallback: pass message content or empty string\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            err = f\"Action {action.name} failed: {e}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        # Construct a Message response compatible with both pydantic and fallback Message\n        try:\n            response = Message(\n                content=result,\n                role=self.profile,\n                cause_by=getattr(action, \"name\", \"Action\"),\n                sent_from=self.name\n            )\n        except Exception:\n            # Fallback minimal message-like object\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = None\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n            response = _M(result, self.profile, getattr(action, \"name\", \"Action\"), self.name)\n\n        self._log(\"ROLE_COMPLETE\", f\"produced_len={len(_safe_str(getattr(response, 'content', '')))} cause_by={getattr(response, 'cause_by', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # triggered by user input\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Simple environment storing messages and coordinating roles.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        # Append message and log safely\n        try:\n            self.history.append(message)\n        except Exception:\n            # Try wrapping into minimal Message if append fails\n            try:\n                m = Message(content=str(getattr(message, \"content\", \"\")), role=getattr(message, \"role\", \"System\"), cause_by=getattr(message, \"cause_by\", \"\"))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                snippet = (_safe_str(getattr(message, \"content\", \"\"))[:100])\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From={sender} cause={getattr(message, 'cause_by', '')} snippet={snippet}\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any name in role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        results: List[Message] = []\n        watched = set(role.watch_list or [])\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    results.append(msg)\n            except Exception:\n                continue\n        return results\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles working on an idea.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Add roles to the team and bind context/env.\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            # Ensure actions use the team's context\n            for a in getattr(role, \"actions\", []):\n                if getattr(a, \"context\", None) is None:\n                    a.context = self.context\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        if self.tracer:\n            self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        if self.tracer:\n            self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        # initial user message\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        # deterministic order: coder, tester, reviewer (preserve hiring order if different)\n        for round_num in range(n_round):\n            if self.tracer:\n                self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            for role in list(self.env.roles):\n                try:\n                    # first round: allow coder(s) to respond to initial instruction\n                    if round_num == 0 and any(a.name == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial_msg)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        # act on the most recent relevant message\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"TEAM_ROLE_ERROR\", role.name, f\"{e}\")\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    # Ensure cause_by exists\n                    if not getattr(response, \"cause_by\", None):\n                        response.cause_by = getattr(role.actions[0], \"name\", \"UnknownAction\") if role.actions else \"UnknownAction\"\n                    self.env.publish_message(response)\n            if self.tracer:\n                self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n\n        if self.tracer:\n            self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n### Inspiration 3 (Score: 3.2125, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Safe conversion to string.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event_type: str, agent: str, details: str):\n    \"\"\"Best-effort logging that never raises.\"\"\"\n    if tracer:\n        try:\n            tracer.log(event_type, agent, _safe_str(details))\n        except Exception:\n            pass\n\ndef make_message(content: str, role: str, cause_by: str, sent_from: str, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance compatible with both pydantic and fallback implementations.\"\"\"\n    kwargs = {\n        \"content\": _safe_str(content),\n        \"role\": role,\n        \"cause_by\": _safe_str(cause_by),\n        \"sent_from\": sent_from\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    try:\n        return Message(**kwargs)\n    except Exception:\n        # Fallback positional/flexible constructor\n        try:\n            return Message(kwargs[\"content\"], kwargs[\"role\"],\n                           instruct_content=kwargs.get(\"instruct_content\"),\n                           cause_by=kwargs[\"cause_by\"],\n                           sent_from=kwargs[\"sent_from\"])\n        except Exception:\n            # Last resort: minimal object with expected attributes\n            class _SimpleMsg:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n                def __str__(self):\n                    return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n            return _SimpleMsg(kwargs[\"content\"], kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Base action class with simple, robust initialization.\"\"\"\n    name: str = \"Action\"\n    \n    def __init__(self, **kwargs):\n        self.context: Optional[Context] = kwargs.get(\"context\")\n        self.llm: Optional[LLMInterface] = None\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError(\"Action.run must be implemented by subclasses\")\n    \n    async def execute(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> str:\n        \"\"\"\n        Map message/env to the appropriate arguments for run().\n        Centralizes mapping to reduce duplication and failure surface.\n        \"\"\"\n        try:\n            aname = getattr(self, \"name\", \"\") or self.__class__.__name__\n            if aname == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                return await self.run(idea)\n            if aname == SimpleWriteTest.name:\n                code = \"\"\n                # prefer explicit code from triggering message\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code = getattr(message, \"content\", \"\") or \"\"\n                # else fallback to latest code from environment\n                if not code and env:\n                    m = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(m, \"content\", \"\") if m else \"\"\n                return await self.run(code)\n            if aname == SimpleWriteReview.name:\n                # reviewer prefers env-sourced latest code/tests\n                code = \"\"\n                tests = \"\"\n                if env:\n                    mc = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    mt = env.get_latest_message_by_cause(SimpleWriteTest.name)\n                    code = getattr(mc, \"content\", \"\") if mc else \"\"\n                    tests = getattr(mt, \"content\", \"\") if mt else \"\"\n                # allow message to override tests if provided\n                if message and getattr(message, \"content\", \"\"):\n                    tests = getattr(message, \"content\", \"\") or tests\n                return await self.run(code, tests)\n            # generic fallback\n            payload = getattr(message, \"content\", \"\") if message else \"\"\n            return await self.run(payload)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_EXCEPTION\", getattr(self, \"name\", \"Action\"), _safe_str(e))\n            return f\"Error executing {getattr(self, 'name', 'Action')}: {e}\"\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str = \"\") -> str:\n        idea_text = _safe_str(idea).strip()\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"Writing code for: {idea_text[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea_text}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nPlease provide only the code without any explanation.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                # Deterministic, useful fallback\n                code = (\n                    f\"# Implementation for: {idea_text}\\n\"\n                    \"def placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'ok'\\n\"\n                    \"    except Exception as exc:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"Generated {len(_safe_str(code))} characters of code\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str = \"\") -> str:\n        code_text = _safe_str(code)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        snippet = code_text[:2000] if code_text else \"# No code provided\"\n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{snippet}\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nPlease provide only the test code without any explanation.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"Generated {len(_safe_str(tests))} characters of tests\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = bool(is_human)\n    \n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code_text = _safe_str(code)\n        tests_text = _safe_str(tests)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n            else:\n                prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{code_text[:1500]}\n\nTests:\n{tests_text[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n                \n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                \n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Review: Code structure looks reasonable. Tests cover main functionality; add more edge cases.\"\n        except Exception as e:\n            review = f\"Error during review generation: {e}\"\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"Review completed: {len(_safe_str(review))} characters\")\n        return _safe_str(review)\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with simplified action handling\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context: Optional[Context] = kwargs.get('context')\n        self.is_human: bool = bool(kwargs.get('is_human', False))\n        # actions stored as instances for simplicity\n        self.actions: List[Action] = []\n        # watch_list stores action names (strings) for simpler comparisons\n        self.watch_list: List[str] = []\n        # environment reference set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform (ensure action contexts are aligned)\"\"\"\n        self.actions = actions or []\n        for a in self.actions:\n            a.context = self.context\n            try:\n                if self.context and getattr(self.context, \"config\", None):\n                    a.llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                a.llm = None\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for. Accept types or names.\"\"\"\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type) and hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n        self.watch_list = names\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action based on a message.\"\"\"\n        if not self.actions:\n            return None\n        \n        action = self.actions[0]\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ACT\", self.name, f\"Executing action: {getattr(action, 'name', 'Action')}\")\n        \n        try:\n            result = await action.execute(message=message, env=self.env)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, f\"Exception during act: {_safe_str(e)}\")\n            result = f\"Error in role {self.name}: {e}\"\n        \n        response = make_message(\n            content=result,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"\"),\n            sent_from=self.name\n        )\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_COMPLETE\", self.name, \"Action completed, message created\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # create action instances with given context\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watch by action name to avoid fragile type checks\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        role.env = self\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return list(self.roles)\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        # Ensure message has at least expected attributes\n        try:\n            if not hasattr(message, \"id\"):\n                message.id = str(uuid.uuid4())\n        except Exception:\n            pass\n        self.history.append(message)\n        try:\n            preview = (getattr(message, \"content\", \"\") or \"\")[:100]\n        except Exception:\n            preview = \"\"\n        _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"Message from {getattr(message, 'sent_from', 'unknown')}: {preview}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages: List[Message] = []\n        watched = set(role.watch_list or [])\n        if not watched:\n            return relevant_messages\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    relevant_messages.append(msg)\n            except Exception:\n                continue\n        return relevant_messages\n    \n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Return the most recent message with matching cause_by\"\"\"\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team and ensure contexts for role actions are aligned\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env  # allow roles to inspect environment history\n            if hasattr(role, \"actions\"):\n                for a in role.actions:\n                    a.context = self.context\n                    try:\n                        a.llm = LLMInterface(self.context.config.llm)\n                    except Exception:\n                        a.llm = None\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Each role acts in sequence\n            for role in list(self.env.roles):\n                response: Optional[Message] = None\n                try:\n                    if round_num == 0 and isinstance(role, SimpleCoder):\n                        # Coder responds to initial message\n                        response = await role.act(initial_msg)\n                    else:\n                        # Other roles respond to relevant messages\n                        relevant_msgs = self.env.get_messages_for_role(role)\n                        if not relevant_msgs:\n                            continue\n                        response = await role.act(relevant_msgs[-1])\n                except Exception as e:\n                    self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"{e}\")\n                    response = None\n                \n                if response:\n                    self.env.publish_message(response)\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n### Inspiration 4 (Score: 3.2125, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a stable string representation, avoiding exceptions.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Robust helper to construct Message objects compatible with both pydantic and fallback Message.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        # Preferred: named constructor (works with pydantic Message)\n        return Message(content=content, instruct_content=instruct_content, role=role, cause_by=cause_by, sent_from=sent_from)\n    except Exception:\n        try:\n            # Fallback: positional constructor for legacy Message\n            return Message(content, role, instruct_content=instruct_content, cause_by=cause_by, sent_from=sent_from)\n        except Exception:\n            # Last resort: create a minimal object with required attributes\n            class _SimpleMsg:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n            return _SimpleMsg(content, role, cause_by, sent_from, instruct_content)\n\nclass Action(ABC):\n    \"\"\"Minimal, robust action base class with safe logging and optional LLM.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLM interface if available in context; safe and idempotent\"\"\"\n        if self._llm is None and self.context:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are an expert Python programmer. Write concise, correct Python code that fulfills the request.\\n\\n\"\n            f\"Task:\\n{idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\nReturn only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                code = resp or \"\"\n            else:\n                # Deterministic fallback\n                code = (\n                    f\"# Implementation for: {idea}\\n\\n\"\n                    \"def placeholder_function():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n            self._log(\"ACTION_ERROR\", f\"{e}\")\n        code = _safe_str(code)\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", \"Writing tests\")\n        prompt = (\n            \"You are an expert QA engineer. Given the implementation, write pytest tests (positive and negative).\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\nReturn only test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = resp or \"\"\n            else:\n                tests = \"import pytest\\n\\ndef test_placeholder():\\n    assert True\\n\"\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n            self._log(\"ACTION_ERROR\", f\"{e}\")\n        tests = _safe_str(tests)\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)[:1500]\n        tests = _safe_str(tests)[:1500]\n        self._log(\"ACTION_START\", f\"Reviewing (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider additional error checks and clearer docstrings.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Provide a concise review and actionable suggestions.\\n\\n\"\n                    f\"Code:\\n{code}\\n\\nTests:\\n{tests}\\n\\nBe concise.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = resp or \"Automated review: Acceptable structure; consider more tests.\"\n                else:\n                    review = \"Automated review: Acceptable structure; consider more edge-case tests.\"\n        except Exception as e:\n            review = f\"Review error: {e}\"\n            self._log(\"ACTION_ERROR\", f\"{e}\")\n        review = _safe_str(review)\n        self._log(\"ACTION_END\", f\"Review length {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simple role with predictable behavior and minimal mutable state.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n\n    def __init__(self, name: Optional[str] = None, profile: Optional[str] = None, context: Optional[Context] = None, is_human: bool = False):\n        self.name = name or self.name\n        self.profile = profile or self.profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list stores action names\n        self.watch_list: List[str] = []\n        # environment reference set when hired\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        prepared = []\n        for a in actions or []:\n            try:\n                a.context = self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action]]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                try:\n                    names.append(getattr(a, \"name\"))\n                except Exception:\n                    names.append(str(a))\n            elif hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"__name__\"))\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    def _select_action(self, message: Optional[Message]) -> Optional[Action]:\n        if not self.actions:\n            return None\n        # Prefer explicit instruction -> coder\n        if message and getattr(message, \"instruct_content\", None):\n            for action in self.actions:\n                if action.name == SimpleWriteCode.name:\n                    return action\n        # Map cause to action\n        cause = getattr(message, \"cause_by\", \"\") if message else \"\"\n        if cause:\n            if cause == SimpleWriteCode.name:\n                for action in self.actions:\n                    if action.name == SimpleWriteTest.name:\n                        return action\n            if cause == SimpleWriteTest.name:\n                for action in self.actions:\n                    if action.name == SimpleWriteReview.name:\n                        return action\n        # Default fallback\n        return self.actions[0]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        self._log(\"ROLE_ACT\", f\"Acting on message id={getattr(message, 'id', None)}\")\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions\")\n            return None\n\n        action = self._select_action(message)\n        if not action:\n            self._log(\"ROLE_SKIP\", \"No action selected\")\n            return None\n\n        result = \"\"\n        try:\n            if action.name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n            elif action.name == SimpleWriteTest.name:\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                else:\n                    # find last code in env\n                    try:\n                        if self.env:\n                            for m in reversed(self.env.history):\n                                if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                    code_text = getattr(m, \"content\", \"\") or \"\"\n                                    break\n                    except Exception:\n                        code_text = \"\"\n                result = await action.run(code_text)\n            elif action.name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                # Prefer message content if it matches cause_by\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                        code_text = getattr(message, \"content\", \"\") or \"\"\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                        tests_text = getattr(message, \"content\", \"\") or \"\"\n                # fill missing from env\n                try:\n                    if self.env:\n                        if not code_text:\n                            for m in reversed(self.env.history):\n                                if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                    code_text = getattr(m, \"content\", \"\") or \"\"\n                                    break\n                        if not tests_text:\n                            for m in reversed(self.env.history):\n                                if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name:\n                                    tests_text = getattr(m, \"content\", \"\") or \"\"\n                                    break\n                except Exception:\n                    pass\n                # ensure human flag propagation\n                if isinstance(action, SimpleWriteReview):\n                    action.is_human = self.is_human\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic single-argument fallback\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            self._log(\"ROLE_ERROR\", f\"{action.name} failed: {e}\")\n            result = f\"Error executing action {action.name}: {e}\"\n\n        response = _make_message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"{action.name} produced message id={getattr(response, 'id', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Alice\")\n        profile = kwargs.get('profile', \"SimpleCoder\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # listens to user instructions\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Bob\")\n        profile = kwargs.get('profile', \"SimpleTester\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Charlie\")\n        profile = kwargs.get('profile', \"SimpleReviewer\")\n        context = kwargs.get('context')\n        is_human = kwargs.get('is_human', False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        \"\"\"Add role and wire context/env references\"\"\"\n        try:\n            role.env = self\n            if getattr(role, \"context\", None) is None:\n                role.context = Context()\n            # Ensure actions know the updated context\n            for a in getattr(role, \"actions\", []) or []:\n                try:\n                    a.context = role.context\n                except Exception:\n                    pass\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment; must be robust.\"\"\"\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                content_preview = (_safe_str(getattr(message, \"content\", \"\")) or \"\")[:100]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {sender} (cause={cause}): {content_preview}\")\n        except Exception as e:\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", f\"Failed to publish message: {e}\")\n                except Exception:\n                    pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any name in role.watch_list.\"\"\"\n        if not getattr(role, \"watch_list\", None):\n            return []\n        watched = set(role.watch_list)\n        results: List[Message] = []\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    results.append(m)\n            except Exception:\n                continue\n        return results\n\nclass Team:\n    \"\"\"Team of agents working together. Simplified, robust orchestration.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        # expose env in context for convenience\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in roles or []:\n            try:\n                r.context = self.context\n                r.env = self.env\n                # ensure actions contexts are aligned\n                for a in getattr(r, \"actions\", []) or []:\n                    try:\n                        a.context = self.context\n                    except Exception:\n                        pass\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea or \"\"\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        for round_num in range(n_round):\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    if round_num == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial_msg)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1])\n                        else:\n                            continue\n                except Exception as e:\n                    try:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"Exception while acting: {e}\")\n                    except Exception:\n                        pass\n                    continue\n\n                if response:\n                    # best-effort ensure cause_by exists\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"UnknownAction\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            except Exception:\n                pass\n\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n\n        try:\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            if self.tracer:\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n### Inspiration 5 (Score: 3.2125, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type, Union\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(value: Any) -> str:\n    \"\"\"Return a stable string representation without raising.\"\"\"\n    try:\n        if value is None:\n            return \"\"\n        if isinstance(value, str):\n            return value\n        return str(value)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Robustly construct a Message-like object. Tries the project's Message class first,\n    falls back to a minimal object that has the expected attributes.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        return Message(content=content, instruct_content=instruct_content, role=role, cause_by=cause_by or \"\", sent_from=sent_from)\n    except Exception:\n        class Minimal:\n            pass\n        m = Minimal()\n        m.id = str(uuid.uuid4())\n        m.content = content\n        m.instruct_content = instruct_content\n        m.role = role\n        m.cause_by = cause_by or \"\"\n        m.sent_from = sent_from\n        m.sent_to = None\n        m.send_to = set()\n        return m\n\nclass Action(ABC):\n    \"\"\"Base action with lazy LLM init and safe logging to reduce failure modes.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, *, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLMInterface; swallow exceptions.\"\"\"\n        if self._llm is None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                # Do not propagate tracer errors\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code given an idea or instruction.\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"idea_len={len(idea)}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the following task.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short explanatory comments\\n\\nReturn only the code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                code = _safe_str(resp)\n            else:\n                # Deterministic fallback to minimize variability\n                code = (\n                    f\"# Placeholder implementation for: {idea}\\n\\n\"\n                    \"def solution(*args, **kwargs):\\n\"\n                    \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"code_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"code_len={len(code)}\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for provided code.\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        code_text = _safe_str(code)[:4000]\n        self._log(\"ACTION_START\", f\"code_snip_len={len(code_text)}\")\n        prompt = (\n            \"You are an expert QA engineer. Write pytest tests for the implementation below.\\n\\n\"\n            f\"{code_text}\\n\\n\"\n            \"Requirements:\\n- Use pytest\\n- Cover typical and edge cases\\n- Short docstrings for tests\\n\\nReturn only test code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = _safe_str(resp)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder positive test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"test_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"tests_len={len(tests)}\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and produce concise feedback.\"\"\"\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str, tests: str) -> str:\n        code_text = _safe_str(code)[:2000]\n        tests_text = _safe_str(tests)[:2000]\n        self._log(\"ACTION_START\", f\"code_len={len(code_text)} tests_len={len(tests_text)} human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Looks reasonable. Consider adding edge-case tests and more explicit error handling.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Provide a concise, actionable review of the code and tests below.\\n\\n\"\n                f\"Code:\\n{code_text}\\n\\nTests:\\n{tests_text}\\n\\nFocus on readability, correctness, coverage, and improvements. Keep it short.\"\n            )\n            messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                        {\"role\": \"user\", \"content\": prompt}]\n            try:\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = _safe_str(resp)\n                else:\n                    review = \"Automated review: Structure acceptable; add more negative tests and clearer error handling.\"\n            except Exception as e:\n                review = f\"Review error: {_safe_str(e)}\"\n                self._log(\"ACTION_ERROR\", f\"review_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"review_len={len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Agent role: holds actions, reacts deterministically to messages, minimal mutable state.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n\n    def __init__(self, *, name: Optional[str] = None, profile: Optional[str] = None, context: Optional[Context] = None, env: Optional[\"Environment\"] = None, is_human: bool = False):\n        self.name = name or self.name\n        self.profile = profile or self.profile\n        self.context = context\n        self.env = env\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list: names of action outputs (cause_by) this role cares about\n        self.watch_list: List[str] = []\n\n    def set_actions(self, actions: List[Action]):\n        # ensure action context bound\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                if getattr(a, \"context\", None) is None:\n                    a.context = self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Union[Type[Action], str]]):\n        names: List[str] = []\n        for a in (actions or []):\n            try:\n                if isinstance(a, str):\n                    names.append(a)\n                elif hasattr(a, \"name\"):\n                    names.append(getattr(a, \"name\"))\n                elif hasattr(a, \"__name__\"):\n                    names.append(getattr(a, \"__name__\"))\n            except Exception:\n                continue\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Deterministic routing: coder handles user instructions; tester reacts to coder outputs; reviewer reacts to tests.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_NOP\", \"No actions assigned\")\n            return None\n\n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"action={action_name} msg_id={getattr(message, 'id', None)}\")\n\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(idea or \"\")\n            elif action_name == SimpleWriteTest.name:\n                code_text = \"\"\n                # prefer code from message if it's from coder\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code_text or \"\")\n            elif action_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                        tests_text = getattr(message, \"content\", \"\") or \"\"\n                if self.env:\n                    if not code_text:\n                        latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code_text = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                    if not tests_text:\n                        latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        tests_text = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            err = f\"Action {action_name} failed: {_safe_str(e)}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        response = _make_message(content=result, role=self.profile, cause_by=action_name, sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"produced_len={len(_safe_str(getattr(response, 'content', '')))} cause_by={getattr(response, 'cause_by', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # listens to explicit user instruction\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment storing roles and message history with robust operations.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        try:\n            self.history.append(message)\n        except Exception:\n            try:\n                m = _make_message(content=_safe_str(getattr(message, \"content\", message)), role=_safe_str(getattr(message, \"role\", \"System\")), cause_by=_safe_str(getattr(message, \"cause_by\", \"\")), sent_from=_safe_str(getattr(message, \"sent_from\", \"System\")))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                snippet = _safe_str(getattr(message, \"content\", \"\"))[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From={sender} cause={cause} snippet={snippet}\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        if not role.watch_list:\n            return []\n        res: List[Message] = []\n        watched = set(role.watch_list or [])\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    res.append(m)\n            except Exception:\n                continue\n        return res\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles and rounds with deterministic, safe execution to reduce failures.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in (roles or []):\n            try:\n                r.context = self.context\n                for a in getattr(r, \"actions\", []) or []:\n                    if getattr(a, \"context\", None) is None:\n                        a.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        initial = _make_message(content=f\"Let's work on this project: {self.idea}\", instruct_content=self.idea, role=\"Human\", sent_from=\"User\", cause_by=\"UserInput\")\n        self.env.publish_message(initial)\n\n        for rnum in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnum+1}/{n_round}\")\n                except Exception:\n                    pass\n\n            # iterate over a stable snapshot of roles\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # allow coder(s) to respond to initial instruction in first round\n                    if rnum == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_EXCEPTION\", role.name, _safe_str(e))\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role.actions[0], \"name\", \"UnknownAction\") if role.actions else \"UnknownAction\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnum+1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n                summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n\n# Current Program\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a stable string representation, avoiding exceptions.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: str = \"System\") -> Message:\n    \"\"\"Construct a Message instance robustly for both pydantic and fallback Message classes.\"\"\"\n    content = _safe_str(content)\n    try:\n        # Preferred: named constructor (works with pydantic Message)\n        return Message(content=content, instruct_content=None, role=role, cause_by=cause_by, sent_from=sent_from)\n    except Exception:\n        try:\n            # Fallback: positional constructor for legacy Message\n            return Message(content, role, instruct_content=None, cause_by=cause_by, sent_from=sent_from)\n        except Exception:\n            # Last resort: create a minimal object with required attributes\n            class _SimpleMsg:\n                def __init__(self, content, role, cause_by, sent_from):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = None\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n            return _SimpleMsg(content, role, cause_by, sent_from)\n\nclass Action(ABC):\n    \"\"\"Minimal, robust action base class with safe logging and optional LLM.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self.llm: Optional[LLMInterface] = None\n        try:\n            if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n                self.llm = LLMInterface(self.context.config.llm)\n        except Exception:\n            self.llm = None\n\n    def _log(self, event: str, details: str):\n        try:\n            if self.context and getattr(self.context, \"tracer\", None):\n                self.context.tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n        except Exception:\n            # Logging must not raise\n            pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write clean, functional Python code\\n\"\n            \"2. Include proper error handling\\n\"\n            \"3. Add comments explaining the logic\\n\"\n            \"4. Make it production-ready\\n\\n\"\n            \"Please provide only the code without any explanation.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                # Deterministic fallback reduces flakiness\n                code = (\n                    f\"# Implementation for: {idea}\\n\"\n                    \"def placeholder_function():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation until LLM available.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n            self._log(\"ACTION_ERROR\", f\"{e}\")\n        code = _safe_str(code)\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        preview = code[:2000]\n        self._log(\"ACTION_START\", \"Writing tests for code\")\n        prompt = (\n            \"You are a QA engineer. Write comprehensive tests for the following code:\\n\\n\"\n            f\"Code:\\n{preview}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write pytest-style test cases\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Include both positive and negative tests\\n\"\n            \"4. Add docstrings to explain what each test does\\n\\n\"\n            \"Please provide only the test code without any explanation.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test until LLM available.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n            self._log(\"ACTION_ERROR\", f\"{e}\")\n        tests = _safe_str(tests)\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider additional error checks and clearer docstrings.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Review the following code and tests:\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Provide a brief review focusing on:\\n\"\n                    \"1. Code quality and best practices\\n\"\n                    \"2. Test coverage\\n\"\n                    \"3. Potential bugs or issues\\n\"\n                    \"4. Suggestions for improvement\\n\\n\"\n                    \"Keep your review concise and actionable.\"\n                )\n                messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                            {\"role\": \"user\", \"content\": prompt}]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Review: Code structure OK. Tests cover basics; consider more edge cases.\"\n        except Exception as e:\n            review = f\"Error during review: {e}\"\n            self._log(\"ACTION_ERROR\", f\"{e}\")\n        review = _safe_str(review)\n        self._log(\"ACTION_END\", f\"Review completed ({len(review)} chars)\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simple role with predictable behavior and minimal mutable state.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n\n    def __init__(self, name: Optional[str] = None, profile: Optional[str] = None, context: Optional[Context] = None, is_human: bool = False):\n        self.name = name or self.name\n        self.profile = profile or self.profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list stores action names to avoid type matching complexity\n        self.watch_list: List[str] = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # ensure actions know current context\n        prepared = []\n        for a in actions or []:\n            try:\n                a.context = self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action]]):\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                try:\n                    names.append(getattr(a, \"name\"))\n                except Exception:\n                    names.append(str(a))\n            elif isinstance(a, type):\n                names.append(getattr(a, \"name\", a.__name__))\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        try:\n            if self.context and getattr(self.context, \"tracer\", None):\n                self.context.tracer.log(event, self.name, details)\n        except Exception:\n            pass\n\n    async def act(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> Optional[Message]:\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        env = env or self.env\n        self._log(\"ROLE_ACT\", f\"Executing action: {getattr(action, 'name', 'Action')} message_id={getattr(message, 'id', None)}\")\n\n        result = \"\"\n        try:\n            # Map action by name (simple and robust)\n            act_name = getattr(action, \"name\", \"\")\n            if act_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            elif act_name == SimpleWriteTest.name:\n                # Prefer message (likely code), else lookup latest code in env\n                code_text = \"\"\n                if message and getattr(message, \"content\", None):\n                    code_text = getattr(message, \"content\")\n                elif env:\n                    for m in reversed(env.history):\n                        if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name and getattr(m, \"content\", None):\n                            code_text = getattr(m, \"content\", \"\")\n                            break\n                result = await action.run(code_text)\n\n            elif act_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if message:\n                    # If the triggering message is tests, prefer that\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                        tests_text = getattr(message, \"content\", \"\") or \"\"\n                    elif getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                        code_text = getattr(message, \"content\", \"\") or \"\"\n                # Fill missing pieces from env\n                if env:\n                    if not code_text:\n                        for m in reversed(env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = getattr(m, \"content\", \"\") or code_text\n                                break\n                    if not tests_text:\n                        for m in reversed(env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name:\n                                tests_text = getattr(m, \"content\", \"\") or tests_text\n                                break\n                # propagate human flag if possible\n                if isinstance(action, SimpleWriteReview):\n                    action.is_human = self.is_human\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic fallback: attempt to pass message content\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            err = f\"Error executing action {getattr(action, 'name', '')}: {e}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        # Build response message robustly\n        try:\n            response = _make_message(content=_safe_str(result), role=self.profile, cause_by=getattr(action, \"name\", \"\"), sent_from=self.name)\n        except Exception:\n            # As a last resort, return None (shouldn't happen)\n            self._log(\"ROLE_ERROR\", \"Failed to create response message\")\n            return None\n\n        self._log(\"ROLE_COMPLETE\", f\"Action completed, message created (cause_by={getattr(action, 'name', '')})\")\n        return response\n\nclass SimpleCoder(Role):\n    name = \"Alice\"\n    profile = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(name=kwargs.get(\"name\", \"Alice\"), profile=kwargs.get(\"profile\", \"SimpleCoder\"), context=kwargs.get(\"context\"), is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name = \"Bob\"\n    profile = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(name=kwargs.get(\"name\", \"Bob\"), profile=kwargs.get(\"profile\", \"SimpleTester\"), context=kwargs.get(\"context\"), is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    name = \"Charlie\"\n    profile = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(name=kwargs.get(\"name\", \"Charlie\"), profile=kwargs.get(\"profile\", \"SimpleReviewer\"), context=kwargs.get(\"context\"), is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with robust message routing.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        try:\n            role.env = self\n            self.roles.append(role)\n            if self.tracer:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n        except Exception:\n            # avoid raising from add_role\n            pass\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        try:\n            if profile:\n                return [r for r in self.roles if r.profile == profile]\n            return list(self.roles)\n        except Exception:\n            return []\n\n    def publish_message(self, message: Message):\n        \"\"\"Append a message to history and log a short preview; must not raise.\"\"\"\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                content_preview = (_safe_str(getattr(message, \"content\", \"\")) or \"\")[:100]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {sender} (cause={cause}): {content_preview}\")\n        except Exception as e:\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", f\"Failed to publish message: {e}\")\n                except Exception:\n                    pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any name in role.watch_list.\"\"\"\n        results: List[Message] = []\n        try:\n            watched = set(getattr(role, \"watch_list\", []) or [])\n            if not watched:\n                return results\n            for m in self.history:\n                try:\n                    if getattr(m, \"cause_by\", \"\") in watched:\n                        results.append(m)\n                except Exception:\n                    continue\n        except Exception:\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", f\"Error in get_messages_for_role for {getattr(role, 'name', '')}\")\n                except Exception:\n                    pass\n        return results\n\nclass Team:\n    \"\"\"Team of agents working together. Simplified, robust orchestration.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in roles or []:\n            try:\n                r.context = self.context\n                # Recreate or update actions' contexts\n                for a in getattr(r, \"actions\", []) or []:\n                    try:\n                        a.context = self.context\n                        if self.context and getattr(self.context, \"config\", None):\n                            try:\n                                a.llm = LLMInterface(self.context.config.llm)\n                            except Exception:\n                                a.llm = None\n                    except Exception:\n                        pass\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        initial_msg = _make_message(content=f\"Let's work on this project: {self.idea}\", role=\"Human\", cause_by=\"UserInput\", sent_from=\"User\")\n        self.env.publish_message(initial_msg)\n\n        for round_num in range(n_round):\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            # iterate over a snapshot of roles to avoid mutation during iteration\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: let the coder respond to the user input explicitly\n                    if round_num == 0 and getattr(role, \"profile\", \"\") == \"SimpleCoder\":\n                        response = await role.act(initial_msg, env=self.env)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1], env=self.env)\n                        else:\n                            continue\n                except Exception as e:\n                    try:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"Exception while acting: {e}\")\n                    except Exception:\n                        pass\n                    continue\n\n                if response:\n                    try:\n                        # Ensure response has cause_by for routing; best-effort\n                        if not getattr(response, \"cause_by\", None):\n                            try:\n                                response.cause_by = getattr(response, \"cause_by\", \"\")\n                            except Exception:\n                                pass\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            except Exception:\n                pass\n\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        try:\n            if self.tracer:\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Convert to a stable string without raising.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Create a Message object compatible with either pydantic Message or the fallback.\n    Always returns an object with attributes: id, content, instruct_content, role, cause_by, sent_from, sent_to, send_to.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        return Message(content=content, instruct_content=instruct_content, role=role, cause_by=cause_by or \"\", sent_from=sent_from)\n    except Exception:\n        # Fallback minimal message-like object\n        class SimpleMsg:\n            def __init__(self, content, instruct_content, role, cause_by, sent_from):\n                self.id = str(uuid.uuid4())\n                self.content = content\n                self.instruct_content = instruct_content\n                self.role = role\n                self.cause_by = cause_by or \"\"\n                self.sent_from = sent_from\n                self.sent_to = None\n                self.send_to = set()\n            def __str__(self):\n                return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n        return SimpleMsg(content, instruct_content, role, cause_by or \"\", sent_from)\n\nclass Action(ABC):\n    \"\"\"Simplified base action with safe llm access and tracer use.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create an LLMInterface when needed. Fail silently if not possible.\"\"\"\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        try:\n            tracer = getattr(self.context, \"tracer\", None)\n            if tracer:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n        except Exception:\n            # ensure logging never raises\n            pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code for a given idea or instruction.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"code_for_len={len(idea)}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the request below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\nReturn only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n                code = _safe_str(result)\n            else:\n                # deterministic fallback to minimize variability\n                code = (\n                    f\"# Placeholder implementation for: {idea}\\n\"\n                    \"def placeholder_function(*args, **kwargs):\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"code_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"code_len={len(_safe_str(code))}\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest-style tests for provided code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", f\"tests_for_code_len={len(code)}\")\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation below.\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n- Use pytest\\n- Cover typical and edge cases\\n- Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n                tests = _safe_str(result)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder positive test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n            self._log(\"ACTION_ERROR\", f\"test_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"tests_len={len(_safe_str(tests))}\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide a concise review of code and tests.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)[:1500]\n        tests = _safe_str(tests)[:1500]\n        self._log(\"ACTION_START\", f\"review_code_len={len(code)} tests_len={len(tests)} human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Looks reasonable. Consider additional edge-case tests and clearer docstrings.\"\n        else:\n            prompt = (\n                \"You are a senior software engineer. Provide a concise review focusing on readability, correctness, and test coverage.\\n\\n\"\n                f\"Code:\\n{code}\\n\\nTests:\\n{tests}\\n\\nKeep the review short and actionable.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            try:\n                if self.llm:\n                    result = await self.llm.ask(messages)\n                    review = _safe_str(result)\n                else:\n                    review = \"Automated review: Structure acceptable. Add more negative tests and clearer error handling.\"\n            except Exception as e:\n                review = f\"Review error: {_safe_str(e)}\"\n                self._log(\"ACTION_ERROR\", f\"review_error={_safe_str(e)}\")\n        self._log(\"ACTION_END\", f\"review_len={len(_safe_str(review))}\")\n        return _safe_str(review)\n\nclass Role(ABC):\n    \"\"\"A role that holds a primary action and responds deterministically.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # list of cause_by strings this role is interested in\n        self.watch_list: List[str] = []\n        # environment set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                try:\n                    names.append(getattr(a, \"name\"))\n                except Exception:\n                    continue\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                names.append(a.__name__)\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        try:\n            tracer = getattr(self.context, \"tracer\", None)\n            if tracer:\n                tracer.log(event, self.name, details)\n        except Exception:\n            pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action. Simple deterministic mapping based on message cause.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"no_actions\")\n            return None\n\n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"{action_name} message_id={getattr(message, 'id', None)}\")\n\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea or \"\")\n            elif action_name == SimpleWriteTest.name:\n                # prefer code from the triggering message if present\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code_text or \"\")\n            elif action_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or \"\"\n                if self.env:\n                    if not code_text:\n                        latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code_text = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                    if not tests_text:\n                        latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        tests_text = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                # propagate human flag into the action if possible\n                if isinstance(action, SimpleWriteReview):\n                    action.is_human = self.is_human\n                result = await action.run(code_text or \"\", tests_text or \"\")\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            err = f\"Action error: {_safe_str(e)}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        response = _make_message(content=_safe_str(result), role=self.profile, cause_by=action_name, sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"produced (cause_by={action_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # responds to explicit user instruction\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with simple, robust routing.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        try:\n            role.env = self\n            self.roles.append(role)\n            if self.tracer:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n        except Exception:\n            pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message and log a short preview; don't allow exceptions to escape.\"\"\"\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                preview = (_safe_str(getattr(message, \"content\", \"\")) or \"\")[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From={sender} cause={cause} preview={preview}\")\n        except Exception:\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", \"Failed to publish message (suppressed)\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any entry in role.watch_list (chronological).\"\"\"\n        if not role.watch_list:\n            return []\n        watched = set(role.watch_list)\n        out: List[Message] = []\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    out.append(m)\n            except Exception:\n                continue\n        return out\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Return the most recent message with matching cause_by.\"\"\"\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles with deterministic rounds and minimal failure surface.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        try:\n            # convenience reference\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in (roles or []):\n            try:\n                r.context = r.context or self.context\n                r.env = self.env\n                # ensure actions carry the context\n                for a in getattr(r, \"actions\", []) or []:\n                    try:\n                        a.context = a.context or self.context\n                    except Exception:\n                        pass\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        initial_msg = _make_message(content=f\"Let's work on this project: {self.idea}\", instruct_content=self.idea, role=\"Human\", sent_from=\"User\", cause_by=\"UserInput\")\n        self.env.publish_message(initial_msg)\n\n        for rnum in range(n_round):\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnum + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            # iterate over a stable snapshot to avoid concurrent mutation issues\n            for role in list(self.env.roles):\n                try:\n                    response = None\n                    # On first round, prefer coder(s) to handle user instruction\n                    if rnum == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in getattr(role, \"actions\", [])):\n                        response = await role.act(initial_msg)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1])\n                        else:\n                            continue\n\n                    if response:\n                        # best-effort ensure cause_by exists (some fallback message objects may lack it)\n                        try:\n                            if not getattr(response, \"cause_by\", None):\n                                response.cause_by = getattr(response, \"cause_by\", \"\") or \"\"\n                        except Exception:\n                            pass\n                        self.env.publish_message(response)\n                except Exception as e:\n                    try:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                    except Exception:\n                        pass\n                    continue\n\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnum + 1} completed\")\n            except Exception:\n                pass\n\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        try:\n            if self.tracer:\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}