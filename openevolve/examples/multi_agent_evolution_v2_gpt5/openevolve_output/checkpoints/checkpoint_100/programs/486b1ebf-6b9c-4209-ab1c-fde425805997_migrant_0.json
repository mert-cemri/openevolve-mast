{"id": "486b1ebf-6b9c-4209-ab1c-fde425805997_migrant_0", "code": "\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a stable string representation for any input.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event: str, agent: str, details: str):\n    \"\"\"Non-throwing logging helper.\"\"\"\n    if not tracer:\n        return\n    try:\n        tracer.log(event, agent, _safe_str(details))\n    except Exception:\n        pass\n\ndef make_message(content: str,\n                 role: str,\n                 cause_by: str = \"\",\n                 sent_from: Optional[str] = None,\n                 instruct_content: Optional[str] = None) -> Message:\n    \"\"\"\n    Robust factory for Message compatible with both pydantic and fallback Message types.\n    Always returns an object with at least the common attributes.\n    \"\"\"\n    kwargs = {\n        \"content\": _safe_str(content),\n        \"role\": _safe_str(role or \"Unknown\"),\n        \"cause_by\": _safe_str(cause_by or \"\"),\n        \"sent_from\": _safe_str(sent_from) if sent_from is not None else None\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    # Try to construct the project's Message type; fallback to simpler shapes otherwise.\n    try:\n        return Message(**kwargs)  # type: ignore\n    except Exception:\n        try:\n            # For fallback Message signature (content, role, **kwargs)\n            return Message(kwargs[\"content\"], kwargs[\"role\"],\n                           instruct_content=kwargs.get(\"instruct_content\"),\n                           cause_by=kwargs.get(\"cause_by\"),\n                           sent_from=kwargs.get(\"sent_from\"))  # type: ignore\n        except Exception:\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n                def __str__(self):\n                    return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n            return _M(kwargs[\"content\"], kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Simple, resilient Action base. Provides execute() to map inputs deterministically.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create a local LLMInterface if config available; swallow errors.\"\"\"\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        _safe_log(getattr(self.context, \"tracer\", None), event, getattr(self, \"name\", \"Action\"), details)\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\n    async def execute(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> str:\n        \"\"\"\n        One central place to map messages/environment to run() arguments.\n        Keeps behavior predictable and easier to test.\n        \"\"\"\n        try:\n            aname = getattr(self, \"name\", \"\") or self.__class__.__name__\n            if aname == \"SimpleWriteCode\":\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\")\n                return await self.run(_safe_str(idea))\n            if aname == \"SimpleWriteTest\":\n                code = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                    code = getattr(message, \"content\", \"\") or \"\"\n                if not code and env:\n                    latest = env.get_latest_message_by_cause(\"SimpleWriteCode\")\n                    code = getattr(latest, \"content\", \"\") if latest else \"\"\n                return await self.run(_safe_str(code))\n            if aname == \"SimpleWriteReview\":\n                code = \"\"\n                tests = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == \"SimpleWriteTest\":\n                    tests = getattr(message, \"content\", \"\") or \"\"\n                if env:\n                    if not code:\n                        latest_code = env.get_latest_message_by_cause(\"SimpleWriteCode\")\n                        code = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                    if not tests:\n                        latest_tests = env.get_latest_message_by_cause(\"SimpleWriteTest\")\n                        tests = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                return await self.run(_safe_str(code), _safe_str(tests))\n            # Generic fallback: pass message content if present\n            return await self.run(_safe_str(getattr(message, \"content\", \"\") if message else \"\"))\n        except Exception as e:\n            self._log(\"ACTION_EXCEPTION\", _safe_str(e))\n            return f\"Error executing {getattr(self, 'name', 'Action')}: {_safe_str(e)}\"\n\nclass SimpleWriteCode(Action):\n    \"\"\"Produce Python code given an idea or instruction.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"idea_len={len(idea)}\")\n        if not idea:\n            # Clear deterministic fallback to avoid flaky behavior\n            fallback = (\n                \"# No idea provided. Placeholder implementation\\n\"\n                \"def solution(*args, **kwargs):\\n\"\n                \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            self._log(\"ACTION_END\", \"used_fallback\")\n            return fallback\n\n        prompt = (\n            \"You are an expert Python programmer. Write clean, testable Python code for the task below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, testable code\\n\"\n            \"- Basic error handling\\n\"\n            \"- Short comments for non-obvious parts\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = f\"# Implementation for: {idea}\\n# [LLM unavailable - placeholder]\\n\"\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"code_len={len(_safe_str(code))}\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Produce pytest tests for provided code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", f\"code_len={len(code)}\")\n        if not code.strip():\n            # Deterministic minimal tests\n            fallback = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    \\\"\\\"\\\"Placeholder test until implementation is available.\\\"\\\"\\\"\\n\"\n                \"    assert True\\n\"\n            )\n            self._log(\"ACTION_END\", \"used_fallback\")\n            return fallback\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation below.\\n\\n\"\n            f\"Code (first 2000 chars):\\n{code[:2000]}\\n\\n\"\n            \"Return only the pytest code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"tests_len={len(_safe_str(tests))}\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide a concise review of code and tests (automated or simulated human).\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"code_len={len(code)} tests_len={len(tests)} human={self.is_human}\")\n        if self.is_human:\n            review = \"Human review: Looks generally fine. Consider adding explicit edge-case tests and clearer exceptions.\"\n            self._log(\"ACTION_END\", \"human_review\")\n            return review\n\n        prompt = (\n            \"You are a senior code reviewer. Provide a concise actionable review of the code and tests.\\n\\n\"\n            f\"Code (first 1500 chars):\\n{code[:1500]}\\n\\n\"\n            f\"Tests (first 1500 chars):\\n{tests[:1500]}\\n\\n\"\n            \"Focus on readability, potential bugs, and test coverage. Be concise.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Automated review: Structure acceptable. Add boundary/negative-case tests and clearer error handling.\"\n        except Exception as e:\n            review = f\"Error generating review: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"review_len={len(_safe_str(review))}\")\n        return _safe_str(review)\n\nclass Role:\n    \"\"\"Lightweight role abstraction: holds a primary action class and watch_list of triggers.\"\"\"\n    def __init__(self, *, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        # store action classes so we instantiate per-act to avoid shared mutable state\n        self.action_classes: List[Type[Action]] = []\n        # list of cause_by strings this role listens for\n        self.watch_list: List[str] = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Any]):\n        \"\"\"Normalize to action classes for safe instantiation.\"\"\"\n        cls_list: List[Type[Action]] = []\n        for a in actions or []:\n            if isinstance(a, type) and issubclass(a, Action):\n                cls_list.append(a)\n            else:\n                try:\n                    cls_list.append(a.__class__)\n                except Exception:\n                    continue\n        self.action_classes = cls_list\n\n    def _watch(self, actions: List[Any]):\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"__name__\"))\n        self.watch_list = [n for n in names if n]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Instantiate the primary action and execute deterministically.\"\"\"\n        if not self.action_classes:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_SKIP\", self.name, \"No action assigned\")\n            return None\n        action_cls = self.action_classes[0]\n        # instantiate with context and, if review, pass is_human\n        try:\n            if action_cls is SimpleWriteReview:\n                action = action_cls(is_human=self.is_human, context=self.context)\n            else:\n                action = action_cls(context=self.context)\n        except Exception:\n            try:\n                action = action_cls()\n                action.context = self.context\n            except Exception as e:\n                _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, f\"Failed to create action: {_safe_str(e)}\")\n                return None\n\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ACT\", self.name, f\"Action={getattr(action, 'name', action_cls.__name__)} msg_id={getattr(message, 'id', None)}\")\n        try:\n            result = await action.execute(message=message, env=self.env)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, _safe_str(e))\n            result = f\"Error in role {self.name}: {_safe_str(e)}\"\n\n        response = make_message(content=result, role=self.profile, cause_by=getattr(action, \"name\", \"\"), sent_from=self.name)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_COMPLETE\", self.name, f\"Produced message id={getattr(response, 'id', None)}\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode])\n        self._watch([])  # reacts to user input\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        is_human = kwargs.get(\"is_human\", False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Minimal environment storing roles and message history with safe queries.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        \"\"\"Append a message to history and log a short preview; tolerate malformed message shapes.\"\"\"\n        try:\n            # ensure id exists if possible\n            if not getattr(message, \"id\", None):\n                try:\n                    message.id = str(uuid.uuid4())\n                except Exception:\n                    pass\n            self.history.append(message)\n            preview = (_safe_str(getattr(message, \"content\", \"\")))[:120]\n            sender = getattr(message, \"sent_from\", getattr(message, \"role\", \"Unknown\"))\n            cause = getattr(message, \"cause_by\", \"\")\n            _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"from={sender} cause={cause} preview={preview}\")\n        except Exception as e:\n            _safe_log(self.tracer, \"ENV_ERROR\", \"Environment\", f\"Failed to publish message: {_safe_str(e)}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages with cause_by that appear in role.watch_list, preserving order.\"\"\"\n        if not getattr(role, \"watch_list\", None):\n            return []\n        watched = set(role.watch_list or [])\n        result: List[Message] = []\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    result.append(m)\n            except Exception:\n                continue\n        return result\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Coordinator that runs deterministic rounds between roles using the environment.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Attach roles to the environment and align contexts.\"\"\"\n        for role in roles or []:\n            role.context = role.context or self.context\n            role.env = self.env\n            # ensure action instantiation will receive the team's context\n            # (actions are instantiated inside Role.act)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = float(investment)\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        _safe_log(self.tracer, \"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n\n    async def run(self, n_round: int = 3):\n        rounds = max(1, int(n_round or 1))\n        _safe_log(self.tracer, \"TEAM_RUN\", \"Team\", f\"Running {rounds} rounds\")\n\n        # Initial user message\n        initial = make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial)\n\n        for r in range(rounds):\n            _safe_log(self.tracer, \"ROUND_START\", \"Team\", f\"Round {r + 1}/{rounds}\")\n            # iterate in stable order\n            for role in list(self.env.roles):\n                response: Optional[Message] = None\n                try:\n                    # first round: coder(s) should respond to user input\n                    if r == 0 and any(getattr(ac, \"__name__\", \"\") == \"SimpleWriteCode\" or getattr(ac, \"name\", \"\") == \"SimpleWriteCode\" for ac in getattr(role, \"action_classes\", []) or []):\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        trigger = relevant[-1]\n                        response = await role.act(trigger)\n                except Exception as e:\n                    _safe_log(self.tracer, \"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                    response = None\n\n                if response:\n                    # Ensure cause_by is set when possible\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role, \"watch_list\", [\"\"])[0] if getattr(role, \"watch_list\", None) else \"\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n            _safe_log(self.tracer, \"ROUND_END\", \"Team\", f\"Round {r + 1} completed\")\n\n        _safe_log(self.tracer, \"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {rounds} rounds with {len(self.env.history)} messages exchanged.\"\n        _safe_log(self.tracer, \"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "486b1ebf-6b9c-4209-ab1c-fde425805997", "generation": 4, "timestamp": 1754649464.1083028, "iteration_found": 0, "metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 0, "migrant": true}, "artifacts_json": null, "artifact_dir": null}