{"id": "0d5c4800-2165-4339-877e-980b836bb256", "code": "# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Convert value to string safely.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event: str, agent: str, details: str):\n    \"\"\"Best-effort logging that never raises.\"\"\"\n    if tracer:\n        try:\n            tracer.log(event, agent, _safe_str(details))\n        except Exception:\n            pass\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Robust message construction compatible with both pydantic and fallback.\"\"\"\n    kwargs = {\n        \"content\": _safe_str(content),\n        \"role\": _safe_str(role),\n        \"cause_by\": _safe_str(cause_by),\n        \"sent_from\": _safe_str(sent_from) if sent_from is not None else None,\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    try:\n        return Message(**kwargs)\n    except Exception:\n        try:\n            # fallback positional\n            return Message(kwargs[\"content\"], kwargs[\"role\"],\n                           instruct_content=kwargs.get(\"instruct_content\"),\n                           cause_by=kwargs[\"cause_by\"],\n                           sent_from=kwargs[\"sent_from\"])\n        except Exception:\n            # minimal ad-hoc message-like object\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n                def __str__(self):\n                    return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n            return _M(kwargs[\"content\"], kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Minimal action base with lazy LLM and a single entrypoint to reduce branching.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Implement action logic and return a string result.\"\"\"\n        raise NotImplementedError\n\n    async def execute(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> str:\n        \"\"\"\n        Centralized mapping from incoming message/environment -> run() arguments.\n        Keeps control flow in one place and reduces surface area for bugs.\n        \"\"\"\n        try:\n            aname = getattr(self, \"name\", \"\") or self.__class__.__name__\n            if aname == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                return await self.run(idea)\n            if aname == SimpleWriteTest.name:\n                code = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code = getattr(message, \"content\", \"\") or \"\"\n                if not code and env:\n                    latest = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest, \"content\", \"\") if latest else \"\"\n                return await self.run(code)\n            if aname == SimpleWriteReview.name:\n                code = \"\"\n                tests = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests = getattr(message, \"content\", \"\") or \"\"\n                if not code and env:\n                    latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                if not tests and env:\n                    latest_tests = env.get_latest_message_by_cause(SimpleWriteTest.name)\n                    tests = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                return await self.run(code, tests)\n            # fallback: pass message content if any\n            return await self.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_EXCEPTION\", getattr(self, \"name\", \"Action\"), _safe_str(e))\n            return f\"Error executing {getattr(self, 'name', 'Action')}: {_safe_str(e)}\"\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code for a given idea.\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea_text = _safe_str(idea).strip()\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"idea={idea_text[:120]}\")\n        prompt = (\n            f\"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea_text}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, testable Python code\\n\"\n            \"- Basic error handling\\n\"\n            \"- Short comments\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                # deterministic fallback to prevent flaky behavior\n                code = (\n                    f\"# Implementation placeholder for: {idea_text}\\n\"\n                    \"def placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"len={len(_safe_str(code))}\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest tests for provided code.\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code_text = _safe_str(code)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"code_len={len(code_text)}\")\n        snippet = code_text[:2000] if code_text else \"# no code provided\"\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation below.\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Return only the pytest code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"len={len(_safe_str(tests))}\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide a concise review of code and tests.\"\"\"\n\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code_text = _safe_str(code)\n        tests_text = _safe_str(tests)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"is_human={self.is_human}\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider adding more edge-case tests and clearer error messages.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Provide a concise, actionable review of the code and tests.\\n\\n\"\n                    f\"Code:\\n{code_text[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests_text[:1500]}\\n\\n\"\n                    \"Focus on quality, coverage, potential bugs, and suggestions.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Structure OK; add boundary tests and improve error handling.\"\n        except Exception as e:\n            review = f\"Error during review: {_safe_str(e)}\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"len={len(_safe_str(review))}\")\n        return _safe_str(review)\n\nclass Role(ABC):\n    \"\"\"Simple agent role abstraction with one primary action and optional watch_list.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list contains cause_by names this role should react to\n        self.watch_list: List[str] = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # ensure actions have correct context and are independent instances\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                a.context = self.context\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type) and hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n        self.watch_list = [n for n in names if n]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action deterministically, returning a Message or None.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ACT\", self.name, f\"Action={getattr(action, 'name', '')}\")\n        try:\n            # Use centralized execute to map inputs robustly\n            result = await action.execute(message=message, env=self.env)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, _safe_str(e))\n            result = f\"Error in role {self.name}: {_safe_str(e)}\"\n        response = _make_message(content=result, role=self.profile, cause_by=getattr(action, \"name\", \"\"), sent_from=self.name)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_COMPLETE\", self.name, f\"Produced message cause_by={getattr(action, 'name', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code.\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # coder directly responds to user input\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests.\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests.\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        is_human = kwargs.get(\"is_human\", False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Message store and filtering utilities; minimal and robust.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        try:\n            self.history.append(message)\n            preview = (_safe_str(getattr(message, \"content\", \"\")) or \"\")[:120]\n            sender = getattr(message, \"sent_from\", getattr(message, \"role\", \"Unknown\"))\n            _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"from={sender} cause={getattr(message, 'cause_by', '')} preview={preview}\")\n        except Exception as e:\n            _safe_log(self.tracer, \"ENV_ERROR\", \"Environment\", f\"Failed to publish message: {_safe_str(e)}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        watched = set(role.watch_list or [])\n        if not watched:\n            return []\n        return [m for m in self.history if getattr(m, \"cause_by\", \"\") in watched]\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrator that manages roles, environment, and rounds deterministically.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Add roles to team and bind shared context/environment. Refresh actions to ensure correct context.\"\"\"\n        for role in roles or []:\n            role.context = role.context or self.context\n            role.env = self.env\n            # Refresh action instances so each action gets current context\n            refreshed: List[Action] = []\n            for a in getattr(role, \"actions\", []) or []:\n                try:\n                    cls = a.__class__\n                    refreshed.append(cls(context=self.context))\n                except Exception:\n                    try:\n                        a.context = self.context\n                        refreshed.append(a)\n                    except Exception:\n                        continue\n            if refreshed:\n                role.set_actions(refreshed)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        _safe_log(self.tracer, \"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n\n    async def run(self, n_round: int = 3):\n        rounds = max(1, int(n_round or 1))\n        _safe_log(self.tracer, \"TEAM_RUN\", \"Team\", f\"Running {rounds} rounds\")\n\n        # initial message\n        initial = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial)\n\n        for r in range(rounds):\n            _safe_log(self.tracer, \"ROUND_START\", \"Team\", f\"Round {r+1}/{rounds}\")\n            # snapshot roles\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # Round 0: coder(s) respond to initial user instruction\n                    if r == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    _safe_log(self.tracer, \"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                    continue\n\n                if response:\n                    # ensure cause_by exists\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role.actions[0], \"name\", \"\") if role.actions else \"\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n            _safe_log(self.tracer, \"ROUND_END\", \"Team\", f\"Round {r+1} completed\")\n\n        _safe_log(self.tracer, \"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {rounds} rounds with {len(self.env.history)} messages exchanged.\"\n        _safe_log(self.tracer, \"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "eae73869-dc40-486f-9422-a244a5c14fb2", "generation": 4, "timestamp": 1754648837.5951343, "iteration_found": 81, "metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes.\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 0.5000\n- overall_score: 0.2500\n- combined_score: 0.1000\n- avg_failures_per_task: 12.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 3.2125)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a safe string for any input.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str, sent_from: str, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance in a way that works with pydantic and fallback classes.\"\"\"\n    kwargs = {\"content\": _safe_str(content), \"role\": role, \"cause_by\": _safe_str(cause_by), \"sent_from\": sent_from}\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    try:\n        return Message(**kwargs)\n    except Exception:\n        # fallback to positional signature for older fallback Message\n        return Message(kwargs[\"content\"], kwargs[\"role\"], instruct_content=kwargs.get(\"instruct_content\"), cause_by=kwargs[\"cause_by\"], sent_from=kwargs[\"sent_from\"])\n\nclass Action(ABC):\n    \"\"\"Base action class - small, clear, robust.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self.llm: Optional[LLMInterface] = None\n        if self.context and getattr(self.context, \"config\", None):\n            try:\n                llm_conf = getattr(self.context.config, \"llm\", None)\n                if llm_conf:\n                    self.llm = LLMInterface(llm_conf)\n            except Exception:\n                self.llm = None\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Perform the concrete action and return text result.\"\"\"\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        idea = _safe_str(idea)\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_START\", self.name, f\"idea={idea[:100]}\")\n            except Exception:\n                pass\n\n        prompt = (\n            f\"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write clean, functional Python code\\n\"\n            \"2. Include proper error handling\\n\"\n            \"3. Add comments explaining the logic\\n\"\n            \"4. Make it production-ready\\n\\n\"\n            \"Please provide only the code without any explanation.\"\n        )\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ACTION_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        code = _safe_str(code)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_END\", self.name, f\"len={len(code)}\")\n            except Exception:\n                pass\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        code = _safe_str(code)\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code[:2000])}\")\n            except Exception:\n                pass\n\n        prompt = (\n            \"You are a QA engineer. Write comprehensive tests for the following code:\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write pytest-style test cases\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Include both positive and negative tests\\n\"\n            \"4. Add docstrings to explain what each test does\\n\\n\"\n            \"Please provide only the test code without any explanation.\"\n        )\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = \"# Tests for the implementation\\n# [Tests would be generated here]\"\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ACTION_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        tests = _safe_str(tests)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_END\", self.name, f\"len={len(tests)}\")\n            except Exception:\n                pass\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str, tests: str) -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_START\", self.name, f\"is_human={self.is_human}\")\n            except Exception:\n                pass\n\n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Review the following code and tests:\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Provide a brief review focusing on:\\n\"\n                    \"1. Code quality and best practices\\n\"\n                    \"2. Test coverage\\n\"\n                    \"3. Potential bugs or issues\\n\"\n                    \"4. Suggestions for improvement\\n\\n\"\n                    \"Keep your review concise and actionable.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        except Exception as e:\n            review = f\"Error during review: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ACTION_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        review = _safe_str(review)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_END\", self.name, f\"len={len(review)}\")\n            except Exception:\n                pass\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents - simplified and robust.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context: Optional[Context] = kwargs.get('context')\n        self.is_human: bool = kwargs.get('is_human', False)\n        # actions are instances of Action\n        self.actions: List[Action] = []\n        # watch_list contains cause_by names for messages this role should respond to\n        self.watch_list: List[str] = []\n        # environment reference (set by Team.hire)\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # store a shallow copy; Team will refresh contexts if needed\n        self.actions = list(actions or [])\n\n    def _watch(self, actions: List[Any]):\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type) and hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            else:\n                try:\n                    names.append(str(a))\n                except Exception:\n                    continue\n        self.watch_list = [n for n in names if n]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action using a small, explicit dispatch.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ROLE_ACT\", self.name, f\"Executing: {getattr(action, 'name', 'Action')}\")\n            except Exception:\n                pass\n\n        try:\n            # Code writer prefers instruct_content then content\n            if isinstance(action, SimpleWriteCode):\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            # Tester prefers code passed in the message; otherwise find latest code in env\n            elif isinstance(action, SimpleWriteTest):\n                code = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code = getattr(message, \"content\", \"\") or \"\"\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code)\n\n            # Reviewer tries to assemble code+tests from env\n            elif isinstance(action, SimpleWriteReview):\n                code = \"\"\n                tests = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests = getattr(message, \"content\", \"\") or \"\"\n                    if self.env:\n                        code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code = getattr(code_msg, \"content\", \"\") if code_msg else \"\"\n                else:\n                    if self.env:\n                        code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        test_msg = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        code = getattr(code_msg, \"content\", \"\") if code_msg else \"\"\n                        tests = getattr(test_msg, \"content\", \"\") if test_msg else \"\"\n                result = await action.run(code, tests)\n\n            else:\n                # Generic fallback: pass content or empty string\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            result = f\"Error in role {self.name} while executing action: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ROLE_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        # Construct response message robustly\n        try:\n            response = _make_message(result, self.profile, getattr(action, \"name\", \"\"), self.name)\n        except Exception:\n            # last-resort simple wrapper\n            try:\n                response = Message(result, self.profile)\n            except Exception:\n                # minimal ad-hoc object\n                class _SimpleMsg:\n                    def __init__(self, content, role, cause_by, sent_from):\n                        self.id = str(uuid.uuid4())\n                        self.content = content\n                        self.role = role\n                        self.cause_by = cause_by\n                        self.sent_from = sent_from\n                response = _SimpleMsg(_safe_str(result), self.profile, getattr(action, \"name\", \"\"), self.name)\n\n        if tracer:\n            try:\n                tracer.log(\"ROLE_COMPLETE\", self.name, f\"Message created (cause_by={getattr(action, 'name', '')})\")\n            except Exception:\n                pass\n\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # create action instance; Team.hire will refresh contexts\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Simple environment that stores messages and filters by cause_by.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return list(self.roles)\n\n    def publish_message(self, message: Message):\n        # Append safely and log summary\n        try:\n            self.history.append(message)\n            if self.tracer:\n                preview = _safe_str(getattr(message, \"content\", \"\"))[:120]\n                sender = getattr(message, \"sent_from\", getattr(message, \"role\", \"Unknown\"))\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"from={sender} cause={cause} preview={preview}\")\n        except Exception as e:\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", f\"publish failed: {e}\")\n                except Exception:\n                    pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by equals any name in role.watch_list\"\"\"\n        watched = set(role.watch_list or [])\n        if not watched:\n            return []\n        res: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    res.append(msg)\n            except Exception:\n                continue\n        return res\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together - orchestrates rounds deterministically.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles, attach shared context/env and refresh actions' context/LLM.\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            # refresh action instances so they use current context\n            refreshed: List[Action] = []\n            for a in getattr(role, \"actions\", []) or []:\n                try:\n                    cls = a.__class__\n                    refreshed.append(cls(context=self.context))\n                except Exception:\n                    try:\n                        a.context = self.context\n                        refreshed.append(a)\n                    except Exception:\n                        continue\n            if refreshed:\n                role.set_actions(refreshed)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        # Build initial message robustly\n        initial = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            cause_by=\"UserInput\",\n            sent_from=\"User\"\n        )\n        self.env.publish_message(initial)\n\n        for round_num in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n                except Exception:\n                    pass\n\n            # Snapshot roles to avoid mutation issues\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # Round 0: coder should respond to user\n                    if round_num == 0 and getattr(role, \"profile\", \"\") == \"SimpleCoder\":\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        # Act on the most recent relevant message\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n                summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n\n### Program 2 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event_type: str, agent: str, details: str):\n    \"\"\"Best-effort logging that never throws.\"\"\"\n    if tracer:\n        try:\n            tracer.log(event_type, agent, details)\n        except Exception:\n            pass\n\ndef make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance compatible with both pydantic and fallback implementations.\"\"\"\n    kwargs = {\n        \"content\": content,\n        \"role\": role,\n        \"cause_by\": cause_by,\n        \"sent_from\": sent_from\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = instruct_content\n    try:\n        return Message(**kwargs)\n    except Exception:\n        # Try positional where pydantic is not present\n        try:\n            return Message(kwargs[\"content\"], kwargs[\"role\"],\n                           instruct_content=kwargs.get(\"instruct_content\"),\n                           cause_by=kwargs[\"cause_by\"],\n                           sent_from=kwargs[\"sent_from\"])\n        except Exception:\n            # Minimal fallback object\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n                def __str__(self):\n                    return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n            return _M(kwargs[\"content\"], kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Base action class with lazy LLM and safe logging.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, *, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        _safe_log(tracer, event, self.name, details)\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea_text = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea_text[:120]}\")\n        prompt = (\n            f\"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea_text}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write clean, functional Python code\\n\"\n            \"2. Include proper error handling\\n\"\n            \"3. Add comments explaining the logic\\n\"\n            \"4. Make it production-ready\\n\\n\"\n            \"Please provide only the code without any explanation.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                # Deterministic, safe fallback\n                code = (\n                    f\"# Implementation for: {idea_text}\\n\"\n                    \"def placeholder_function():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(code)} characters of code\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code_text = (code or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing tests for code (len={len(code_text)})\")\n        snippet = code_text[:2000] if code_text else \"# No code provided\"\n        prompt = (\n            \"You are a QA engineer. Write comprehensive tests for the following code:\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write pytest-style test cases\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Include both positive and negative tests\\n\"\n            \"4. Add docstrings to explain what each test does\\n\\n\"\n            \"Please provide only the test code without any explanation.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} characters of tests\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code_text = (code or \"\").strip()\n        tests_text = (tests or \"\").strip()\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Review the following code and tests:\\n\\n\"\n                    f\"Code:\\n{code_text[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests_text[:1500]}\\n\\n\"\n                    \"Provide a brief review focusing on:\\n\"\n                    \"1. Code quality and best practices\\n\"\n                    \"2. Test coverage\\n\"\n                    \"3. Potential bugs or issues\\n\"\n                    \"4. Suggestions for improvement\\n\\n\"\n                    \"Keep your review concise and actionable.\"\n                )\n                messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                            {\"role\": \"user\", \"content\": prompt}]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Review: Code structure looks reasonable. Tests cover main functionality; add more edge cases.\"\n        except Exception as e:\n            review = f\"Error during review generation: {e}\"\n        self._log(\"ACTION_END\", f\"Review completed ({len(review)} chars)\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents (simplified).\"\"\"\n    def __init__(self, *, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list stores cause_by names (strings) to react to\n        self.watch_list: List[str] = []\n        # environment reference set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # Bind context into action instances and keep them per-instance (no shared mutable)\n        bound: List[Action] = []\n        for a in actions or []:\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                a.context = self.context\n            bound.append(a)\n        self.actions = bound\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"__name__\"))\n        self.watch_list = [n for n in names if n]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform primary action based on a message; returns a Message or None.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ACT\", self.name, f\"Executing action: {getattr(action, 'name', 'Action')}\")\n        try:\n            # Map inputs according to action type\n            if getattr(action, \"name\", \"\") == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n            elif getattr(action, \"name\", \"\") == SimpleWriteTest.name:\n                # Prefer code from message (if coder produced it), else search environment history\n                code = \"\"\n                if message and getattr(message, \"content\", None):\n                    code = message.content\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code)\n            elif getattr(action, \"name\", \"\") == SimpleWriteReview.name:\n                # Gather code and tests from message or environment\n                code = \"\"\n                tests = \"\"\n                if message:\n                    tests = getattr(message, \"content\", \"\") or \"\"\n                    code = getattr(message, \"instruct_content\", \"\") or \"\"\n                if self.env:\n                    if not code:\n                        latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code = getattr(latest_code, \"content\", \"\") if latest_code else code\n                    if not tests:\n                        latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        tests = getattr(latest_tests, \"content\", \"\") if latest_tests else tests\n                result = await action.run(code, tests)\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, f\"Exception during act: {e}\")\n            result = f\"Error in role {self.name}: {e}\"\n\n        response = make_message(\n            content=result,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"\"),\n            sent_from=self.name\n        )\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_COMPLETE\", self.name, \"Action completed, message created\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # coder responds to user input explicitly\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        is_human = kwargs.get(\"is_human\", False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return list(self.roles)\n\n    def publish_message(self, message: Message):\n        # append and log safely\n        try:\n            self.history.append(message)\n            preview = (getattr(message, \"content\", \"\") or \"\")[:100]\n            sender = getattr(message, \"sent_from\", \"unknown\")\n            _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"Message from {sender}: {preview}\")\n        except Exception:\n            # best-effort attempt to normalize and store minimal info\n            try:\n                minimal = make_message(str(getattr(message, \"content\", \"\")), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"), sent_from=getattr(message, \"sent_from\", \"unknown\"))\n                self.history.append(minimal)\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        relevant: List[Message] = []\n        watched = set(role.watch_list or [])\n        if not watched:\n            return relevant\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    relevant.append(m)\n            except Exception:\n                continue\n        return relevant\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # ensure tracer in context\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team; ensure contexts for role actions are aligned\"\"\"\n        for role in roles:\n            role.context = role.context or self.context\n            role.env = self.env\n            # ensure actions know the team's context\n            for a in role.actions:\n                a.context = a.context or self.context\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        _safe_log(self.tracer, \"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 3):\n        _safe_log(self.tracer, \"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        # initial message (user instruction)\n        initial = make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial)\n\n        for round_num in range(n_round):\n            _safe_log(self.tracer, \"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            # roles act in deterministic order\n            for role in list(self.env.roles):\n                response: Optional[Message] = None\n                try:\n                    if round_num == 0 and isinstance(role, SimpleCoder):\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    _safe_log(self.tracer, \"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"{e}\")\n                    response = None\n                if response:\n                    self.env.publish_message(response)\n            _safe_log(self.tracer, \"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n\n        _safe_log(self.tracer, \"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        _safe_log(self.tracer, \"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 3.2125)\n```python\n# -*- coding: utf-8 -*-\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a safe string representation.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance in a robust manner for both pydantic and fallback.\"\"\"\n    content_s = _safe_str(content)\n    try:\n        return Message(\n            content=content_s,\n            instruct_content=instruct_content,\n            role=role,\n            cause_by=cause_by or \"\",\n            sent_from=sent_from\n        )\n    except Exception:\n        class _M:\n            pass\n        m = _M()\n        m.id = str(uuid.uuid4())\n        m.content = content_s\n        m.instruct_content = instruct_content\n        m.role = role\n        m.cause_by = cause_by or \"\"\n        m.sent_from = sent_from\n        m.sent_to = None\n        m.send_to = set()\n        return m\n\nclass Action(ABC):\n    \"\"\"Base action with lazy LLM initialization and safe logging.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, **kwargs):\n        self.context: Optional[Context] = kwargs.get(\"context\")\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and self.context:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, etype: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(etype, getattr(self, \"name\", \"Action\"), _safe_str(details))\n            except Exception:\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code for an idea.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the request.\\n\\n\"\n            f\"Task:\\n{idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, testable code\\n\"\n            \"- Basic error handling\\n\"\n            \"- Short comments\\n\"\n            \"Return only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = (\n                    f\"# Implementation for: {idea}\\n\"\n                    \"def placeholder_function(*args, **kwargs):\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    return None\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        code = _safe_str(code)\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest tests for a piece of code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", \"Writing tests for code\")\n        prompt = (\n            \"You are an expert QA engineer. Given the implementation, write pytest-style tests (positive and negative).\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        tests = _safe_str(tests)\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Review code and tests and provide actionable feedback.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"Reviewing (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable; consider more edge-case tests and clearer error messages.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Provide a concise, actionable review of the code and tests.\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Focus on quality, coverage, potential issues, and improvements.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt},\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Structure is acceptable; add boundary tests and improve error handling.\"\n        except Exception as e:\n            review = f\"Error during review: {_safe_str(e)}\"\n        review = _safe_str(review)\n        self._log(\"ACTION_END\", f\"Review length {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Minimal, predictable agent role abstraction.\"\"\"\n    def __init__(self, **kwargs):\n        self.name: str = kwargs.get(\"name\", \"Role\")\n        self.profile: str = kwargs.get(\"profile\", \"Default\")\n        self.context: Optional[Context] = kwargs.get(\"context\")\n        self.is_human: bool = bool(kwargs.get(\"is_human\", False))\n        self.actions: List[Action] = []\n        # watch_list holds cause_by names to react to\n        self.watch_list: Set[str] = set()\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions or []\n        for a in self.actions:\n            a.context = self.context\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: Set[str] = set()\n        for a in actions or []:\n            try:\n                if isinstance(a, str):\n                    names.add(a)\n                elif isinstance(a, type) and hasattr(a, \"name\"):\n                    names.add(getattr(a, \"name\"))\n                elif hasattr(a, \"name\"):\n                    names.add(getattr(a, \"name\"))\n            except Exception:\n                continue\n        self.watch_list = names\n\n    def _log(self, etype: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(etype, self.name, _safe_str(details))\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform primary action deterministically using latest relevant context.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions configured\")\n            return None\n\n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"Executing action: {action_name}\")\n\n        result = \"\"\n        try:\n            # Routing based on action name keeps behavior explicit and simple\n            if action_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            elif action_name == SimpleWriteTest.name:\n                code_text = \"\"\n                # Prefer code from triggering message if it was coder output\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                # Otherwise, try to fetch latest code from environment\n                if not code_text and self.env:\n                    code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    if code_msg:\n                        code_text = getattr(code_msg, \"content\", \"\") or \"\"\n                result = await action.run(code_text)\n\n            elif action_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                # Prefer explicit pieces from the incoming message (if present)\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                # Fill from environment if missing\n                if self.env:\n                    if not code_text:\n                        cm = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        if cm:\n                            code_text = getattr(cm, \"content\", \"\") or \"\"\n                    if not tests_text:\n                        tm = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        if tm:\n                            tests_text = getattr(tm, \"content\", \"\") or \"\"\n                result = await action.run(code_text, tests_text)\n\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            err = f\"Error executing action {action_name}: {_safe_str(e)}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        response = _make_message(\n            content=_safe_str(result),\n            role=self.profile,\n            cause_by=action_name,\n            sent_from=self.name\n        )\n        self._log(\"ROLE_COMPLETE\", f\"Message created (cause_by={action_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault(\"name\", self.name)\n        kwargs.setdefault(\"profile\", self.profile)\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # coder triggers from user input\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault(\"name\", self.name)\n        kwargs.setdefault(\"profile\", self.profile)\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault(\"name\", self.name)\n        kwargs.setdefault(\"profile\", self.profile)\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with simplified, safe interface.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return list(self.roles)\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message to history and log a short preview. Be tolerant of shape.\"\"\"\n        try:\n            self.history.append(message)\n        except Exception:\n            try:\n                m = _make_message(\n                    content=_safe_str(getattr(message, \"content\", message)),\n                    role=_safe_str(getattr(message, \"role\", \"Unknown\")),\n                    cause_by=_safe_str(getattr(message, \"cause_by\", \"\")),\n                    sent_from=_safe_str(getattr(message, \"sent_from\", \"Unknown\"))\n                )\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                cause = getattr(message, \"cause_by\", \"\")\n                preview = (_safe_str(getattr(message, \"content\", \"\")))[:120]\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {sender} (cause={cause}): {preview}\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by is in role.watch_list.\"\"\"\n        watched = set(getattr(role, \"watch_list\", []) or [])\n        if not watched:\n            return []\n        relevant: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    relevant.append(msg)\n            except Exception:\n                continue\n        return relevant\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Return latest message matching cause_by.\"\"\"\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team orchestrating roles and environment with deterministic rounds.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles; align contexts and env references.\"\"\"\n        for role in roles:\n            try:\n                role.context = self.context\n                role.env = self.env\n                for a in getattr(role, \"actions\", []) or []:\n                    a.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        # Initial user message\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        # Deterministic sequential rounds\n        for round_num in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n                except Exception:\n                    pass\n\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: coder(s) respond to initial instruction\n                    has_code_action = any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions)\n                    if round_num == 0 and has_code_action:\n                        response = await role.act(initial_msg)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1])\n                        else:\n                            continue\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_RUN_ERROR\", getattr(role, \"name\", \"Unknown\"), f\"Error during act: {_safe_str(e)}\")\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role.actions[0], \"name\", \"UnknownAction\")\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n                summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D2 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a stable string for logging/outputs.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance that works with pydantic or fallback Message safely.\"\"\"\n    content = _safe_str(content)\n    kwargs = {\n        \"content\": content,\n        \"role\": _safe_str(role),\n        \"cause_by\": _safe_str(cause_by),\n        \"sent_from\": _safe_str(sent_from) if sent_from is not None else None,\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    try:\n        # pydantic Message accepts keywords; fallback Message accepts keywords as well\n        return Message(**kwargs)\n    except Exception:\n        # Last-resort minimal object\n        class _M:\n            def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                self.id = str(uuid.uuid4())\n                self.content = content\n                self.instruct_content = instruct_content\n                self.role = role\n                self.cause_by = cause_by\n                self.sent_from = sent_from\n                self.sent_to = None\n                self.send_to = set()\n            def __str__(self):\n                return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n        return _M(content, kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Defensive, minimal base action with lazy LLM initialization.\"\"\"\n\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            try:\n                self._llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Idea: {idea[:120]}\")\n        prompt = (\n            \"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Clean, testable Python code\\n\"\n            \"2. Basic error handling\\n\"\n            \"3. Short comments\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                code = _safe_str(resp)\n            else:\n                # deterministic fallback to prevent flaky failures\n                code = (\n                    f\"# Implementation placeholder for: {idea}\\n\"\n                    \"def placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", f\"Code len: {len(code)}\")\n        snippet = code[:2000] if code else \"# no code provided\"\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation.\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = _safe_str(resp)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"is_human={self.is_human}\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider more edge-case tests and clearer errors.\"\n            else:\n                prompt = (\n                    \"You are a senior reviewer. Provide a concise review focusing on code quality, test coverage, and issues.\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Keep it concise.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt},\n                ]\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = _safe_str(resp)\n                else:\n                    review = \"Automated review: Structure OK; consider adding more edge-case tests and clearer error handling.\"\n        except Exception as e:\n            review = f\"Error during review: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Review len {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simplified agent role: one primary action, optional watch list (names).\"\"\"\n\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list contains cause_by names to react to\n        self.watch_list: List[str] = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # ensure actions are instances and share context\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Any]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type):\n                names.append(getattr(a, \"name\", a.__name__))\n            else:\n                names.append(getattr(a, \"name\", str(a)))\n        self.watch_list = [n for n in names if n]\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> Optional[Message]:\n        \"\"\"Deterministic mapping from message -> action inputs, robust to missing data.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        env = env or self.env\n\n        self._log(\"ROLE_ACT\", f\"Action={action_name} message_id={getattr(message, 'id', None)}\")\n\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            elif action_name == SimpleWriteTest.name:\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                if not code_text and env:\n                    latest = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code_text)\n\n            elif action_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or \"\"\n                if env:\n                    latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    latest_tests = env.get_latest_message_by_cause(SimpleWriteTest.name)\n                    code_text = code_text or (getattr(latest_code, \"content\", \"\") if latest_code else \"\")\n                    tests_text = tests_text or (getattr(latest_tests, \"content\", \"\") if latest_tests else \"\")\n                # ensure review action knows if role is human\n                if isinstance(action, SimpleWriteReview):\n                    try:\n                        action.is_human = self.is_human\n                    except Exception:\n                        pass\n                result = await action.run(code_text, tests_text)\n\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                try:\n                    result = await action.run(payload)\n                except TypeError:\n                    result = await action.run()\n        except Exception as e:\n            err = f\"Error executing {action_name}: {_safe_str(e)}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        # Build response message in a safe manner\n        response = _make_message(content=_safe_str(result), role=self.profile, cause_by=action_name, sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"Created message (cause_by={action_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # coder listens to explicit user instruction (no watch list)\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Lightweight deterministic message bus with simple filtering and processed-tracking.\"\"\"\n\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track last processed message id per role to avoid duplicates\n        self._last_processed: Dict[str, Optional[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._last_processed.setdefault(role.name, None)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message and log a concise preview; never raise to caller.\"\"\"\n        try:\n            if not getattr(message, \"id\", None):\n                message.id = str(uuid.uuid4())\n        except Exception:\n            pass\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", getattr(message, \"role\", \"Unknown\"))\n                preview = (_safe_str(getattr(message, \"content\", \"\")))[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From={sender} Cause={cause} Preview={preview}\")\n        except Exception:\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", \"Failed to append message\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages whose cause_by matches role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        res: List[Message] = []\n        last_id = self._last_processed.get(role.name)\n        start_index = 0\n        if last_id:\n            for idx, m in enumerate(self.history):\n                try:\n                    if getattr(m, \"id\", None) == last_id:\n                        start_index = idx + 1\n                        break\n                except Exception:\n                    continue\n        for m in self.history[start_index:]:\n            try:\n                if getattr(m, \"cause_by\", \"\") in role.watch_list:\n                    res.append(m)\n            except Exception:\n                continue\n        return res\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\n    def mark_processed(self, role: Role, message: Message):\n        try:\n            self._last_processed[role.name] = getattr(message, \"id\", None)\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_MARK\", \"Environment\", f\"Role {role.name} processed message {getattr(message, 'id', '')}\")\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\nclass Team:\n    \"\"\"Orchestrates roles and rounds with clear deterministic flow and robust logging.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for role in (roles or []):\n            role.context = self.context\n            # update actions context\n            for a in getattr(role, \"actions\", []) or []:\n                try:\n                    a.context = role.context\n                except Exception:\n                    pass\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        for rnd in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnd+1}/{n_round}\")\n                except Exception:\n                    pass\n\n            # process roles in deterministic order\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    if rnd == 0 and isinstance(role, SimpleCoder):\n                        response = await role.act(initial_msg, env=self.env)\n                        try:\n                            self.env.mark_processed(role, initial_msg)\n                        except Exception:\n                            pass\n                    else:\n                        msgs = self.env.get_messages_for_role(role)\n                        if not msgs:\n                            continue\n                        selected = msgs[-1]\n                        response = await role.act(selected, env=self.env)\n                        try:\n                            self.env.mark_processed(role, selected)\n                        except Exception:\n                            pass\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    # ensure message-like\n                    if not hasattr(response, \"content\"):\n                        try:\n                            response = _make_message(content=_safe_str(getattr(response, \"content\", \"\")),\n                                                     role=getattr(response, \"role\", getattr(role, \"profile\", \"Unknown\")),\n                                                     cause_by=_safe_str(getattr(response, \"cause_by\", \"\")),\n                                                     sent_from=_safe_str(getattr(response, \"sent_from\", getattr(role, \"name\", \"Unknown\"))))\n                        except Exception:\n                            try:\n                                response = Message(content=_safe_str(response), role=role.profile, cause_by=\"\", sent_from=role.name)\n                            except Exception:\n                                class _M:\n                                    def __init__(self, content, role, cause_by, sent_from):\n                                        self.id = str(uuid.uuid4())\n                                        self.content = content\n                                        self.role = role\n                                        self.cause_by = cause_by\n                                        self.sent_from = sent_from\n                                response = _M(_safe_str(response), role.profile, \"\", role.name)\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnd+1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n                summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n\n### Program D3 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Stable string conversion without raising.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(\n    content: str,\n    role: str,\n    cause_by: str = \"\",\n    sent_from: Optional[str] = None,\n    instruct_content: Optional[str] = None\n):\n    \"\"\"\n    Create a Message instance in a robust way that works with pydantic Message or fallback Message class.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        return Message(\n            content=content,\n            instruct_content=instruct_content,\n            role=role,\n            cause_by=cause_by or \"\",\n            sent_from=sent_from\n        )\n    except Exception:\n        # Fallback positional init\n        try:\n            return Message(\n                content, role,\n                instruct_content=instruct_content,\n                cause_by=cause_by or \"\",\n                sent_from=sent_from\n            )\n        except Exception:\n            # Minimal fallback\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n                def __str__(self):\n                    return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n            return _M(content, role, cause_by or \"\", sent_from, instruct_content)\n\nclass Action(ABC):\n    \"\"\"Small, predictable action base with lazy LLM init and safe logging.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily instantiate LLMInterface; swallow errors to avoid failure modes.\"\"\"\n        if self._llm is None and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            try:\n                self._llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the request.\\n\\n\"\n            f\"Task:\\n{idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\nReturn only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                code = _safe_str(resp)\n            else:\n                code = (\n                    f\"# Implementation for: {idea}\\n\\n\"\n                    \"def placeholder_function():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", \"Writing tests for code\")\n        prompt = (\n            \"You are an expert QA engineer. Given the implementation, write pytest-style tests (positive and negative).\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = _safe_str(resp)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n    \n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Looks reasonable. Consider adding more edge-case tests and clearer errors.\"\n        else:\n            prompt = (\n                \"You are a senior engineer. Provide a concise review focusing on code quality, test coverage, and issues.\\n\\n\"\n                f\"Code:\\n{code[:1500]}\\n\\nTests:\\n{tests[:1500]}\\n\\nKeep it concise.\"\n            )\n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            try:\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = _safe_str(resp)\n                else:\n                    review = \"Automated review: Acceptable structure; consider more edge cases and clearer error handling.\"\n            except Exception as e:\n                review = f\"Error during review: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Review length {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simplified role with deterministic selection and minimal mutable state.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list contains cause_by strings to respond to\n        self.watch_list: List[str] = []\n        # environment reference set when hired\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # Ensure action contexts are consistent\n        prepared = []\n        for a in (actions or []):\n            try:\n                a.context = self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action]]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                try:\n                    names.append(getattr(a, \"name\"))\n                except Exception:\n                    pass\n            elif isinstance(a, type):\n                names.append(getattr(a, \"name\", a.__name__))\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> Optional[Message]:\n        \"\"\"\n        Determine appropriate action and produce a message.\n        Deterministic mapping:\n          - If there is an instruct_content -> SimpleWriteCode\n          - If message.cause_by == SimpleWriteCode -> SimpleWriteTest\n          - If message.cause_by == SimpleWriteTest -> SimpleWriteReview\n          - Otherwise default to first action.\n        \"\"\"\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions available\")\n            return None\n\n        env = env or self.env\n        selected = self.actions[0]\n\n        # Prefer explicit instruction for coder\n        if message and getattr(message, \"instruct_content\", None):\n            for a in self.actions:\n                if getattr(a, \"name\", \"\") == SimpleWriteCode.name:\n                    selected = a\n                    break\n        else:\n            cause = getattr(message, \"cause_by\", \"\") if message else \"\"\n            if cause:\n                if cause == SimpleWriteCode.name:\n                    for a in self.actions:\n                        if getattr(a, \"name\", \"\") == SimpleWriteTest.name:\n                            selected = a\n                            break\n                elif cause == SimpleWriteTest.name:\n                    for a in self.actions:\n                        if getattr(a, \"name\", \"\") == SimpleWriteReview.name:\n                            selected = a\n                            break\n\n        self._log(\"ROLE_ACT\", f\"Executing {getattr(selected, 'name', 'Action')}\")\n\n        try:\n            if getattr(selected, \"name\", \"\") == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await selected.run(idea)\n\n            elif getattr(selected, \"name\", \"\") == SimpleWriteTest.name:\n                # Prefer code in the triggering message; else search env history\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                elif env:\n                    for m in reversed(env.history):\n                        if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                            code_text = getattr(m, \"content\", \"\") or \"\"\n                            break\n                result = await selected.run(code_text)\n\n            elif getattr(selected, \"name\", \"\") == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                # If message is tests or code prefer it\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                        tests_text = getattr(message, \"content\", \"\") or \"\"\n                    elif getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                        code_text = getattr(message, \"content\", \"\") or \"\"\n                # Fill missing pieces from env\n                if env:\n                    if not code_text:\n                        for m in reversed(env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteCode.name:\n                                code_text = getattr(m, \"content\", \"\") or \"\"\n                                break\n                    if not tests_text:\n                        for m in reversed(env.history):\n                            if getattr(m, \"cause_by\", \"\") == SimpleWriteTest.name:\n                                tests_text = getattr(m, \"content\", \"\") or \"\"\n                                break\n                # Propagate human flag to action if possible\n                if isinstance(selected, SimpleWriteReview):\n                    selected.is_human = self.is_human\n                result = await selected.run(code_text, tests_text)\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await selected.run(payload)\n        except Exception as e:\n            self._log(\"ROLE_ERROR\", f\"Action failed: {_safe_str(e)}\")\n            result = f\"Error executing action: {_safe_str(e)}\"\n\n        response = _make_message(content=result, role=self.profile, cause_by=getattr(selected, \"name\", \"\"), sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"Produced message (cause_by={getattr(selected, 'name', '')})\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # listens to explicit user instruction\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with simple routing rules.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        # Attach environment reference to role for lookups\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message and log a short preview. Never raise.\"\"\"\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                preview = _safe_str(getattr(message, \"content\", \"\"))[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {sender} (cause={cause}): {preview}\")\n        except Exception:\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", \"Failed to publish message\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        results: List[Message] = []\n        try:\n            watched = set(role.watch_list)\n            for m in self.history:\n                try:\n                    if getattr(m, \"cause_by\", \"\") in watched:\n                        results.append(m)\n                except Exception:\n                    continue\n        except Exception:\n            pass\n        return results\n\nclass Team:\n    \"\"\"Orchestrates roles deterministically with safe error handling.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in (roles or []):\n            try:\n                r.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        # initial user message\n        initial = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            role=\"Human\",\n            cause_by=\"UserInput\",\n            sent_from=\"User\",\n            instruct_content=self.idea\n        )\n        self.env.publish_message(initial)\n\n        for round_num in range(n_round):\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            # Iterate over a stable snapshot of roles\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: coder responds to user input explicitly\n                    if round_num == 0 and role.profile == \"SimpleCoder\":\n                        response = await role.act(initial, env=self.env)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1], env=self.env)\n                        else:\n                            continue\n                except Exception as e:\n                    try:\n                        if self.tracer:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"{_safe_str(e)}\")\n                    except Exception:\n                        pass\n                    continue\n\n                if response:\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            except Exception:\n                pass\n\n        try:\n            if self.tracer:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n\n        try:\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            if self.tracer:\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to overall_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 3.2125, Type: Migrant)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a safe string for any input.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str, sent_from: str, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance in a way that works with pydantic and fallback classes.\"\"\"\n    kwargs = {\"content\": _safe_str(content), \"role\": role, \"cause_by\": _safe_str(cause_by), \"sent_from\": sent_from}\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    try:\n        return Message(**kwargs)\n    except Exception:\n        # fallback to positional signature for older fallback Message\n        return Message(kwargs[\"content\"], kwargs[\"role\"], instruct_content=kwargs.get(\"instruct_content\"), cause_by=kwargs[\"cause_by\"], sent_from=kwargs[\"sent_from\"])\n\nclass Action(ABC):\n    \"\"\"Base action class - small, clear, robust.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self.llm: Optional[LLMInterface] = None\n        if self.context and getattr(self.context, \"config\", None):\n            try:\n                llm_conf = getattr(self.context.config, \"llm\", None)\n                if llm_conf:\n                    self.llm = LLMInterface(llm_conf)\n            except Exception:\n                self.llm = None\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Perform the concrete action and return text result.\"\"\"\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str) -> str:\n        idea = _safe_str(idea)\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_START\", self.name, f\"idea={idea[:100]}\")\n            except Exception:\n                pass\n\n        prompt = (\n            f\"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write clean, functional Python code\\n\"\n            \"2. Include proper error handling\\n\"\n            \"3. Add comments explaining the logic\\n\"\n            \"4. Make it production-ready\\n\\n\"\n            \"Please provide only the code without any explanation.\"\n        )\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ACTION_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        code = _safe_str(code)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_END\", self.name, f\"len={len(code)}\")\n            except Exception:\n                pass\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str) -> str:\n        code = _safe_str(code)\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_START\", self.name, f\"code_len={len(code[:2000])}\")\n            except Exception:\n                pass\n\n        prompt = (\n            \"You are a QA engineer. Write comprehensive tests for the following code:\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write pytest-style test cases\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Include both positive and negative tests\\n\"\n            \"4. Add docstrings to explain what each test does\\n\\n\"\n            \"Please provide only the test code without any explanation.\"\n        )\n\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = \"# Tests for the implementation\\n# [Tests would be generated here]\"\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ACTION_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        tests = _safe_str(tests)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_END\", self.name, f\"len={len(tests)}\")\n            except Exception:\n                pass\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str, tests: str) -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_START\", self.name, f\"is_human={self.is_human}\")\n            except Exception:\n                pass\n\n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Review the following code and tests:\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Provide a brief review focusing on:\\n\"\n                    \"1. Code quality and best practices\\n\"\n                    \"2. Test coverage\\n\"\n                    \"3. Potential bugs or issues\\n\"\n                    \"4. Suggestions for improvement\\n\\n\"\n                    \"Keep your review concise and actionable.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        except Exception as e:\n            review = f\"Error during review: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ACTION_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        review = _safe_str(review)\n        if tracer:\n            try:\n                tracer.log(\"ACTION_END\", self.name, f\"len={len(review)}\")\n            except Exception:\n                pass\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents - simplified and robust.\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n\n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context: Optional[Context] = kwargs.get('context')\n        self.is_human: bool = kwargs.get('is_human', False)\n        # actions are instances of Action\n        self.actions: List[Action] = []\n        # watch_list contains cause_by names for messages this role should respond to\n        self.watch_list: List[str] = []\n        # environment reference (set by Team.hire)\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # store a shallow copy; Team will refresh contexts if needed\n        self.actions = list(actions or [])\n\n    def _watch(self, actions: List[Any]):\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type) and hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            else:\n                try:\n                    names.append(str(a))\n                except Exception:\n                    continue\n        self.watch_list = [n for n in names if n]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action using a small, explicit dispatch.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(\"ROLE_ACT\", self.name, f\"Executing: {getattr(action, 'name', 'Action')}\")\n            except Exception:\n                pass\n\n        try:\n            # Code writer prefers instruct_content then content\n            if isinstance(action, SimpleWriteCode):\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            # Tester prefers code passed in the message; otherwise find latest code in env\n            elif isinstance(action, SimpleWriteTest):\n                code = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code = getattr(message, \"content\", \"\") or \"\"\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code)\n\n            # Reviewer tries to assemble code+tests from env\n            elif isinstance(action, SimpleWriteReview):\n                code = \"\"\n                tests = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests = getattr(message, \"content\", \"\") or \"\"\n                    if self.env:\n                        code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code = getattr(code_msg, \"content\", \"\") if code_msg else \"\"\n                else:\n                    if self.env:\n                        code_msg = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        test_msg = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        code = getattr(code_msg, \"content\", \"\") if code_msg else \"\"\n                        tests = getattr(test_msg, \"content\", \"\") if test_msg else \"\"\n                result = await action.run(code, tests)\n\n            else:\n                # Generic fallback: pass content or empty string\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            result = f\"Error in role {self.name} while executing action: {e}\"\n            if tracer:\n                try:\n                    tracer.log(\"ROLE_ERROR\", self.name, _safe_str(e))\n                except Exception:\n                    pass\n\n        # Construct response message robustly\n        try:\n            response = _make_message(result, self.profile, getattr(action, \"name\", \"\"), self.name)\n        except Exception:\n            # last-resort simple wrapper\n            try:\n                response = Message(result, self.profile)\n            except Exception:\n                # minimal ad-hoc object\n                class _SimpleMsg:\n                    def __init__(self, content, role, cause_by, sent_from):\n                        self.id = str(uuid.uuid4())\n                        self.content = content\n                        self.role = role\n                        self.cause_by = cause_by\n                        self.sent_from = sent_from\n                response = _SimpleMsg(_safe_str(result), self.profile, getattr(action, \"name\", \"\"), self.name)\n\n        if tracer:\n            try:\n                tracer.log(\"ROLE_COMPLETE\", self.name, f\"Message created (cause_by={getattr(action, 'name', '')})\")\n            except Exception:\n                pass\n\n        return response\n\nclass SimpleCoder(Role):\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # create action instance; Team.hire will refresh contexts\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Simple environment that stores messages and filters by cause_by.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return list(self.roles)\n\n    def publish_message(self, message: Message):\n        # Append safely and log summary\n        try:\n            self.history.append(message)\n            if self.tracer:\n                preview = _safe_str(getattr(message, \"content\", \"\"))[:120]\n                sender = getattr(message, \"sent_from\", getattr(message, \"role\", \"Unknown\"))\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"from={sender} cause={cause} preview={preview}\")\n        except Exception as e:\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", f\"publish failed: {e}\")\n                except Exception:\n                    pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by equals any name in role.watch_list\"\"\"\n        watched = set(role.watch_list or [])\n        if not watched:\n            return []\n        res: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    res.append(msg)\n            except Exception:\n                continue\n        return res\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together - orchestrates rounds deterministically.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles, attach shared context/env and refresh actions' context/LLM.\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env\n            # refresh action instances so they use current context\n            refreshed: List[Action] = []\n            for a in getattr(role, \"actions\", []) or []:\n                try:\n                    cls = a.__class__\n                    refreshed.append(cls(context=self.context))\n                except Exception:\n                    try:\n                        a.context = self.context\n                        refreshed.append(a)\n                    except Exception:\n                        continue\n            if refreshed:\n                role.set_actions(refreshed)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        # Build initial message robustly\n        initial = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            cause_by=\"UserInput\",\n            sent_from=\"User\"\n        )\n        self.env.publish_message(initial)\n\n        for round_num in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n                except Exception:\n                    pass\n\n            # Snapshot roles to avoid mutation issues\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # Round 0: coder should respond to user\n                    if round_num == 0 and getattr(role, \"profile\", \"\") == \"SimpleCoder\":\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        # Act on the most recent relevant message\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n                summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n### Inspiration 2 (Score: 3.2125, Type: High-Performer)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a stable string for logging/outputs.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        if isinstance(x, str):\n            return x\n        return str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance that works with pydantic or fallback Message safely.\"\"\"\n    content = _safe_str(content)\n    kwargs = {\n        \"content\": content,\n        \"role\": _safe_str(role),\n        \"cause_by\": _safe_str(cause_by),\n        \"sent_from\": _safe_str(sent_from) if sent_from is not None else None,\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    try:\n        # pydantic Message accepts keywords; fallback Message accepts keywords as well\n        return Message(**kwargs)\n    except Exception:\n        # Last-resort minimal object\n        class _M:\n            def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                self.id = str(uuid.uuid4())\n                self.content = content\n                self.instruct_content = instruct_content\n                self.role = role\n                self.cause_by = cause_by\n                self.sent_from = sent_from\n                self.sent_to = None\n                self.send_to = set()\n            def __str__(self):\n                return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n        return _M(content, kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Defensive, minimal base action with lazy LLM initialization.\"\"\"\n\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            try:\n                self._llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Idea: {idea[:120]}\")\n        prompt = (\n            \"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Clean, testable Python code\\n\"\n            \"2. Basic error handling\\n\"\n            \"3. Short comments\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                code = _safe_str(resp)\n            else:\n                # deterministic fallback to prevent flaky failures\n                code = (\n                    f\"# Implementation placeholder for: {idea}\\n\"\n                    \"def placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", f\"Code len: {len(code)}\")\n        snippet = code[:2000] if code else \"# no code provided\"\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation.\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt},\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = _safe_str(resp)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"is_human={self.is_human}\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider more edge-case tests and clearer errors.\"\n            else:\n                prompt = (\n                    \"You are a senior reviewer. Provide a concise review focusing on code quality, test coverage, and issues.\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests[:1500]}\\n\\n\"\n                    \"Keep it concise.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt},\n                ]\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = _safe_str(resp)\n                else:\n                    review = \"Automated review: Structure OK; consider adding more edge-case tests and clearer error handling.\"\n        except Exception as e:\n            review = f\"Error during review: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Review len {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simplified agent role: one primary action, optional watch list (names).\"\"\"\n\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list contains cause_by names to react to\n        self.watch_list: List[str] = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # ensure actions are instances and share context\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Any]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type):\n                names.append(getattr(a, \"name\", a.__name__))\n            else:\n                names.append(getattr(a, \"name\", str(a)))\n        self.watch_list = [n for n in names if n]\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> Optional[Message]:\n        \"\"\"Deterministic mapping from message -> action inputs, robust to missing data.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        action_name = getattr(action, \"name\", \"Action\")\n        env = env or self.env\n\n        self._log(\"ROLE_ACT\", f\"Action={action_name} message_id={getattr(message, 'id', None)}\")\n\n        try:\n            if action_name == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n\n            elif action_name == SimpleWriteTest.name:\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code_text = getattr(message, \"content\", \"\") or \"\"\n                if not code_text and env:\n                    latest = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code_text)\n\n            elif action_name == SimpleWriteReview.name:\n                code_text = \"\"\n                tests_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests_text = getattr(message, \"content\", \"\") or \"\"\n                if env:\n                    latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    latest_tests = env.get_latest_message_by_cause(SimpleWriteTest.name)\n                    code_text = code_text or (getattr(latest_code, \"content\", \"\") if latest_code else \"\")\n                    tests_text = tests_text or (getattr(latest_tests, \"content\", \"\") if latest_tests else \"\")\n                # ensure review action knows if role is human\n                if isinstance(action, SimpleWriteReview):\n                    try:\n                        action.is_human = self.is_human\n                    except Exception:\n                        pass\n                result = await action.run(code_text, tests_text)\n\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                try:\n                    result = await action.run(payload)\n                except TypeError:\n                    result = await action.run()\n        except Exception as e:\n            err = f\"Error executing {action_name}: {_safe_str(e)}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        # Build response message in a safe manner\n        response = _make_message(content=_safe_str(result), role=self.profile, cause_by=action_name, sent_from=self.name)\n        self._log(\"ROLE_COMPLETE\", f\"Created message (cause_by={action_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # coder listens to explicit user instruction (no watch list)\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Lightweight deterministic message bus with simple filtering and processed-tracking.\"\"\"\n\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n        # track last processed message id per role to avoid duplicates\n        self._last_processed: Dict[str, Optional[str]] = {}\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        self._last_processed.setdefault(role.name, None)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message and log a concise preview; never raise to caller.\"\"\"\n        try:\n            if not getattr(message, \"id\", None):\n                message.id = str(uuid.uuid4())\n        except Exception:\n            pass\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", getattr(message, \"role\", \"Unknown\"))\n                preview = (_safe_str(getattr(message, \"content\", \"\")))[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From={sender} Cause={cause} Preview={preview}\")\n        except Exception:\n            try:\n                if self.tracer:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", \"Failed to append message\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return unprocessed messages whose cause_by matches role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        res: List[Message] = []\n        last_id = self._last_processed.get(role.name)\n        start_index = 0\n        if last_id:\n            for idx, m in enumerate(self.history):\n                try:\n                    if getattr(m, \"id\", None) == last_id:\n                        start_index = idx + 1\n                        break\n                except Exception:\n                    continue\n        for m in self.history[start_index:]:\n            try:\n                if getattr(m, \"cause_by\", \"\") in role.watch_list:\n                    res.append(m)\n            except Exception:\n                continue\n        return res\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\n    def mark_processed(self, role: Role, message: Message):\n        try:\n            self._last_processed[role.name] = getattr(message, \"id\", None)\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_MARK\", \"Environment\", f\"Role {role.name} processed message {getattr(message, 'id', '')}\")\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\nclass Team:\n    \"\"\"Orchestrates roles and rounds with clear deterministic flow and robust logging.\"\"\"\n\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for role in (roles or []):\n            role.context = self.context\n            # update actions context\n            for a in getattr(role, \"actions\", []) or []:\n                try:\n                    a.context = role.context\n                except Exception:\n                    pass\n            role.env = self.env\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n\n        for rnd in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnd+1}/{n_round}\")\n                except Exception:\n                    pass\n\n            # process roles in deterministic order\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    if rnd == 0 and isinstance(role, SimpleCoder):\n                        response = await role.act(initial_msg, env=self.env)\n                        try:\n                            self.env.mark_processed(role, initial_msg)\n                        except Exception:\n                            pass\n                    else:\n                        msgs = self.env.get_messages_for_role(role)\n                        if not msgs:\n                            continue\n                        selected = msgs[-1]\n                        response = await role.act(selected, env=self.env)\n                        try:\n                            self.env.mark_processed(role, selected)\n                        except Exception:\n                            pass\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    # ensure message-like\n                    if not hasattr(response, \"content\"):\n                        try:\n                            response = _make_message(content=_safe_str(getattr(response, \"content\", \"\")),\n                                                     role=getattr(response, \"role\", getattr(role, \"profile\", \"Unknown\")),\n                                                     cause_by=_safe_str(getattr(response, \"cause_by\", \"\")),\n                                                     sent_from=_safe_str(getattr(response, \"sent_from\", getattr(role, \"name\", \"Unknown\"))))\n                        except Exception:\n                            try:\n                                response = Message(content=_safe_str(response), role=role.profile, cause_by=\"\", sent_from=role.name)\n                            except Exception:\n                                class _M:\n                                    def __init__(self, content, role, cause_by, sent_from):\n                                        self.id = str(uuid.uuid4())\n                                        self.content = content\n                                        self.role = role\n                                        self.cause_by = cause_by\n                                        self.sent_from = sent_from\n                                response = _M(_safe_str(response), role.profile, \"\", role.name)\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnd+1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n                summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n### Inspiration 3 (Score: 3.2125, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event_type: str, agent: str, details: str):\n    \"\"\"Best-effort logging that never throws.\"\"\"\n    if tracer:\n        try:\n            tracer.log(event_type, agent, details)\n        except Exception:\n            pass\n\ndef make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance compatible with both pydantic and fallback implementations.\"\"\"\n    kwargs = {\n        \"content\": content,\n        \"role\": role,\n        \"cause_by\": cause_by,\n        \"sent_from\": sent_from\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = instruct_content\n    try:\n        return Message(**kwargs)\n    except Exception:\n        # Try positional where pydantic is not present\n        try:\n            return Message(kwargs[\"content\"], kwargs[\"role\"],\n                           instruct_content=kwargs.get(\"instruct_content\"),\n                           cause_by=kwargs[\"cause_by\"],\n                           sent_from=kwargs[\"sent_from\"])\n        except Exception:\n            # Minimal fallback object\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n                def __str__(self):\n                    return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n            return _M(kwargs[\"content\"], kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Base action class with lazy LLM and safe logging.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, *, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        _safe_log(tracer, event, self.name, details)\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea_text = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea_text[:120]}\")\n        prompt = (\n            f\"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea_text}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write clean, functional Python code\\n\"\n            \"2. Include proper error handling\\n\"\n            \"3. Add comments explaining the logic\\n\"\n            \"4. Make it production-ready\\n\\n\"\n            \"Please provide only the code without any explanation.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                # Deterministic, safe fallback\n                code = (\n                    f\"# Implementation for: {idea_text}\\n\"\n                    \"def placeholder_function():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(code)} characters of code\")\n        return code\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code_text = (code or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing tests for code (len={len(code_text)})\")\n        snippet = code_text[:2000] if code_text else \"# No code provided\"\n        prompt = (\n            \"You are a QA engineer. Write comprehensive tests for the following code:\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Requirements:\\n\"\n            \"1. Write pytest-style test cases\\n\"\n            \"2. Cover edge cases and error conditions\\n\"\n            \"3. Include both positive and negative tests\\n\"\n            \"4. Add docstrings to explain what each test does\\n\\n\"\n            \"Please provide only the test code without any explanation.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} characters of tests\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code_text = (code or \"\").strip()\n        tests_text = (tests or \"\").strip()\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Review the following code and tests:\\n\\n\"\n                    f\"Code:\\n{code_text[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests_text[:1500]}\\n\\n\"\n                    \"Provide a brief review focusing on:\\n\"\n                    \"1. Code quality and best practices\\n\"\n                    \"2. Test coverage\\n\"\n                    \"3. Potential bugs or issues\\n\"\n                    \"4. Suggestions for improvement\\n\\n\"\n                    \"Keep your review concise and actionable.\"\n                )\n                messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                            {\"role\": \"user\", \"content\": prompt}]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Review: Code structure looks reasonable. Tests cover main functionality; add more edge cases.\"\n        except Exception as e:\n            review = f\"Error during review generation: {e}\"\n        self._log(\"ACTION_END\", f\"Review completed ({len(review)} chars)\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents (simplified).\"\"\"\n    def __init__(self, *, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list stores cause_by names (strings) to react to\n        self.watch_list: List[str] = []\n        # environment reference set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # Bind context into action instances and keep them per-instance (no shared mutable)\n        bound: List[Action] = []\n        for a in actions or []:\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                a.context = self.context\n            bound.append(a)\n        self.actions = bound\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif isinstance(a, type) and hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"__name__\"))\n        self.watch_list = [n for n in names if n]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform primary action based on a message; returns a Message or None.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ACT\", self.name, f\"Executing action: {getattr(action, 'name', 'Action')}\")\n        try:\n            # Map inputs according to action type\n            if getattr(action, \"name\", \"\") == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n            elif getattr(action, \"name\", \"\") == SimpleWriteTest.name:\n                # Prefer code from message (if coder produced it), else search environment history\n                code = \"\"\n                if message and getattr(message, \"content\", None):\n                    code = message.content\n                elif self.env:\n                    latest = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest, \"content\", \"\") if latest else \"\"\n                result = await action.run(code)\n            elif getattr(action, \"name\", \"\") == SimpleWriteReview.name:\n                # Gather code and tests from message or environment\n                code = \"\"\n                tests = \"\"\n                if message:\n                    tests = getattr(message, \"content\", \"\") or \"\"\n                    code = getattr(message, \"instruct_content\", \"\") or \"\"\n                if self.env:\n                    if not code:\n                        latest_code = self.env.get_latest_message_by_cause(SimpleWriteCode.name)\n                        code = getattr(latest_code, \"content\", \"\") if latest_code else code\n                    if not tests:\n                        latest_tests = self.env.get_latest_message_by_cause(SimpleWriteTest.name)\n                        tests = getattr(latest_tests, \"content\", \"\") if latest_tests else tests\n                result = await action.run(code, tests)\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(payload)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, f\"Exception during act: {e}\")\n            result = f\"Error in role {self.name}: {e}\"\n\n        response = make_message(\n            content=result,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"\"),\n            sent_from=self.name\n        )\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_COMPLETE\", self.name, \"Action completed, message created\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # coder responds to user input explicitly\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        is_human = kwargs.get(\"is_human\", False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return list(self.roles)\n\n    def publish_message(self, message: Message):\n        # append and log safely\n        try:\n            self.history.append(message)\n            preview = (getattr(message, \"content\", \"\") or \"\")[:100]\n            sender = getattr(message, \"sent_from\", \"unknown\")\n            _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"Message from {sender}: {preview}\")\n        except Exception:\n            # best-effort attempt to normalize and store minimal info\n            try:\n                minimal = make_message(str(getattr(message, \"content\", \"\")), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"), sent_from=getattr(message, \"sent_from\", \"unknown\"))\n                self.history.append(minimal)\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        relevant: List[Message] = []\n        watched = set(role.watch_list or [])\n        if not watched:\n            return relevant\n        for m in self.history:\n            try:\n                if getattr(m, \"cause_by\", \"\") in watched:\n                    relevant.append(m)\n            except Exception:\n                continue\n        return relevant\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # ensure tracer in context\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team; ensure contexts for role actions are aligned\"\"\"\n        for role in roles:\n            role.context = role.context or self.context\n            role.env = self.env\n            # ensure actions know the team's context\n            for a in role.actions:\n                a.context = a.context or self.context\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea\n        _safe_log(self.tracer, \"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n\n    async def run(self, n_round: int = 3):\n        _safe_log(self.tracer, \"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        # initial message (user instruction)\n        initial = make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial)\n\n        for round_num in range(n_round):\n            _safe_log(self.tracer, \"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            # roles act in deterministic order\n            for role in list(self.env.roles):\n                response: Optional[Message] = None\n                try:\n                    if round_num == 0 and isinstance(role, SimpleCoder):\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    _safe_log(self.tracer, \"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"{e}\")\n                    response = None\n                if response:\n                    self.env.publish_message(response)\n            _safe_log(self.tracer, \"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n\n        _safe_log(self.tracer, \"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        _safe_log(self.tracer, \"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n### Inspiration 4 (Score: 3.2125, Type: Migrant)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    name: str = \"Action\"\n    context: Optional[Context] = None\n    llm: Optional[LLMInterface] = None\n    \n    def __init__(self, **kwargs):\n        self.context = kwargs.get('context')\n        if self.context and self.context.config.llm:\n            self.llm = LLMInterface(self.context.config.llm)\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs):\n        \"\"\"Run the action\"\"\"\n        pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Writing code for: {idea[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nPlease provide only the code without any explanation.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            code = await self.llm.ask(messages)\n        else:\n            code = f\"# Implementation for: {idea}\\n# [Code would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(code)} characters of code\")\n        \n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str) -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{code[:2000]}  # Truncate if too long\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nPlease provide only the test code without any explanation.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        if self.llm:\n            tests = await self.llm.ask(messages)\n        else:\n            tests = f\"# Tests for the implementation\\n# [Tests would be generated here]\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Generated {len(tests)} characters of tests\")\n        \n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests\"\"\"\n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        if self.is_human:\n            # Simulate human review\n            review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n        else:\n            prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{code[:1500]}\n\nTests:\n{tests[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n            \n            messages = [\n                {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            \n            if self.llm:\n                review = await self.llm.ask(messages)\n            else:\n                review = \"Review: Code structure looks good. Tests cover main functionality.\"\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ACTION_END\", self.name, f\"Review completed: {len(review)} characters\")\n        \n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    context: Optional[Context] = None\n    actions: List[Action] = []\n    watch_list: List[Type[Action]] = []\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context = kwargs.get('context')\n        self.is_human = kwargs.get('is_human', False)\n        self.actions = []\n        self.watch_list = []\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform\"\"\"\n        self.actions = actions\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for\"\"\"\n        self.watch_list = actions\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        if not self.actions:\n            return None\n        \n        # Execute the first action (simplified)\n        action = self.actions[0]\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_ACT\", self.name, f\"Executing action: {action.name}\")\n        \n        # Execute action based on type\n        if isinstance(action, SimpleWriteCode):\n            if message and hasattr(message, 'instruct_content'):\n                result = await action.run(message.instruct_content or message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteTest):\n            if message:\n                result = await action.run(message.content)\n            else:\n                result = await action.run(\"\")\n        elif isinstance(action, SimpleWriteReview):\n            # For review, we need both code and tests\n            if message:\n                # Extract code and tests from previous messages (simplified)\n                result = await action.run(message.content, \"\")\n            else:\n                result = await action.run(\"\", \"\")\n        else:\n            result = \"Action completed\"\n        \n        # Create response message\n        response = Message(\n            content=result,\n            role=self.profile,\n            cause_by=action.name if action else \"\",\n            sent_from=self.name\n        )\n        \n        if self.context and self.context.tracer:\n            self.context.tracer.log(\"ROLE_COMPLETE\", self.name, f\"Action completed, message created\")\n        \n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        if self.tracer:\n            self.tracer.log(\"ENV_MESSAGE\", \"Environment\", \n                          f\"Message from {message.sent_from}: {message.content[:100]}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages = []\n        for msg in self.history:\n            # Check if this message is from an action the role watches\n            for watched_action in role.watch_list:\n                if msg.cause_by == watched_action.name:\n                    relevant_messages.append(msg)\n                    break\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            role.context = self.context\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Each role acts in sequence\n            for role in self.env.roles:\n                # Determine what messages this role should respond to\n                if round_num == 0 and isinstance(role, SimpleCoder):\n                    # Coder responds to initial message\n                    response = await role.act(initial_msg)\n                else:\n                    # Other roles respond to relevant messages\n                    relevant_msgs = self.env.get_messages_for_role(role)\n                    if relevant_msgs:\n                        response = await role.act(relevant_msgs[-1])  # Act on most recent relevant message\n                    else:\n                        continue\n                \n                if response:\n                    self.env.publish_message(response)\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Alternative overall_score approach, Alternative combined_score approach\n\n\n### Inspiration 5 (Score: 3.2125, Type: High-Performer)\n```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Return a string safely without raising.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Robustly construct a Message instance compatible with both pydantic and fallback implementations.\n    \"\"\"\n    content = _safe_str(content)\n    try:\n        return Message(content=content, instruct_content=instruct_content, role=role, cause_by=cause_by or \"\", sent_from=sent_from)\n    except Exception:\n        try:\n            return Message(content, role, instruct_content=instruct_content, cause_by=cause_by or \"\", sent_from=sent_from)\n        except Exception:\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n            return _M(content, role, cause_by or \"\", sent_from, instruct_content)\n\nclass Action(ABC):\n    \"\"\"Minimal action base with lazy LLM and safe logging.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, getattr(self, \"name\", \"Action\"), details)\n            except Exception:\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements.\"\"\"\n    name = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea = _safe_str(idea).strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code for the task.\\n\\n\"\n            f\"Task:\\n{idea}\\n\\n\"\n            \"Requirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\n\"\n            \"Return only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n                code = _safe_str(code)\n            else:\n                code = (\n                    f\"# Implementation for: {idea}\\n\"\n                    \"def placeholder_function():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'placeholder'\\n\"\n                    \"    except Exception as e:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(code)} chars\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code.\"\"\"\n    name = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code = _safe_str(code)\n        self._log(\"ACTION_START\", \"Writing tests for code\")\n        prompt = (\n            \"You are an expert QA engineer. Write pytest-style tests (positive and negative) for the following implementation.\\n\\n\"\n            f\"Code:\\n{code[:2000]}\\n\\n\"\n            \"Return only the test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n                tests = _safe_str(tests)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests.\"\"\"\n    name = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code = _safe_str(code)\n        tests = _safe_str(tests)\n        self._log(\"ACTION_START\", f\"Reviewing (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider adding more edge-case tests and clearer errors.\"\n            else:\n                prompt = (\n                    \"You are a senior engineer. Provide a concise review focusing on code quality, test coverage, and potential issues.\\n\\n\"\n                    f\"Code:\\n{code[:1500]}\\n\\nTests:\\n{tests[:1500]}\\n\\nKeep it concise and actionable.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                    review = _safe_str(review)\n                else:\n                    review = \"Automated review: Acceptable structure; consider more edge cases and clearer error handling.\"\n        except Exception as e:\n            review = f\"Error during review: {_safe_str(e)}\"\n        self._log(\"ACTION_END\", f\"Review length {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Simple role with deterministic, readable behavior.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list contains action names (strings) this role reacts to\n        self.watch_list: List[str] = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                a.context = self.context\n            except Exception:\n                pass\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action]]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                try:\n                    names.append(getattr(a, \"name\"))\n                except Exception:\n                    pass\n            elif isinstance(a, type):\n                names.append(getattr(a, \"name\", a.__name__))\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    def _gather_inputs(self, action_name: str, message: Optional[Message], env: Optional[\"Environment\"]) -> Dict[str, str]:\n        \"\"\"Collect inputs for a given action in a straightforward way.\"\"\"\n        data = {\"idea\": \"\", \"code\": \"\", \"tests\": \"\"}\n        if action_name == SimpleWriteCode.name:\n            if message:\n                data[\"idea\"] = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n        elif action_name == SimpleWriteTest.name:\n            # Prefer code from triggering message; else find latest code in env\n            if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                data[\"code\"] = getattr(message, \"content\", \"\") or \"\"\n            elif env:\n                latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                data[\"code\"] = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n        elif action_name == SimpleWriteReview.name:\n            # Prefer tests from triggering message and latest code from env\n            if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                data[\"tests\"] = getattr(message, \"content\", \"\") or \"\"\n            if env:\n                latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                latest_tests = env.get_latest_message_by_cause(SimpleWriteTest.name)\n                if not data[\"code\"]:\n                    data[\"code\"] = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                if not data[\"tests\"]:\n                    data[\"tests\"] = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n        return data\n\n    async def act(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> Optional[Message]:\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions available\")\n            return None\n\n        env = env or self.env\n\n        # Default to first action; if message has instruct_content, prefer code action; else map by cause\n        selected = self.actions[0]\n        if message and getattr(message, \"instruct_content\", None):\n            for a in self.actions:\n                if getattr(a, \"name\", \"\") == SimpleWriteCode.name:\n                    selected = a\n                    break\n        else:\n            cause = getattr(message, \"cause_by\", \"\") if message else \"\"\n            if cause == SimpleWriteCode.name:\n                for a in self.actions:\n                    if getattr(a, \"name\", \"\") == SimpleWriteTest.name:\n                        selected = a\n                        break\n            elif cause == SimpleWriteTest.name:\n                for a in self.actions:\n                    if getattr(a, \"name\", \"\") == SimpleWriteReview.name:\n                        selected = a\n                        break\n\n        act_name = getattr(selected, \"name\", \"Action\")\n        self._log(\"ROLE_ACT\", f\"Executing {act_name}\")\n\n        try:\n            inputs = self._gather_inputs(act_name, message, env)\n            if act_name == SimpleWriteCode.name:\n                result = await selected.run(inputs[\"idea\"])\n            elif act_name == SimpleWriteTest.name:\n                result = await selected.run(inputs[\"code\"])\n            elif act_name == SimpleWriteReview.name:\n                # Propagate human flag\n                if isinstance(selected, SimpleWriteReview):\n                    selected.is_human = self.is_human\n                result = await selected.run(inputs[\"code\"], inputs[\"tests\"])\n            else:\n                payload = getattr(message, \"content\", \"\") if message else \"\"\n                result = await selected.run(payload)\n        except Exception as e:\n            self._log(\"ROLE_ERROR\", f\"Action failed: {_safe_str(e)}\")\n            result = f\"Error executing action: {_safe_str(e)}\"\n\n        response = _make_message(\n            content=result,\n            role=self.profile,\n            cause_by=act_name,\n            sent_from=self.name\n        )\n        self._log(\"ROLE_COMPLETE\", f\"Produced message (cause_by={act_name})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # coder reacts to explicit user instruction\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration with clear, safe routing.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        try:\n            role.env = self\n        except Exception:\n            pass\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        \"\"\"Append message and log a short preview without raising.\"\"\"\n        try:\n            self.history.append(message)\n            if self.tracer:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                preview = _safe_str(getattr(message, \"content\", \"\"))[:120]\n                cause = getattr(message, \"cause_by\", \"\")\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {sender} (cause={cause}): {preview}\")\n        except Exception:\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ENV_ERROR\", \"Environment\", \"Failed to publish message\")\n                except Exception:\n                    pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any name in role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        results: List[Message] = []\n        try:\n            watched = set(role.watch_list)\n            for m in self.history:\n                try:\n                    if getattr(m, \"cause_by\", \"\") in watched:\n                        results.append(m)\n                except Exception:\n                    continue\n        except Exception:\n            pass\n        return results\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Fetch the most recent message with a given cause.\"\"\"\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Deterministic orchestrator with simplified, robust flow.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        try:\n            # expose env in context for potential lookups\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in (roles or []):\n            try:\n                r.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n            except Exception:\n                pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n            except Exception:\n                pass\n\n        # Initial user message\n        initial = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            role=\"Human\",\n            cause_by=\"UserInput\",\n            sent_from=\"User\",\n            instruct_content=self.idea\n        )\n        self.env.publish_message(initial)\n\n        for round_num in range(n_round):\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n                except Exception:\n                    pass\n\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: coder responds to explicit user instruction\n                    if round_num == 0 and getattr(role, \"profile\", \"\") == \"SimpleCoder\":\n                        response = await role.act(initial, env=self.env)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1], env=self.env)\n                        else:\n                            continue\n                except Exception as e:\n                    if self.tracer:\n                        try:\n                            self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                        except Exception:\n                            pass\n                    continue\n\n                if response:\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n\n            if self.tracer:\n                try:\n                    self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n                except Exception:\n                    pass\n\n        if self.tracer:\n            try:\n                self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n            except Exception:\n                pass\n\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        if self.tracer:\n            try:\n                self.tracer.log(\"SUMMARY\", \"Team\", summary)\n            except Exception:\n                pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nUnique approach: Modification: Full rewrite, Alternative overall_score approach\n\n\n\n# Current Program\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event_type: str, agent: str, details: str):\n    \"\"\"Best-effort logging that never throws.\"\"\"\n    if tracer:\n        try:\n            tracer.log(event_type, agent, details)\n        except Exception:\n            pass\n\ndef make_message(content: str, role: str, cause_by: str, sent_from: str, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Create a Message instance compatible with both pydantic and fallback implementations.\"\"\"\n    kwargs = {\n        \"content\": content,\n        \"role\": role,\n        \"cause_by\": cause_by,\n        \"sent_from\": sent_from\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = instruct_content\n    try:\n        return Message(**kwargs)\n    except Exception:\n        return Message(kwargs[\"content\"], kwargs[\"role\"],\n                       instruct_content=kwargs.get(\"instruct_content\"),\n                       cause_by=kwargs[\"cause_by\"],\n                       sent_from=kwargs[\"sent_from\"])\n\nclass Action(ABC):\n    \"\"\"Base action class with unified execution wrapper.\"\"\"\n    name: str = \"Action\"\n    \n    def __init__(self, **kwargs):\n        self.context: Optional[Context] = kwargs.get('context')\n        self.llm: Optional[LLMInterface] = None\n        if self.context and getattr(self.context, \"config\", None) and getattr(self.context.config, \"llm\", None):\n            try:\n                self.llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                self.llm = None\n    \n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a string result\"\"\"\n        raise NotImplementedError\n    \n    async def execute(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> str:\n        \"\"\"\n        Unified execution wrapper for mapping message/environment to concrete action inputs.\n        Keeps logic central to reduce branching and failure surface.\n        \"\"\"\n        try:\n            aname = getattr(self, \"name\", \"\") or self.__class__.__name__\n            if aname == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                return await self.run(idea)\n            if aname == SimpleWriteTest.name:\n                # Prefer explicit code from message; otherwise grab latest code from env.\n                code = getattr(message, \"content\", \"\") if message else \"\"\n                if not code and env:\n                    latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    if latest_code:\n                        code = getattr(latest_code, \"content\", \"\") or \"\"\n                return await self.run(code)\n            if aname == SimpleWriteReview.name:\n                # Needs both code and tests; search env for latest items if missing.\n                tests = getattr(message, \"content\", \"\") if message else \"\"\n                code = getattr(message, \"instruct_content\", \"\") if message else \"\"\n                if not code and env:\n                    latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    if latest_code:\n                        code = getattr(latest_code, \"content\", \"\") or \"\"\n                if not tests and env:\n                    latest_tests = env.get_latest_message_by_cause(SimpleWriteTest.name)\n                    if latest_tests:\n                        tests = getattr(latest_tests, \"content\", \"\") or \"\"\n                return await self.run(code, tests)\n            # Fallback for unknown actions\n            return await self.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_EXCEPTION\", getattr(self, \"name\", \"Action\"), str(e))\n            return f\"Error executing {getattr(self, 'name', 'Action')}: {e}\"\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    name: str = \"SimpleWriteCode\"\n    \n    async def run(self, idea: str = \"\") -> str:\n        \"\"\"Generate code based on the idea\"\"\"\n        idea_text = (idea or \"\").strip()\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"Writing code for: {idea_text[:100]}\")\n        \n        prompt = f\"\"\"You are a professional programmer. Write Python code for the following task:\nTask: {idea_text}\n\nRequirements:\n1. Write clean, functional Python code\n2. Include proper error handling\n3. Add comments explaining the logic\n4. Make it production-ready\n\nPlease provide only the code without any explanation.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                code = (\n                    f\"# Implementation for: {idea_text}\\n\"\n                    \"def placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return 'ok'\\n\"\n                    \"    except Exception as exc:\\n\"\n                    \"        raise exc\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {e}\"\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"Generated {len(code)} characters of code\")\n        return code\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    name: str = \"SimpleWriteTest\"\n    \n    async def run(self, code: str = \"\") -> str:\n        \"\"\"Generate tests for the given code\"\"\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, \"Writing tests for code\")\n        \n        snippet = (code or \"\")[:2000]\n        prompt = f\"\"\"You are a QA engineer. Write comprehensive tests for the following code:\n\nCode:\n{snippet}  # Truncate if too long\n\nRequirements:\n1. Write pytest-style test cases\n2. Cover edge cases and error conditions\n3. Include both positive and negative tests\n4. Add docstrings to explain what each test does\n\nPlease provide only the test code without any explanation.\"\"\"\n        \n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test until LLM is available.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {e}\"\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"Generated {len(tests)} characters of tests\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    name: str = \"SimpleWriteReview\"\n    \n    def __init__(self, is_human: bool = False, **kwargs):\n        super().__init__(**kwargs)\n        self.is_human = is_human\n    \n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        \"\"\"Review the code and tests\"\"\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"Reviewing code (human={self.is_human})\")\n        \n        try:\n            if self.is_human:\n                review = \"Human review: The code looks good overall. Consider adding more error handling.\"\n            else:\n                prompt = f\"\"\"You are a senior code reviewer. Review the following code and tests:\n\nCode:\n{(code or '')[:1500]}\n\nTests:\n{(tests or '')[:1500]}\n\nProvide a brief review focusing on:\n1. Code quality and best practices\n2. Test coverage\n3. Potential bugs or issues\n4. Suggestions for improvement\n\nKeep your review concise and actionable.\"\"\"\n                \n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                \n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Review: Code structure looks reasonable. Tests cover main functionality; add more edge cases.\"\n        except Exception as e:\n            review = f\"Error during review generation: {e}\"\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"Review completed: {len(review)} characters\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents with simplified action handling\"\"\"\n    name: str = \"Role\"\n    profile: str = \"Default\"\n    \n    def __init__(self, **kwargs):\n        self.name = kwargs.get('name', self.name)\n        self.profile = kwargs.get('profile', self.profile)\n        self.context: Optional[Context] = kwargs.get('context')\n        self.is_human: bool = kwargs.get('is_human', False)\n        self.actions: List[Action] = []\n        # watch_list stores action names (strings) for simpler comparisons\n        self.watch_list: List[str] = []\n        # environment reference set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n    \n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform (ensure action contexts are aligned)\"\"\"\n        self.actions = actions or []\n        for a in self.actions:\n            a.context = self.context\n            try:\n                if self.context:\n                    a.llm = LLMInterface(self.context.config.llm)\n            except Exception:\n                a.llm = None\n    \n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for. Accept types or names.\"\"\"\n        names: List[str] = []\n        for a in actions or []:\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type) and hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n        self.watch_list = names\n    \n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform the primary action based on a message.\"\"\"\n        if not self.actions:\n            return None\n        \n        action = self.actions[0]\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ACT\", self.name, f\"Executing action: {getattr(action, 'name', 'Action')}\")\n        \n        try:\n            result = await action.execute(message=message, env=self.env)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, f\"Exception during act: {e}\")\n            result = f\"Error in role {self.name}: {e}\"\n        \n        response = make_message(\n            content=result,\n            role=self.profile,\n            cause_by=getattr(action, \"name\", \"\"),\n            sent_from=self.name\n        )\n        \n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_COMPLETE\", self.name, \"Action completed, message created\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    name: str = \"Alice\"\n    profile: str = \"SimpleCoder\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        # create action instances lazily with given context\n        self.set_actions([SimpleWriteCode(context=self.context)])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    name: str = \"Bob\"\n    profile: str = \"SimpleTester\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watch by action name to avoid fragile type checks\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    name: str = \"Charlie\"\n    profile: str = \"SimpleReviewer\"\n    \n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        self.history.append(message)\n        preview = \"\"\n        try:\n            preview = (getattr(message, \"content\", \"\") or \"\")[:100]\n        except Exception:\n            preview = \"\"\n        _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"Message from {getattr(message, 'sent_from', 'unknown')}: {preview}\")\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to\"\"\"\n        relevant_messages: List[Message] = []\n        watched = set(role.watch_list or [])\n        if not watched:\n            return relevant_messages\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    relevant_messages.append(msg)\n            except Exception:\n                continue\n        return relevant_messages\n    \n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        \"\"\"Return the most recent message with matching cause_by\"\"\"\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause_name:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        self.context.tracer = self.tracer\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team and ensure contexts for role actions are aligned\"\"\"\n        for role in roles:\n            role.context = self.context\n            role.env = self.env  # allow roles to inspect environment history\n            if hasattr(role, \"actions\"):\n                for a in role.actions:\n                    a.context = self.context\n                    try:\n                        a.llm = LLMInterface(self.context.config.llm)\n                    except Exception:\n                        a.llm = None\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {idea}\")\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Each role acts in sequence\n            for role in list(self.env.roles):\n                response: Optional[Message] = None\n                try:\n                    if round_num == 0 and isinstance(role, SimpleCoder):\n                        # Coder responds to initial message\n                        response = await role.act(initial_msg)\n                    else:\n                        # Other roles respond to relevant messages\n                        relevant_msgs = self.env.get_messages_for_role(role)\n                        if not relevant_msgs:\n                            continue\n                        response = await role.act(relevant_msgs[-1])\n                except Exception as e:\n                    self.tracer.log(\"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), f\"{e}\")\n                    response = None\n                \n                if response:\n                    self.env.publish_message(response)\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        self.tracer.log(\"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _safe_str(x: Any) -> str:\n    \"\"\"Convert value to string safely.\"\"\"\n    try:\n        if x is None:\n            return \"\"\n        return x if isinstance(x, str) else str(x)\n    except Exception:\n        return \"\"\n\ndef _safe_log(tracer: Optional[ExecutionTracer], event: str, agent: str, details: str):\n    \"\"\"Best-effort logging that never raises.\"\"\"\n    if tracer:\n        try:\n            tracer.log(event, agent, _safe_str(details))\n        except Exception:\n            pass\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None) -> Message:\n    \"\"\"Robust message construction compatible with both pydantic and fallback.\"\"\"\n    kwargs = {\n        \"content\": _safe_str(content),\n        \"role\": _safe_str(role),\n        \"cause_by\": _safe_str(cause_by),\n        \"sent_from\": _safe_str(sent_from) if sent_from is not None else None,\n    }\n    if instruct_content is not None:\n        kwargs[\"instruct_content\"] = _safe_str(instruct_content)\n    try:\n        return Message(**kwargs)\n    except Exception:\n        try:\n            # fallback positional\n            return Message(kwargs[\"content\"], kwargs[\"role\"],\n                           instruct_content=kwargs.get(\"instruct_content\"),\n                           cause_by=kwargs[\"cause_by\"],\n                           sent_from=kwargs[\"sent_from\"])\n        except Exception:\n            # minimal ad-hoc message-like object\n            class _M:\n                def __init__(self, content, role, cause_by, sent_from, instruct_content=None):\n                    self.id = str(uuid.uuid4())\n                    self.content = content\n                    self.instruct_content = instruct_content\n                    self.role = role\n                    self.cause_by = cause_by\n                    self.sent_from = sent_from\n                    self.sent_to = None\n                    self.send_to = set()\n                def __str__(self):\n                    return f\"Message(role={self.role}, content={self.content[:50]}...)\"\n            return _M(kwargs[\"content\"], kwargs[\"role\"], kwargs[\"cause_by\"], kwargs[\"sent_from\"], kwargs.get(\"instruct_content\"))\n\nclass Action(ABC):\n    \"\"\"Minimal action base with lazy LLM and a single entrypoint to reduce branching.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Implement action logic and return a string result.\"\"\"\n        raise NotImplementedError\n\n    async def execute(self, message: Optional[Message] = None, env: Optional[\"Environment\"] = None) -> str:\n        \"\"\"\n        Centralized mapping from incoming message/environment -> run() arguments.\n        Keeps control flow in one place and reduces surface area for bugs.\n        \"\"\"\n        try:\n            aname = getattr(self, \"name\", \"\") or self.__class__.__name__\n            if aname == SimpleWriteCode.name:\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                return await self.run(idea)\n            if aname == SimpleWriteTest.name:\n                code = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name:\n                    code = getattr(message, \"content\", \"\") or \"\"\n                if not code and env:\n                    latest = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest, \"content\", \"\") if latest else \"\"\n                return await self.run(code)\n            if aname == SimpleWriteReview.name:\n                code = \"\"\n                tests = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name:\n                    tests = getattr(message, \"content\", \"\") or \"\"\n                if not code and env:\n                    latest_code = env.get_latest_message_by_cause(SimpleWriteCode.name)\n                    code = getattr(latest_code, \"content\", \"\") if latest_code else \"\"\n                if not tests and env:\n                    latest_tests = env.get_latest_message_by_cause(SimpleWriteTest.name)\n                    tests = getattr(latest_tests, \"content\", \"\") if latest_tests else \"\"\n                return await self.run(code, tests)\n            # fallback: pass message content if any\n            return await self.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_EXCEPTION\", getattr(self, \"name\", \"Action\"), _safe_str(e))\n            return f\"Error executing {getattr(self, 'name', 'Action')}: {_safe_str(e)}\"\n\nclass SimpleWriteCode(Action):\n    \"\"\"Generate Python code for a given idea.\"\"\"\n    name: str = \"SimpleWriteCode\"\n\n    async def run(self, idea: str = \"\") -> str:\n        idea_text = _safe_str(idea).strip()\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"idea={idea_text[:120]}\")\n        prompt = (\n            f\"You are a professional programmer. Write Python code for the following task:\\n\"\n            f\"Task: {idea_text}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, testable Python code\\n\"\n            \"- Basic error handling\\n\"\n            \"- Short comments\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                code = await self.llm.ask(messages)\n            else:\n                # deterministic fallback to prevent flaky behavior\n                code = (\n                    f\"# Implementation placeholder for: {idea_text}\\n\"\n                    \"def placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder implementation.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            code = f\"# Error generating code: {_safe_str(e)}\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"len={len(_safe_str(code))}\")\n        return _safe_str(code)\n\nclass SimpleWriteTest(Action):\n    \"\"\"Generate pytest tests for provided code.\"\"\"\n    name: str = \"SimpleWriteTest\"\n\n    async def run(self, code: str = \"\") -> str:\n        code_text = _safe_str(code)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"code_len={len(code_text)}\")\n        snippet = code_text[:2000] if code_text else \"# no code provided\"\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the implementation below.\\n\\n\"\n            f\"Code:\\n{snippet}\\n\\n\"\n            \"Return only the pytest code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                tests = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder test.\\\"\\\"\\\"\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            tests = f\"# Error generating tests: {_safe_str(e)}\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"len={len(_safe_str(tests))}\")\n        return _safe_str(tests)\n\nclass SimpleWriteReview(Action):\n    \"\"\"Provide a concise review of code and tests.\"\"\"\n\n    name: str = \"SimpleWriteReview\"\n\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str = \"\", tests: str = \"\") -> str:\n        code_text = _safe_str(code)\n        tests_text = _safe_str(tests)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_START\", self.name, f\"is_human={self.is_human}\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider adding more edge-case tests and clearer error messages.\"\n            else:\n                prompt = (\n                    \"You are a senior code reviewer. Provide a concise, actionable review of the code and tests.\\n\\n\"\n                    f\"Code:\\n{code_text[:1500]}\\n\\n\"\n                    f\"Tests:\\n{tests_text[:1500]}\\n\\n\"\n                    \"Focus on quality, coverage, potential bugs, and suggestions.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Structure OK; add boundary tests and improve error handling.\"\n        except Exception as e:\n            review = f\"Error during review: {_safe_str(e)}\"\n        _safe_log(getattr(self.context, \"tracer\", None), \"ACTION_END\", self.name, f\"len={len(_safe_str(review))}\")\n        return _safe_str(review)\n\nclass Role(ABC):\n    \"\"\"Simple agent role abstraction with one primary action and optional watch_list.\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = bool(is_human)\n        self.actions: List[Action] = []\n        # watch_list contains cause_by names this role should react to\n        self.watch_list: List[str] = []\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # ensure actions have correct context and are independent instances\n        prepared: List[Action] = []\n        for a in (actions or []):\n            try:\n                a.context = a.context or self.context\n            except Exception:\n                a.context = self.context\n            prepared.append(a)\n        self.actions = prepared\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in (actions or []):\n            if isinstance(a, str):\n                names.append(a)\n            elif isinstance(a, type) and hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n        self.watch_list = [n for n in names if n]\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute primary action deterministically, returning a Message or None.\"\"\"\n        if not self.actions:\n            return None\n        action = self.actions[0]\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ACT\", self.name, f\"Action={getattr(action, 'name', '')}\")\n        try:\n            # Use centralized execute to map inputs robustly\n            result = await action.execute(message=message, env=self.env)\n        except Exception as e:\n            _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_ERROR\", self.name, _safe_str(e))\n            result = f\"Error in role {self.name}: {_safe_str(e)}\"\n        response = _make_message(content=result, role=self.profile, cause_by=getattr(action, \"name\", \"\"), sent_from=self.name)\n        _safe_log(getattr(self.context, \"tracer\", None), \"ROLE_COMPLETE\", self.name, f\"Produced message cause_by={getattr(action, 'name', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code.\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        self._watch([])  # coder directly responds to user input\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests.\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests.\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        is_human = kwargs.get(\"is_human\", False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Message store and filtering utilities; minimal and robust.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        _safe_log(self.tracer, \"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n\n    def publish_message(self, message: Message):\n        try:\n            self.history.append(message)\n            preview = (_safe_str(getattr(message, \"content\", \"\")) or \"\")[:120]\n            sender = getattr(message, \"sent_from\", getattr(message, \"role\", \"Unknown\"))\n            _safe_log(self.tracer, \"ENV_MESSAGE\", \"Environment\", f\"from={sender} cause={getattr(message, 'cause_by', '')} preview={preview}\")\n        except Exception as e:\n            _safe_log(self.tracer, \"ENV_ERROR\", \"Environment\", f\"Failed to publish message: {_safe_str(e)}\")\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        watched = set(role.watch_list or [])\n        if not watched:\n            return []\n        return [m for m in self.history if getattr(m, \"cause_by\", \"\") in watched]\n\n    def get_latest_message_by_cause(self, cause_name: str) -> Optional[Message]:\n        for m in reversed(self.history):\n            try:\n                if getattr(m, \"cause_by\", \"\") == cause_name:\n                    return m\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrator that manages roles, environment, and rounds deterministically.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        \"\"\"Add roles to team and bind shared context/environment. Refresh actions to ensure correct context.\"\"\"\n        for role in roles or []:\n            role.context = role.context or self.context\n            role.env = self.env\n            # Refresh action instances so each action gets current context\n            refreshed: List[Action] = []\n            for a in getattr(role, \"actions\", []) or []:\n                try:\n                    cls = a.__class__\n                    refreshed.append(cls(context=self.context))\n                except Exception:\n                    try:\n                        a.context = self.context\n                        refreshed.append(a)\n                    except Exception:\n                        continue\n            if refreshed:\n                role.set_actions(refreshed)\n            self.env.add_role(role)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = _safe_str(idea)\n        _safe_log(self.tracer, \"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n\n    async def run(self, n_round: int = 3):\n        rounds = max(1, int(n_round or 1))\n        _safe_log(self.tracer, \"TEAM_RUN\", \"Team\", f\"Running {rounds} rounds\")\n\n        # initial message\n        initial = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial)\n\n        for r in range(rounds):\n            _safe_log(self.tracer, \"ROUND_START\", \"Team\", f\"Round {r+1}/{rounds}\")\n            # snapshot roles\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # Round 0: coder(s) respond to initial user instruction\n                    if r == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial)\n                    else:\n                        relevant = self.env.get_messages_for_role(role)\n                        if not relevant:\n                            continue\n                        response = await role.act(relevant[-1])\n                except Exception as e:\n                    _safe_log(self.tracer, \"ROLE_EXCEPTION\", getattr(role, \"name\", \"Unknown\"), _safe_str(e))\n                    continue\n\n                if response:\n                    # ensure cause_by exists\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role.actions[0], \"name\", \"\") if role.actions else \"\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n            _safe_log(self.tracer, \"ROUND_END\", \"Team\", f\"Round {r+1} completed\")\n\n        _safe_log(self.tracer, \"TEAM_END\", \"Team\", \"Project completed\")\n        summary = f\"Project '{self.idea}' completed after {rounds} rounds with {len(self.env.history)} messages exchanged.\"\n        _safe_log(self.tracer, \"SUMMARY\", \"Team\", summary)\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}