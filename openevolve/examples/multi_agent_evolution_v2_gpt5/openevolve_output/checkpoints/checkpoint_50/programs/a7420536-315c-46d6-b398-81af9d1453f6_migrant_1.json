{"id": "a7420536-315c-46d6-b398-81af9d1453f6_migrant_1", "code": "\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Lightweight base action with safe LLM access and logging helpers.\"\"\"\n    name: str = \"Action\"\n\n    def __init__(self, *, context: Optional[Context] = None):\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily construct LLMInterface if configuration is present.\"\"\"\n        if self._llm is None and self.context is not None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg is not None and getattr(cfg, \"llm\", None) is not None:\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                # never allow tracing issues to propagate\n                pass\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        raise NotImplementedError\n\nclass SimpleWriteCode(Action):\n    name = \"SimpleWriteCode\"\n    def __init__(self, *, context: Optional[Context] = None):\n        super().__init__(context=context)\n\n    async def run(self, idea: str) -> str:\n        idea = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Preparing code generation (len={len(idea)})\")\n        if not idea:\n            # explicit deterministic fallback: small template that is valid Python\n            fallback = (\n                \"# No idea provided. Placeholder implementation\\n\"\n                \"def solution(*args, **kwargs):\\n\"\n                \"    \\\"\\\"\\\"Placeholder function.\\\"\\\"\\\"\\n\"\n                \"    return None\\n\"\n            )\n            self._log(\"ACTION_END\", \"Used deterministic fallback for code\")\n            return fallback\n\n        prompt = (\n            \"You are an expert Python programmer. Produce clear, correct Python code for the task below.\\n\\n\"\n            f\"Task: {idea}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Clean, testable code\\n\"\n            \"- Basic error handling when applicable\\n\"\n            \"- Short comments explaining non-obvious parts\\n\\n\"\n            \"Return only the code.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                result = f\"# Implementation for: {idea}\\n# [LLM not available - deterministic stub]\\n\"\n        except Exception as e:\n            result = f\"# Error generating code: {e}\\n\"\n        self._log(\"ACTION_END\", f\"Generated code (len={len(result)})\")\n        return result\n\nclass SimpleWriteTest(Action):\n    name = \"SimpleWriteTest\"\n    def __init__(self, *, context: Optional[Context] = None):\n        super().__init__(context=context)\n\n    async def run(self, code: str) -> str:\n        code = (code or \"\").strip()\n        self._log(\"ACTION_START\", f\"Preparing tests generation (code_len={len(code)})\")\n        if not code:\n            fallback = (\n                \"import pytest\\n\\n\"\n                \"def test_placeholder():\\n\"\n                \"    assert True\\n\"\n            )\n            self._log(\"ACTION_END\", \"Used deterministic fallback for tests\")\n            return fallback\n\n        prompt = (\n            \"You are a QA engineer. Write pytest-style tests for the provided implementation.\\n\\n\"\n            f\"Code (first 2000 chars):\\n{code[:2000]}\\n\\n\"\n            \"Requirements:\\n\"\n            \"- Use pytest\\n\"\n            \"- Cover typical and edge cases\\n\"\n            \"- Return only test code\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                result = (\n                    \"import pytest\\n\\n\"\n                    \"def test_placeholder():\\n\"\n                    \"    assert True\\n\"\n                )\n        except Exception as e:\n            result = f\"# Error generating tests: {e}\\n\"\n        self._log(\"ACTION_END\", f\"Generated tests (len={len(result)})\")\n        return result\n\nclass SimpleWriteReview(Action):\n    name = \"SimpleWriteReview\"\n    def __init__(self, *, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(context=context)\n        self.is_human = bool(is_human)\n\n    async def run(self, code: str, tests: str) -> str:\n        code = (code or \"\").strip()\n        tests = (tests or \"\").strip()\n        self._log(\"ACTION_START\", f\"Preparing review (code_len={len(code)}, tests_len={len(tests)}, human={self.is_human})\")\n        if self.is_human:\n            review = \"Human review: Looks good; consider adding more edge-case tests and clearer docstrings.\"\n            self._log(\"ACTION_END\", \"Produced human-like review\")\n            return review\n\n        prompt = (\n            \"You are a senior reviewer. Provide a concise actionable review of the code and tests.\\n\\n\"\n            f\"Code (first 1500 chars):\\n{code[:1500]}\\n\\n\"\n            f\"Tests (first 1500 chars):\\n{tests[:1500]}\\n\\n\"\n            \"Focus on readability, possible bugs, test coverage, and simple suggestions. Keep it short.\"\n        )\n        messages = [{\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                result = \"Automated review: Code structure acceptable. Consider more boundary tests.\"\n        except Exception as e:\n            result = f\"Review error: {e}\"\n        self._log(\"ACTION_END\", f\"Review generated (len={len(result)})\")\n        return result\n\nclass Role(ABC):\n    \"\"\"Simple role that holds one primary action and optional watch list.\"\"\"\n    def __init__(self, *, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = is_human\n        self.actions: List[Action] = []\n        # watch_list contains strings of cause_by values to react to\n        self.watch_list: List[str] = []\n        # env will be set by Team.hire\n        self.env: Optional[\"Environment\"] = None\n\n    def set_actions(self, actions: List[Action]):\n        # Bind context into actions for safety\n        bound: List[Action] = []\n        for a in actions or []:\n            a.context = a.context or self.context\n            bound.append(a)\n        self.actions = bound\n\n    def _watch(self, actions: List[Type[Action] or str]):\n        names: List[str] = []\n        for a in actions:\n            if isinstance(a, str):\n                names.append(a)\n            elif hasattr(a, \"name\"):\n                names.append(getattr(a, \"name\"))\n            elif hasattr(a, \"__name__\"):\n                names.append(getattr(a, \"__name__\"))\n        self.watch_list = [n for n in names if n]\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Execute the primary action deterministically and return a Message.\"\"\"\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions assigned\")\n            return None\n\n        action = self.actions[0]\n        self._log(\"ROLE_ACT\", f\"Action={action.name} MessageID={getattr(message, 'id', None)}\")\n\n        try:\n            if action.name == SimpleWriteCode.name:\n                idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\") or \"\"\n                result = await action.run(idea)\n            elif action.name == SimpleWriteTest.name:\n                # prefer code from the provided message; otherwise look up last code in environment\n                code_text = getattr(message, \"content\", \"\") if message else \"\"\n                if not code_text and self.env:\n                    last_code = self.env.get_latest_by_cause(SimpleWriteCode.name)\n                    code_text = getattr(last_code, \"content\", \"\") if last_code else \"\"\n                result = await action.run(code_text)\n            elif action.name == SimpleWriteReview.name:\n                # assemble code and tests from environment history when possible\n                code_text = \"\"\n                tests_text = \"\"\n                if self.env:\n                    last_code = self.env.get_latest_by_cause(SimpleWriteCode.name)\n                    last_tests = self.env.get_latest_by_cause(SimpleWriteTest.name)\n                    code_text = getattr(last_code, \"content\", \"\") if last_code else \"\"\n                    tests_text = getattr(last_tests, \"content\", \"\") if last_tests else \"\"\n                # message may contain part of this too (use to fill gaps)\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteCode.name and not code_text:\n                        code_text = getattr(message, \"content\", \"\")\n                    if getattr(message, \"cause_by\", \"\") == SimpleWriteTest.name and not tests_text:\n                        tests_text = getattr(message, \"content\", \"\")\n                result = await action.run(code_text, tests_text)\n            else:\n                # generic fallback, pass content if available\n                arg = getattr(message, \"content\", \"\") if message else \"\"\n                result = await action.run(arg)\n        except Exception as e:\n            err = f\"Action {action.name} failed: {e}\"\n            self._log(\"ROLE_ERROR\", err)\n            result = err\n\n        # Construct response message safely for both pydantic and plain implementations\n        try:\n            response = Message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n        except Exception:\n            # fallback minimal object\n            class Mini:\n                pass\n            response = Mini()\n            response.content = result\n            response.role = self.profile\n            response.cause_by = action.name\n            response.sent_from = self.name\n\n        self._log(\"ROLE_COMPLETE\", f\"Produced message (len={len(result)})\")\n        return response\n\nclass SimpleCoder(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Alice\")\n        profile = kwargs.get(\"profile\", \"SimpleCoder\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # coder listens to user input only (handled by Team)\n        self._watch([])\n\nclass SimpleTester(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Bob\")\n        profile = kwargs.get(\"profile\", \"SimpleTester\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        self._watch([SimpleWriteCode.name])\n\nclass SimpleReviewer(Role):\n    def __init__(self, **kwargs):\n        name = kwargs.get(\"name\", \"Charlie\")\n        profile = kwargs.get(\"profile\", \"SimpleReviewer\")\n        context = kwargs.get(\"context\")\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get(\"is_human\", False))\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        self._watch([SimpleWriteTest.name])\n\nclass Environment:\n    \"\"\"Tracks roles and message history; provides helper queries used by roles.\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n\n    def add_role(self, role: Role):\n        role.env = self\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n\n    def publish_message(self, message: Message):\n        try:\n            self.history.append(message)\n        except Exception:\n            # safe append: wrap into simple message if necessary\n            try:\n                m = Message(content=str(getattr(message, \"content\", \"\")), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                sender = getattr(message, \"sent_from\", \"Unknown\")\n                snippet = (getattr(message, \"content\", \"\") or \"\")[:100]\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"From {sender}: {snippet}\")\n            except Exception:\n                pass\n\n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Return messages whose cause_by matches any entry in role.watch_list.\"\"\"\n        if not role.watch_list:\n            return []\n        watched = set(role.watch_list)\n        relevant: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    relevant.append(msg)\n            except Exception:\n                continue\n        return relevant\n\n    def get_latest_by_cause(self, cause: str) -> Optional[Message]:\n        \"\"\"Return the most recent message with the given cause_by.\"\"\"\n        for msg in reversed(self.history):\n            try:\n                if getattr(msg, \"cause_by\", \"\") == cause:\n                    return msg\n            except Exception:\n                continue\n        return None\n\nclass Team:\n    \"\"\"Orchestrates roles, environment, and rounds in a deterministic and robust way.\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # ensure context tracer reference exists\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n\n    def hire(self, roles: List[Role]):\n        for r in roles:\n            try:\n                r.context = r.context or self.context\n                r.env = self.env\n                # ensure actions have context\n                for a in getattr(r, \"actions\", []):\n                    a.context = a.context or self.context\n            except Exception:\n                pass\n            self.env.add_role(r)\n\n    def invest(self, investment: float):\n        self.investment = investment\n\n    def run_project(self, idea: str):\n        self.idea = idea or \"\"\n        try:\n            self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n\n    async def run(self, n_round: int = 3):\n        n_round = max(1, int(n_round or 1))\n        try:\n            self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n\n        # Initial user message with instruct_content\n        initial = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial)\n\n        for rnum in range(n_round):\n            try:\n                self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {rnum+1}/{n_round}\")\n            except Exception:\n                pass\n\n            # deterministic order: coder(s) first, then tester(s), then reviewer(s)\n            for role in list(self.env.roles):\n                try:\n                    response = None\n                    # coder responds to initial instruction on first round\n                    if rnum == 0 and any(getattr(a, \"name\", \"\") == SimpleWriteCode.name for a in role.actions):\n                        response = await role.act(initial)\n                    else:\n                        candidates = self.env.get_messages_for_role(role)\n                        if not candidates:\n                            continue\n                        response = await role.act(candidates[-1])\n\n                    if response:\n                        # ensure cause_by set\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(role.actions[0], \"name\", \"UnknownAction\")\n                        self.env.publish_message(response)\n                except Exception as e:\n                    try:\n                        self.tracer.log(\"ROLE_EXCEPTION\", role.name, f\"Exception while acting: {e}\")\n                    except Exception:\n                        pass\n                    continue\n\n            try:\n                self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {rnum+1} completed\")\n            except Exception:\n                pass\n\n        try:\n            self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "a7420536-315c-46d6-b398-81af9d1453f6", "generation": 2, "timestamp": 1754647500.2912557, "iteration_found": 0, "metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 1, "migrant": true}, "artifacts_json": null, "artifact_dir": null}