{"id": "b9a545ce-781e-4faa-bc18-2960b2194a5e", "code": "\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Robust helper to construct Message objects compatible with both pydantic and fallback Message.\n    Returns either a Message instance or a minimal object with expected attributes.\n    \"\"\"\n    try:\n        # Try constructing pydantic Message (or the fallback class) with full fields\n        return Message(content=content, role=role, cause_by=cause_by or \"\", sent_from=sent_from, instruct_content=instruct_content)\n    except Exception:\n        # Last-resort minimal object\n        class _M:\n            pass\n        m = _M()\n        m.id = str(uuid.uuid4())\n        m.content = content\n        m.instruct_content = instruct_content\n        m.role = role\n        m.cause_by = cause_by or \"\"\n        m.sent_from = sent_from\n        m.sent_to = None\n        m.send_to = set()\n        return m\n\nclass Action(ABC):\n    \"\"\"Base action class with simplified, robust LLM access\"\"\"\n    def __init__(self, name: str = \"Action\", context: Optional[Context] = None):\n        self.name = name\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLM interface if available in context; safe and idempotent\"\"\"\n        if self._llm is None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a text result\"\"\"\n        raise NotImplementedError\n\n    def _log(self, event: str, details: str):\n        \"\"\"Safe logging helper\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                # Swallow tracer exceptions to reduce failure modes\n                pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteCode\", context=context)\n\n    async def run(self, idea: str) -> str:\n        idea = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code that fulfills the request.\\n\\n\"\n            f\"Task:\\n{idea}\\n\\nRequirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\nReturn only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                result = resp or \"\"\n            else:\n                # Stable deterministic fallback\n                result = (\n                    f\"# Implementation for: {idea}\\n\\n\"\n                    \"def solution():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            result = f\"# Error generating code: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(result)} chars\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteTest\", context=context)\n\n    async def run(self, code: str) -> str:\n        code_snippet = (code or \"\")[:2000]\n        self._log(\"ACTION_START\", \"Writing tests\")\n        prompt = (\n            \"You are an expert QA engineer. Given the implementation, write pytest tests (positive and negative).\\n\\n\"\n            f\"Code:\\n{code_snippet}\\n\\nReturn only test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = resp or \"\"\n            else:\n                tests = \"import pytest\\n\\ndef test_placeholder():\\n    assert True\\n\"\n        except Exception as e:\n            tests = f\"# Error generating tests: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteReview\", context=context)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        code_snippet = (code or \"\")[:1500]\n        tests_snippet = (tests or \"\")[:1500]\n        self._log(\"ACTION_START\", \"Reviewing\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider adding more edge-case tests and clearer error messages.\"\n            else:\n                prompt = (\n                    \"You are a senior engineer. Provide a concise review and actionable suggestions for improvements.\\n\\n\"\n                    f\"Code:\\n{code_snippet}\\n\\nTests:\\n{tests_snippet}\\n\\nBe concise.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = resp or \"Automated review: Acceptable structure; consider more tests.\"\n                else:\n                    review = \"Automated review: Acceptable structure; consider more tests and edge cases.\"\n        except Exception as e:\n            review = f\"Review error: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Review length {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents - simplified decision logic and robust behavior\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = is_human\n        self.actions: List[Action] = []\n        # watch_list contains cause_by strings that this role should respond to\n        self.watch_list: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions or []\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Normalize watched action identifiers into string names (robust)\"\"\"\n        names: Set[str] = set()\n        for a in (actions or []):\n            try:\n                if isinstance(a, str):\n                    names.add(a)\n                elif hasattr(a, \"name\"):\n                    # instance or class with 'name' attribute\n                    names.add(getattr(a, \"name\"))\n                elif hasattr(a, \"__name__\"):\n                    names.add(getattr(a, \"__name__\"))\n            except Exception:\n                continue\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    def _select_action_for_message(self, message: Optional[Message]) -> Optional[Action]:\n        \"\"\"\n        Deterministic selection:\n        - If message has instruct_content -> prefer SimpleWriteCode\n        - Else choose action based on watch_list mapping: if the message.cause_by is in this role's watch_list,\n          then map that cause to the most appropriate action by known mapping.\n        - Else default to first action.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        # Prefer explicit instruction to coder\n        if message and getattr(message, \"instruct_content\", None):\n            for action in self.actions:\n                if action.name == \"SimpleWriteCode\":\n                    return action\n\n        cause = getattr(message, \"cause_by\", \"\") if message else \"\"\n        if cause and cause in (self.watch_list or set()):\n            # Simple mapping: when coder output -> tester, when tester output -> reviewer\n            if cause == \"SimpleWriteCode\":\n                for action in self.actions:\n                    if action.name == \"SimpleWriteTest\":\n                        return action\n            if cause == \"SimpleWriteTest\":\n                for action in self.actions:\n                    if action.name == \"SimpleWriteReview\":\n                        return action\n\n        # Default fallback\n        return self.actions[0] if self.actions else None\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message; always returns a Message-like object or None\"\"\"\n        self._log(\"ROLE_ACT\", f\"Acting on message {getattr(message, 'id', 'none')}\")\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions\")\n            return None\n\n        action = self._select_action_for_message(message)\n        if not action:\n            self._log(\"ROLE_SKIP\", \"No action selected\")\n            return None\n\n        try:\n            # Prepare inputs based on action type (explicit and simple)\n            if action.name == \"SimpleWriteCode\":\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\")\n                result = await action.run(idea)\n            elif action.name == \"SimpleWriteTest\":\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                    code_text = getattr(message, \"content\", \"\")\n                else:\n                    # Try to find last code from environment history\n                    code_text = \"\"\n                    try:\n                        hist = getattr(self.context, \"tracer\", None)\n                        # Avoid parsing tracer; rely on environment history if available\n                        env = getattr(self.context, \"env\", None)\n                        if env:\n                            for m in reversed(getattr(env, \"history\", []) or []):\n                                if getattr(m, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                                    code_text = getattr(m, \"content\", \"\")\n                                    break\n                    except Exception:\n                        code_text = \"\"\n                result = await action.run(code_text)\n            elif action.name == \"SimpleWriteReview\":\n                # Attempt to gather latest code and tests deterministically from env.history if available\n                code_text = \"\"\n                tests_text = \"\"\n                try:\n                    env = getattr(self.context, \"env\", None)\n                    if env:\n                        for m in reversed(getattr(env, \"history\", []) or []):\n                            c = getattr(m, \"cause_by\", \"\")\n                            if not tests_text and c == \"SimpleWriteTest\":\n                                tests_text = getattr(m, \"content\", \"\")\n                            if not code_text and c == \"SimpleWriteCode\":\n                                code_text = getattr(m, \"content\", \"\")\n                            if code_text and tests_text:\n                                break\n                except Exception:\n                    code_text = \"\"\n                    tests_text = \"\"\n                # If the incoming message contains one of them, prefer it\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                        code_text = getattr(message, \"content\", \"\") or code_text\n                    if getattr(message, \"cause_by\", \"\") == \"SimpleWriteTest\":\n                        tests_text = getattr(message, \"content\", \"\") or tests_text\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic single-arg invocation\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            self._log(\"ROLE_ERROR\", f\"{action.name} failed: {str(e)}\")\n            result = f\"Action {action.name} encountered an error: {str(e)}\"\n\n        # Construct response message robustly\n        try:\n            response = _make_message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n        except Exception:\n            # Fallback minimal object\n            response = _make_message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n\n        self._log(\"ROLE_COMPLETE\", f\"{action.name} produced message {getattr(response, 'id', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Alice\")\n        profile = kwargs.get('profile', \"SimpleCoder\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder listens to user instructions\n        self._watch([])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Bob\")\n        profile = kwargs.get('profile', \"SimpleTester\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watch for coder outputs\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Charlie\")\n        profile = kwargs.get('profile', \"SimpleReviewer\")\n        context = kwargs.get('context')\n        is_human = kwargs.get('is_human', False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Watch for tester outputs\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        # Ensure role has pointer to environment context for history lookups\n        try:\n            if getattr(role, \"context\", None) is None:\n                role.context = Context()\n            # Provide environment reference inside context if possible (safe assignment)\n            try:\n                role.context.env = self\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment; robustly append and log\"\"\"\n        try:\n            self.history.append(message)\n        except Exception:\n            try:\n                m = _make_message(content=str(getattr(message, \"content\", message)), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {getattr(message, 'sent_from', 'Unknown')}: {str(getattr(message, 'content', ''))[:200]}\")\n            except Exception:\n                pass\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to based on watched cause_by names\"\"\"\n        if not role.watch_list:\n            return []\n        relevant: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                    relevant.append(msg)\n            except Exception:\n                continue\n        return relevant\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # Ensure context has tracer for logging inside actions/roles\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        # Expose env in context for easier lookups by roles/actions\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            try:\n                role.context = self.context\n            except Exception:\n                pass\n            # Add role to environment (which will also attach env reference into context)\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea or \"\"\n        try:\n            self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds with deterministic, low-failure behavior\"\"\"\n        n_round = max(1, int(n_round or 1))\n        try:\n            self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n        \n        # Initial message with the idea\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        # Publish initial message\n        self.env.publish_message(initial_msg)\n        \n        # Deterministic sequential rounds\n        for round_num in range(n_round):\n            try:\n                self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: allow coder to respond to initial instruction if they have a coder action\n                    if round_num == 0 and any(getattr(a, \"name\", \"\") == \"SimpleWriteCode\" for a in role.actions):\n                        response = await role.act(initial_msg)\n                    else:\n                        # For later rounds, use most recent relevant message for the role\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1])\n                        else:\n                            # Skip if nothing relevant\n                            continue\n                except Exception as e:\n                    try:\n                        self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {str(e)}\")\n                    except Exception:\n                        pass\n                    continue\n\n                if response:\n                    # Ensure cause_by is present\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"UnknownAction\"\n                    except Exception:\n                        pass\n                    # Publish response into environment and log\n                    self.env.publish_message(response)\n            \n            try:\n                self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            except Exception:\n                pass\n        \n        try:\n            self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n        \n        # Final summary\n        try:\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"", "language": "python", "parent_id": "067558a3-2c57-4e19-924a-f6cfffaf8e0d", "generation": 2, "timestamp": 1754646916.8162086, "iteration_found": 14, "metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 0.5, "overall_score": 0.25, "combined_score": 0.1, "avg_failures_per_task": 12.0}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert software architect specializing in multi-agent systems.\nRewrite the program inside the EVOLVE-BLOCK to reduce failure modes.\n\nCRITICAL OUTPUT RULES:\n- Output ONLY a single fenced code block labeled \"python\".\n- The block must contain the ENTIRE rewritten file (not just the block).\n- Preserve all imports and non-evolved infrastructure.\n- Keep the EVOLVE-BLOCK-START and EVOLVE-BLOCK-END markers.\n- Do NOT include any text outside the code block.\n", "user": "# Current Program Information\n- Current performance metrics: - runs_successfully: 0.5000\n- overall_score: 0.2500\n- combined_score: 0.1000\n- avg_failures_per_task: 12.0000\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: runs_successfully: 0.5000, overall_score: 0.2500, combined_score: 0.1000, avg_failures_per_task: 12.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 3.2125)\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    def __init__(self, name: str = \"Action\", context: Optional[Context] = None):\n        self.name = name\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLM interface if available in context\"\"\"\n        if self._llm is None and self.context and getattr(self.context, \"config\", None):\n            try:\n                cfg = self.context.config.llm\n                if cfg:\n                    self._llm = LLMInterface(cfg)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a text result\"\"\"\n        raise NotImplementedError\n\n    def _log(self, event: str, details: str):\n        if self.context and getattr(self.context, \"tracer\", None):\n            try:\n                self.context.tracer.log(event, self.name, details)\n            except Exception:\n                # Swallow tracer exceptions to reduce failure modes\n                pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteCode\", context=context)\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea, with robust fallbacks\"\"\"\n        idea = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:100]}\")\n        prompt = (f\"You are a professional programmer. Write concise, correct Python code for the task:\\n\"\n                  f\"{idea}\\n\\n\"\n                  \"Requirements:\\n\"\n                  \"- Clean, testable code\\n\"\n                  \"- Include basic error handling\\n\"\n                  \"- Add short comments\\n\\n\"\n                  \"Return only the code.\")\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                # Deterministic fallback to avoid flakiness\n                result = f\"# Implementation for: {idea}\\n\\n\" \\\n                         \"def solution():\\n\" \\\n                         \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\" \\\n                         \"    try:\\n\" \\\n                         \"        return None\\n\" \\\n                         \"    except Exception as e:\\n\" \\\n                         \"        raise\\n\"\n        except Exception as e:\n            result = f\"# Error generating code: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(result)} characters\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteTest\", context=context)\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate pytest tests for the given code, robustly\"\"\"\n        code_snippet = (code or \"\")[:2000]\n        self._log(\"ACTION_START\", \"Writing tests for provided code\")\n        prompt = (f\"You are a QA engineer. Write pytest tests for the following implementation:\\n\\n\"\n                  f\"{code_snippet}\\n\\n\"\n                  \"Include positive and negative tests. Return only test code.\")\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                # Deterministic fallback stub\n                tests = (\"import pytest\\n\\n\"\n                         \"def test_placeholder():\\n\"\n                         \"    assert True\\n\")\n        except Exception as e:\n            tests = f\"# Error generating tests: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} characters of tests\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteReview\", context=context)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests; supports human simulation\"\"\"\n        code_snippet = (code or \"\")[:1500]\n        tests_snippet = (tests or \"\")[:1500]\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider adding more error handling and edge-case tests.\"\n            else:\n                prompt = (f\"You are a senior reviewer. Review the code and tests below briefly and suggest improvements.\\n\\n\"\n                          f\"Code:\\n{code_snippet}\\n\\nTests:\\n{tests_snippet}\\n\\n\"\n                          \"Be concise and actionable.\")\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Code structure acceptable. Add more tests for edge cases.\"\n        except Exception as e:\n            review = f\"Review error: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Review completed: {len(review)} characters\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = is_human\n        self.actions: List[Action] = []\n        # watch_list contains cause_by strings that this role should respond to\n        self.watch_list: List[str] = []\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform (action instances)\"\"\"\n        self.actions = actions or []\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for using action class or instances\"\"\"\n        names: List[str] = []\n        for a in actions:\n            # Allow both classes and instances\n            try:\n                if isinstance(a, str):\n                    names.append(a)\n                elif hasattr(a, \"name\"):\n                    names.append(a.name)\n                elif hasattr(a, \"__name__\"):\n                    names.append(a.__name__)\n            except Exception:\n                continue\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        if self.context and getattr(self.context, \"tracer\", None):\n            try:\n                self.context.tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    def _select_action_for_message(self, message: Optional[Message]) -> Optional[Action]:\n        \"\"\"Choose the most appropriate action for a message, simple deterministic policy\"\"\"\n        if not self.actions:\n            return None\n        # If message contains instruct_content, prefer actions that accept instruction (SimpleWriteCode)\n        if message and getattr(message, \"instruct_content\", None):\n            for action in self.actions:\n                if action.name == \"SimpleWriteCode\":\n                    return action\n        # Otherwise choose based on watch_list mapping and available actions\n        if message and getattr(message, \"cause_by\", None):\n            cause = message.cause_by\n            for action in self.actions:\n                # Tester watches for coder outputs, reviewer watches for tester outputs\n                if action.name and cause and ((action.name == \"SimpleWriteTest\" and \"SimpleWriteCode\" in (self.watch_list or [])) or (action.name == \"SimpleWriteReview\" and \"SimpleWriteTest\" in (self.watch_list or []))):\n                    # This heuristic is conservative; fall back if nothing matches\n                    return action\n        # Default: return first action\n        return self.actions[0] if self.actions else None\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        self._log(\"ROLE_ACT\", f\"Preparing to act on message: {getattr(message, 'id', 'none')}\")\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions available for role\")\n            return None\n\n        action = self._select_action_for_message(message)\n        if not action:\n            self._log(\"ROLE_SKIP\", \"No suitable action selected\")\n            return None\n\n        try:\n            # Determine inputs for action in a simple, explicit manner\n            if action.name == \"SimpleWriteCode\":\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\")\n                result = await action.run(idea)\n            elif action.name == \"SimpleWriteTest\":\n                code_text = \"\"\n                if message:\n                    # If message is from coder (cause_by == SimpleWriteCode), its content is code\n                    code_text = getattr(message, \"content\", \"\")\n                result = await action.run(code_text)\n            elif action.name == \"SimpleWriteReview\":\n                # Reviewer may need both code and tests; try to extract the latest code and tests from context tracer history if available\n                code_text = \"\"\n                tests_text = \"\"\n                if message:\n                    # If message contains code, assume it's code; otherwise try to find last coder/tester outputs in context history\n                    if getattr(message, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                        code_text = getattr(message, \"content\", \"\")\n                    elif getattr(message, \"cause_by\", \"\") == \"SimpleWriteTest\":\n                        tests_text = getattr(message, \"content\", \"\")\n                # Try to supplement missing pieces from tracer history safely\n                try:\n                    hist = getattr(self.context, \"tracer\", None)\n                    # We avoid parsing the tracer file; keep simple and deterministic\n                except Exception:\n                    pass\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic action invocation\n                result = await action.run(message)\n        except Exception as e:\n            # Ensure failures inside actions do not crash the system; return an error message\n            self._log(\"ROLE_ERROR\", f\"Action {action.name} failed: {str(e)}\")\n            result = f\"Action {action.name} encountered an error: {str(e)}\"\n\n        # Create response message with clear metadata\n        try:\n            response = Message(\n                content=result,\n                role=self.profile,\n                cause_by=action.name,\n                sent_from=self.name\n            )\n        except Exception:\n            # In case pydantic Message signature differs, try fallback construction\n            try:\n                response = Message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n            except Exception:\n                # As last resort, build a minimal object\n                class _M:\n                    pass\n                response = _M()\n                response.content = result\n                response.role = self.profile\n                response.cause_by = action.name\n                response.sent_from = self.name\n\n        self._log(\"ROLE_COMPLETE\", f\"Action {action.name} completed, message {getattr(response, 'id', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Alice\")\n        profile = kwargs.get('profile', \"SimpleCoder\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        # Instantiate action with context now to ensure llm config picked up\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder doesn't need to watch others; it reacts to initial instruction only\n        self._watch([])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Bob\")\n        profile = kwargs.get('profile', \"SimpleTester\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watch for coder outputs by name\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Charlie\")\n        profile = kwargs.get('profile', \"SimpleReviewer\")\n        context = kwargs.get('context')\n        is_human = kwargs.get('is_human', False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Reviewer should watch for tests being produced\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        # Sanitize message to avoid unhashable types in history\n        try:\n            self.history.append(message)\n        except Exception:\n            # Wrap into a minimal message-like dict\n            try:\n                m = Message(content=str(getattr(message, \"content\", message)), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {getattr(message, 'sent_from', 'Unknown')}: {str(getattr(message, 'content', ''))[:100]}\")\n            except Exception:\n                pass\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to based on watched cause_by names\"\"\"\n        relevant_messages: List[Message] = []\n        watched = set(role.watch_list or [])\n        if not watched:\n            return relevant_messages\n        # Return messages whose cause_by matches any watched name, preserving order\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    relevant_messages.append(msg)\n            except Exception:\n                continue\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # Ensure context has tracer for logging inside actions/roles\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            try:\n                role.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea or \"\"\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        n_round = max(1, int(n_round or 1))\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Each role acts in sequence deterministically\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: allow coder to respond to initial instruction\n                    if round_num == 0 and any(a.name == \"SimpleWriteCode\" for a in role.actions):\n                        response = await role.act(initial_msg)\n                    else:\n                        # Other roles respond to relevant messages found by environment\n                        relevant_msgs = self.env.get_messages_for_role(role)\n                        if relevant_msgs:\n                            # Use the most recent relevant message\n                            response = await role.act(relevant_msgs[-1])\n                        else:\n                            # No relevant messages; skip acting to avoid noise\n                            continue\n                except Exception as e:\n                    # Log and continue on role-level exception\n                    try:\n                        self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {str(e)}\")\n                    except Exception:\n                        pass\n                    continue\n                \n                if response:\n                    # Ensure response has cause_by set; fallback to action name if missing\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"UnknownAction\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        try:\n            self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\nKey features: Performs well on runs_successfully (0.5000), Performs well on overall_score (0.2500), Performs well on combined_score (0.1000), Performs well on avg_failures_per_task (12.0000)\n\n\n\n\n# Current Program\n```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\nclass Action(ABC):\n    \"\"\"Base action class\"\"\"\n    def __init__(self, name: str = \"Action\", context: Optional[Context] = None):\n        self.name = name\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLM interface if available in context\"\"\"\n        if self._llm is None and self.context and getattr(self.context, \"config\", None):\n            try:\n                cfg = self.context.config.llm\n                if cfg:\n                    self._llm = LLMInterface(cfg)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a text result\"\"\"\n        raise NotImplementedError\n\n    def _log(self, event: str, details: str):\n        if self.context and getattr(self.context, \"tracer\", None):\n            try:\n                self.context.tracer.log(event, self.name, details)\n            except Exception:\n                # Swallow tracer exceptions to reduce failure modes\n                pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteCode\", context=context)\n\n    async def run(self, idea: str) -> str:\n        \"\"\"Generate code based on the idea, with robust fallbacks\"\"\"\n        idea = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:100]}\")\n        prompt = (f\"You are a professional programmer. Write concise, correct Python code for the task:\\n\"\n                  f\"{idea}\\n\\n\"\n                  \"Requirements:\\n\"\n                  \"- Clean, testable code\\n\"\n                  \"- Include basic error handling\\n\"\n                  \"- Add short comments\\n\\n\"\n                  \"Return only the code.\")\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                result = await self.llm.ask(messages)\n            else:\n                # Deterministic fallback to avoid flakiness\n                result = f\"# Implementation for: {idea}\\n\\n\" \\\n                         \"def solution():\\n\" \\\n                         \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\" \\\n                         \"    try:\\n\" \\\n                         \"        return None\\n\" \\\n                         \"    except Exception as e:\\n\" \\\n                         \"        raise\\n\"\n        except Exception as e:\n            result = f\"# Error generating code: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(result)} characters\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteTest\", context=context)\n\n    async def run(self, code: str) -> str:\n        \"\"\"Generate pytest tests for the given code, robustly\"\"\"\n        code_snippet = (code or \"\")[:2000]\n        self._log(\"ACTION_START\", \"Writing tests for provided code\")\n        prompt = (f\"You are a QA engineer. Write pytest tests for the following implementation:\\n\\n\"\n                  f\"{code_snippet}\\n\\n\"\n                  \"Include positive and negative tests. Return only test code.\")\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                tests = await self.llm.ask(messages)\n            else:\n                # Deterministic fallback stub\n                tests = (\"import pytest\\n\\n\"\n                         \"def test_placeholder():\\n\"\n                         \"    assert True\\n\")\n        except Exception as e:\n            tests = f\"# Error generating tests: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} characters of tests\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteReview\", context=context)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        \"\"\"Review the code and tests; supports human simulation\"\"\"\n        code_snippet = (code or \"\")[:1500]\n        tests_snippet = (tests or \"\")[:1500]\n        self._log(\"ACTION_START\", f\"Reviewing code (human={self.is_human})\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider adding more error handling and edge-case tests.\"\n            else:\n                prompt = (f\"You are a senior reviewer. Review the code and tests below briefly and suggest improvements.\\n\\n\"\n                          f\"Code:\\n{code_snippet}\\n\\nTests:\\n{tests_snippet}\\n\\n\"\n                          \"Be concise and actionable.\")\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    review = await self.llm.ask(messages)\n                else:\n                    review = \"Automated review: Code structure acceptable. Add more tests for edge cases.\"\n        except Exception as e:\n            review = f\"Review error: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Review completed: {len(review)} characters\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = is_human\n        self.actions: List[Action] = []\n        # watch_list contains cause_by strings that this role should respond to\n        self.watch_list: List[str] = []\n\n    def set_actions(self, actions: List[Action]):\n        \"\"\"Set the actions this role can perform (action instances)\"\"\"\n        self.actions = actions or []\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Set the actions this role watches for using action class or instances\"\"\"\n        names: List[str] = []\n        for a in actions:\n            # Allow both classes and instances\n            try:\n                if isinstance(a, str):\n                    names.append(a)\n                elif hasattr(a, \"name\"):\n                    names.append(a.name)\n                elif hasattr(a, \"__name__\"):\n                    names.append(a.__name__)\n            except Exception:\n                continue\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        if self.context and getattr(self.context, \"tracer\", None):\n            try:\n                self.context.tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    def _select_action_for_message(self, message: Optional[Message]) -> Optional[Action]:\n        \"\"\"Choose the most appropriate action for a message, simple deterministic policy\"\"\"\n        if not self.actions:\n            return None\n        # If message contains instruct_content, prefer actions that accept instruction (SimpleWriteCode)\n        if message and getattr(message, \"instruct_content\", None):\n            for action in self.actions:\n                if action.name == \"SimpleWriteCode\":\n                    return action\n        # Otherwise choose based on watch_list mapping and available actions\n        if message and getattr(message, \"cause_by\", None):\n            cause = message.cause_by\n            for action in self.actions:\n                # Tester watches for coder outputs, reviewer watches for tester outputs\n                if action.name and cause and ((action.name == \"SimpleWriteTest\" and \"SimpleWriteCode\" in (self.watch_list or [])) or (action.name == \"SimpleWriteReview\" and \"SimpleWriteTest\" in (self.watch_list or []))):\n                    # This heuristic is conservative; fall back if nothing matches\n                    return action\n        # Default: return first action\n        return self.actions[0] if self.actions else None\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message\"\"\"\n        self._log(\"ROLE_ACT\", f\"Preparing to act on message: {getattr(message, 'id', 'none')}\")\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions available for role\")\n            return None\n\n        action = self._select_action_for_message(message)\n        if not action:\n            self._log(\"ROLE_SKIP\", \"No suitable action selected\")\n            return None\n\n        try:\n            # Determine inputs for action in a simple, explicit manner\n            if action.name == \"SimpleWriteCode\":\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\")\n                result = await action.run(idea)\n            elif action.name == \"SimpleWriteTest\":\n                code_text = \"\"\n                if message:\n                    # If message is from coder (cause_by == SimpleWriteCode), its content is code\n                    code_text = getattr(message, \"content\", \"\")\n                result = await action.run(code_text)\n            elif action.name == \"SimpleWriteReview\":\n                # Reviewer may need both code and tests; try to extract the latest code and tests from context tracer history if available\n                code_text = \"\"\n                tests_text = \"\"\n                if message:\n                    # If message contains code, assume it's code; otherwise try to find last coder/tester outputs in context history\n                    if getattr(message, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                        code_text = getattr(message, \"content\", \"\")\n                    elif getattr(message, \"cause_by\", \"\") == \"SimpleWriteTest\":\n                        tests_text = getattr(message, \"content\", \"\")\n                # Try to supplement missing pieces from tracer history safely\n                try:\n                    hist = getattr(self.context, \"tracer\", None)\n                    # We avoid parsing the tracer file; keep simple and deterministic\n                except Exception:\n                    pass\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic action invocation\n                result = await action.run(message)\n        except Exception as e:\n            # Ensure failures inside actions do not crash the system; return an error message\n            self._log(\"ROLE_ERROR\", f\"Action {action.name} failed: {str(e)}\")\n            result = f\"Action {action.name} encountered an error: {str(e)}\"\n\n        # Create response message with clear metadata\n        try:\n            response = Message(\n                content=result,\n                role=self.profile,\n                cause_by=action.name,\n                sent_from=self.name\n            )\n        except Exception:\n            # In case pydantic Message signature differs, try fallback construction\n            try:\n                response = Message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n            except Exception:\n                # As last resort, build a minimal object\n                class _M:\n                    pass\n                response = _M()\n                response.content = result\n                response.role = self.profile\n                response.cause_by = action.name\n                response.sent_from = self.name\n\n        self._log(\"ROLE_COMPLETE\", f\"Action {action.name} completed, message {getattr(response, 'id', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Alice\")\n        profile = kwargs.get('profile', \"SimpleCoder\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        # Instantiate action with context now to ensure llm config picked up\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder doesn't need to watch others; it reacts to initial instruction only\n        self._watch([])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Bob\")\n        profile = kwargs.get('profile', \"SimpleTester\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watch for coder outputs by name\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Charlie\")\n        profile = kwargs.get('profile', \"SimpleReviewer\")\n        context = kwargs.get('context')\n        is_human = kwargs.get('is_human', False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Reviewer should watch for tests being produced\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        self.roles.append(role)\n        if self.tracer:\n            self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment\"\"\"\n        # Sanitize message to avoid unhashable types in history\n        try:\n            self.history.append(message)\n        except Exception:\n            # Wrap into a minimal message-like dict\n            try:\n                m = Message(content=str(getattr(message, \"content\", message)), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {getattr(message, 'sent_from', 'Unknown')}: {str(getattr(message, 'content', ''))[:100]}\")\n            except Exception:\n                pass\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to based on watched cause_by names\"\"\"\n        relevant_messages: List[Message] = []\n        watched = set(role.watch_list or [])\n        if not watched:\n            return relevant_messages\n        # Return messages whose cause_by matches any watched name, preserving order\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in watched:\n                    relevant_messages.append(msg)\n            except Exception:\n                continue\n        return relevant_messages\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # Ensure context has tracer for logging inside actions/roles\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            try:\n                role.context = self.context\n            except Exception:\n                pass\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea or \"\"\n        self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds\"\"\"\n        n_round = max(1, int(n_round or 1))\n        self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        \n        # Initial message with the idea\n        initial_msg = Message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        self.env.publish_message(initial_msg)\n        \n        for round_num in range(n_round):\n            self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            \n            # Each role acts in sequence deterministically\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: allow coder to respond to initial instruction\n                    if round_num == 0 and any(a.name == \"SimpleWriteCode\" for a in role.actions):\n                        response = await role.act(initial_msg)\n                    else:\n                        # Other roles respond to relevant messages found by environment\n                        relevant_msgs = self.env.get_messages_for_role(role)\n                        if relevant_msgs:\n                            # Use the most recent relevant message\n                            response = await role.act(relevant_msgs[-1])\n                        else:\n                            # No relevant messages; skip acting to avoid noise\n                            continue\n                except Exception as e:\n                    # Log and continue on role-level exception\n                    try:\n                        self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {str(e)}\")\n                    except Exception:\n                        pass\n                    continue\n                \n                if response:\n                    # Ensure response has cause_by set; fallback to action name if missing\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"UnknownAction\"\n                    except Exception:\n                        pass\n                    self.env.publish_message(response)\n            \n            self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n        \n        self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        \n        # Final summary\n        summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n        try:\n            self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nInitial multi-agent system for evolution.\nThis contains the core multi-agent logic that will be evolved to minimize failure modes.\n\"\"\"\n\nimport os\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Set, Type\n\ntry:\n    import aiohttp\nexcept ImportError:\n    aiohttp = None\n\ntry:\n    from pydantic import BaseModel, Field\nexcept ImportError:\n    BaseModel = None\n    Field = None\n\n# ============== Fixed Infrastructure (Not Evolved) ==============\n\nclass ExecutionTracer:\n    \"\"\"Comprehensive execution tracer for multi-agent interactions\"\"\"\n    \n    def __init__(self, log_file: Optional[str] = None):\n        self.log_file = log_file\n        self.trace_id = 0\n        \n        if self.log_file:\n            # Clear the log file at the start\n            with open(self.log_file, 'w') as f:\n                f.write(f\"Execution Trace Started: {datetime.now()}\\n\")\n                f.write(\"=\"*80 + \"\\n\")\n    \n    def log(self, event_type: str, agent: str, details: str):\n        \"\"\"Log an event to the trace file\"\"\"\n        self.trace_id += 1\n        timestamp = datetime.now().strftime(\"%H:%M:%S.%f\")[:-3]\n        log_entry = f\"[{self.trace_id:04d}] [{timestamp}] [{event_type}] [{agent}] {details}\\n\"\n        \n        if self.log_file:\n            with open(self.log_file, 'a') as f:\n                f.write(log_entry)\n        \n        return log_entry\n\nclass LLMType(Enum):\n    \"\"\"LLM types\"\"\"\n    OPENAI = \"openai\"\n    QWEN = \"qwen\"\n    CODELLAMA = \"codellama\"\n\nclass LLMConfig:\n    \"\"\"LLM configuration\"\"\"\n    def __init__(self):\n        self.api_type = LLMType.OPENAI\n        self.model = \"gpt-4o\"\n        self.api_key = None\n        self.base_url = \"https://api.openai.com/v1\"\n        self.proxy = \"\"\n        self.temperature = 0.7\n        self.max_token = 2048\n\nclass Config:\n    \"\"\"Configuration object\"\"\"\n    def __init__(self):\n        self.llm = LLMConfig()\n\nif BaseModel:\n    class Context(BaseModel):\n        \"\"\"Context object that holds configuration and shared state\"\"\"\n        config: Config = Field(default_factory=Config)\n        cost_manager: Optional[Any] = None\n        tracer: Optional[Any] = None\n        \n        class Config:\n            arbitrary_types_allowed = True\n    \n    class Message(BaseModel):\n        \"\"\"Message object for agent communication\"\"\"\n        id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n        content: str\n        instruct_content: Optional[str] = None\n        role: str\n        cause_by: str = \"\"\n        sent_from: Optional[str] = None\n        sent_to: Optional[str] = None\n        send_to: Set[str] = Field(default_factory=set)\n        \n        def __str__(self):\n            return f\"Message(role={self.role}, content={self.content[:50]}...)\"\nelse:\n    # Fallback classes if pydantic is not available\n    class Context:\n        def __init__(self):\n            self.config = Config()\n            self.cost_manager = None\n            self.tracer = None\n    \n    class Message:\n        def __init__(self, content, role, **kwargs):\n            self.id = str(uuid.uuid4())\n            self.content = content\n            self.instruct_content = kwargs.get('instruct_content')\n            self.role = role\n            self.cause_by = kwargs.get('cause_by', '')\n            self.sent_from = kwargs.get('sent_from')\n            self.sent_to = kwargs.get('sent_to')\n            self.send_to = kwargs.get('send_to', set())\n\nclass LLMInterface:\n    \"\"\"Interface for LLM communication\"\"\"\n    def __init__(self, config: LLMConfig):\n        self.config = config\n        self.api_key = config.api_key or os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n        self.base_url = config.base_url\n    \n    async def ask(self, messages: List[Dict[str, str]]) -> str:\n        \"\"\"Send messages to LLM and get response\"\"\"\n        if not aiohttp:\n            # Fallback for testing without actual API calls\n            return \"I'll help you with that task. Let me write the code for you.\"\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # data = {\n        #     \"model\": self.config.model,\n        #     \"messages\": messages,\n        #     \"temperature\": self.config.temperature,\n        #     \"max_tokens\": self.config.max_token\n        # }\n        data = {\n            \"model\": self.config.model,\n            \"messages\": messages,\n            \"temperature\": self.config.temperature        \n            }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/chat/completions\",\n                    headers=headers,\n                    json=data,\n                    timeout=aiohttp.ClientTimeout(total=60)\n                ) as response:\n                    if response.status == 200:\n                        result = await response.json()\n                        return result[\"choices\"][0][\"message\"][\"content\"]\n                    else:\n                        error_text = await response.text()\n                        return f\"Error: {response.status} - {error_text[:200]}\"\n        except Exception as e:\n            return f\"Error communicating with LLM: {str(e)}\"\n\n# EVOLVE-BLOCK-START\n# This section contains the multi-agent system logic that will be evolved\n\ndef _make_message(content: str, role: str, cause_by: str = \"\", sent_from: Optional[str] = None, instruct_content: Optional[str] = None):\n    \"\"\"\n    Robust helper to construct Message objects compatible with both pydantic and fallback Message.\n    Returns either a Message instance or a minimal object with expected attributes.\n    \"\"\"\n    try:\n        # Try constructing pydantic Message (or the fallback class) with full fields\n        return Message(content=content, role=role, cause_by=cause_by or \"\", sent_from=sent_from, instruct_content=instruct_content)\n    except Exception:\n        # Last-resort minimal object\n        class _M:\n            pass\n        m = _M()\n        m.id = str(uuid.uuid4())\n        m.content = content\n        m.instruct_content = instruct_content\n        m.role = role\n        m.cause_by = cause_by or \"\"\n        m.sent_from = sent_from\n        m.sent_to = None\n        m.send_to = set()\n        return m\n\nclass Action(ABC):\n    \"\"\"Base action class with simplified, robust LLM access\"\"\"\n    def __init__(self, name: str = \"Action\", context: Optional[Context] = None):\n        self.name = name\n        self.context = context\n        self._llm: Optional[LLMInterface] = None\n\n    @property\n    def llm(self) -> Optional[LLMInterface]:\n        \"\"\"Lazily create LLM interface if available in context; safe and idempotent\"\"\"\n        if self._llm is None:\n            try:\n                cfg = getattr(self.context, \"config\", None)\n                if cfg and getattr(cfg, \"llm\", None):\n                    self._llm = LLMInterface(cfg.llm)\n            except Exception:\n                self._llm = None\n        return self._llm\n\n    @abstractmethod\n    async def run(self, *args, **kwargs) -> str:\n        \"\"\"Run the action and return a text result\"\"\"\n        raise NotImplementedError\n\n    def _log(self, event: str, details: str):\n        \"\"\"Safe logging helper\"\"\"\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                # Swallow tracer exceptions to reduce failure modes\n                pass\n\nclass SimpleWriteCode(Action):\n    \"\"\"Action to write code based on requirements\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteCode\", context=context)\n\n    async def run(self, idea: str) -> str:\n        idea = (idea or \"\").strip()\n        self._log(\"ACTION_START\", f\"Writing code for: {idea[:120]}\")\n        prompt = (\n            \"You are an expert Python programmer. Produce concise, correct Python code that fulfills the request.\\n\\n\"\n            f\"Task:\\n{idea}\\n\\nRequirements:\\n- Clean, testable code\\n- Basic error handling\\n- Short comments\\nReturn only the code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert Python programmer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                result = resp or \"\"\n            else:\n                # Stable deterministic fallback\n                result = (\n                    f\"# Implementation for: {idea}\\n\\n\"\n                    \"def solution():\\n\"\n                    \"    \\\"\\\"\\\"Placeholder solution.\\\"\\\"\\\"\\n\"\n                    \"    try:\\n\"\n                    \"        return None\\n\"\n                    \"    except Exception:\\n\"\n                    \"        raise\\n\"\n                )\n        except Exception as e:\n            result = f\"# Error generating code: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(result)} chars\")\n        return result\n\nclass SimpleWriteTest(Action):\n    \"\"\"Action to write tests for code\"\"\"\n    def __init__(self, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteTest\", context=context)\n\n    async def run(self, code: str) -> str:\n        code_snippet = (code or \"\")[:2000]\n        self._log(\"ACTION_START\", \"Writing tests\")\n        prompt = (\n            \"You are an expert QA engineer. Given the implementation, write pytest tests (positive and negative).\\n\\n\"\n            f\"Code:\\n{code_snippet}\\n\\nReturn only test code.\"\n        )\n        messages = [\n            {\"role\": \"system\", \"content\": \"You are an expert QA engineer.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        try:\n            if self.llm:\n                resp = await self.llm.ask(messages)\n                tests = resp or \"\"\n            else:\n                tests = \"import pytest\\n\\ndef test_placeholder():\\n    assert True\\n\"\n        except Exception as e:\n            tests = f\"# Error generating tests: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Generated {len(tests)} chars\")\n        return tests\n\nclass SimpleWriteReview(Action):\n    \"\"\"Action to review code and tests\"\"\"\n    def __init__(self, is_human: bool = False, context: Optional[Context] = None):\n        super().__init__(name=\"SimpleWriteReview\", context=context)\n        self.is_human = is_human\n\n    async def run(self, code: str, tests: str) -> str:\n        code_snippet = (code or \"\")[:1500]\n        tests_snippet = (tests or \"\")[:1500]\n        self._log(\"ACTION_START\", \"Reviewing\")\n        try:\n            if self.is_human:\n                review = \"Human review: Looks reasonable. Consider adding more edge-case tests and clearer error messages.\"\n            else:\n                prompt = (\n                    \"You are a senior engineer. Provide a concise review and actionable suggestions for improvements.\\n\\n\"\n                    f\"Code:\\n{code_snippet}\\n\\nTests:\\n{tests_snippet}\\n\\nBe concise.\"\n                )\n                messages = [\n                    {\"role\": \"system\", \"content\": \"You are a senior software engineer doing code review.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ]\n                if self.llm:\n                    resp = await self.llm.ask(messages)\n                    review = resp or \"Automated review: Acceptable structure; consider more tests.\"\n                else:\n                    review = \"Automated review: Acceptable structure; consider more tests and edge cases.\"\n        except Exception as e:\n            review = f\"Review error: {str(e)}\"\n        self._log(\"ACTION_END\", f\"Review length {len(review)}\")\n        return review\n\nclass Role(ABC):\n    \"\"\"Base role class for agents - simplified decision logic and robust behavior\"\"\"\n    def __init__(self, name: str = \"Role\", profile: str = \"Default\", context: Optional[Context] = None, is_human: bool = False):\n        self.name = name\n        self.profile = profile\n        self.context = context\n        self.is_human = is_human\n        self.actions: List[Action] = []\n        # watch_list contains cause_by strings that this role should respond to\n        self.watch_list: Set[str] = set()\n\n    def set_actions(self, actions: List[Action]):\n        self.actions = actions or []\n\n    def _watch(self, actions: List[Type[Action]]):\n        \"\"\"Normalize watched action identifiers into string names (robust)\"\"\"\n        names: Set[str] = set()\n        for a in (actions or []):\n            try:\n                if isinstance(a, str):\n                    names.add(a)\n                elif hasattr(a, \"name\"):\n                    # instance or class with 'name' attribute\n                    names.add(getattr(a, \"name\"))\n                elif hasattr(a, \"__name__\"):\n                    names.add(getattr(a, \"__name__\"))\n            except Exception:\n                continue\n        self.watch_list = names\n\n    def _log(self, event: str, details: str):\n        tracer = getattr(self.context, \"tracer\", None)\n        if tracer:\n            try:\n                tracer.log(event, self.name, details)\n            except Exception:\n                pass\n\n    def _select_action_for_message(self, message: Optional[Message]) -> Optional[Action]:\n        \"\"\"\n        Deterministic selection:\n        - If message has instruct_content -> prefer SimpleWriteCode\n        - Else choose action based on watch_list mapping: if the message.cause_by is in this role's watch_list,\n          then map that cause to the most appropriate action by known mapping.\n        - Else default to first action.\n        \"\"\"\n        if not self.actions:\n            return None\n\n        # Prefer explicit instruction to coder\n        if message and getattr(message, \"instruct_content\", None):\n            for action in self.actions:\n                if action.name == \"SimpleWriteCode\":\n                    return action\n\n        cause = getattr(message, \"cause_by\", \"\") if message else \"\"\n        if cause and cause in (self.watch_list or set()):\n            # Simple mapping: when coder output -> tester, when tester output -> reviewer\n            if cause == \"SimpleWriteCode\":\n                for action in self.actions:\n                    if action.name == \"SimpleWriteTest\":\n                        return action\n            if cause == \"SimpleWriteTest\":\n                for action in self.actions:\n                    if action.name == \"SimpleWriteReview\":\n                        return action\n\n        # Default fallback\n        return self.actions[0] if self.actions else None\n\n    async def act(self, message: Optional[Message] = None) -> Optional[Message]:\n        \"\"\"Perform an action based on the message; always returns a Message-like object or None\"\"\"\n        self._log(\"ROLE_ACT\", f\"Acting on message {getattr(message, 'id', 'none')}\")\n        if not self.actions:\n            self._log(\"ROLE_SKIP\", \"No actions\")\n            return None\n\n        action = self._select_action_for_message(message)\n        if not action:\n            self._log(\"ROLE_SKIP\", \"No action selected\")\n            return None\n\n        try:\n            # Prepare inputs based on action type (explicit and simple)\n            if action.name == \"SimpleWriteCode\":\n                idea = \"\"\n                if message:\n                    idea = getattr(message, \"instruct_content\", None) or getattr(message, \"content\", \"\")\n                result = await action.run(idea)\n            elif action.name == \"SimpleWriteTest\":\n                code_text = \"\"\n                if message and getattr(message, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                    code_text = getattr(message, \"content\", \"\")\n                else:\n                    # Try to find last code from environment history\n                    code_text = \"\"\n                    try:\n                        hist = getattr(self.context, \"tracer\", None)\n                        # Avoid parsing tracer; rely on environment history if available\n                        env = getattr(self.context, \"env\", None)\n                        if env:\n                            for m in reversed(getattr(env, \"history\", []) or []):\n                                if getattr(m, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                                    code_text = getattr(m, \"content\", \"\")\n                                    break\n                    except Exception:\n                        code_text = \"\"\n                result = await action.run(code_text)\n            elif action.name == \"SimpleWriteReview\":\n                # Attempt to gather latest code and tests deterministically from env.history if available\n                code_text = \"\"\n                tests_text = \"\"\n                try:\n                    env = getattr(self.context, \"env\", None)\n                    if env:\n                        for m in reversed(getattr(env, \"history\", []) or []):\n                            c = getattr(m, \"cause_by\", \"\")\n                            if not tests_text and c == \"SimpleWriteTest\":\n                                tests_text = getattr(m, \"content\", \"\")\n                            if not code_text and c == \"SimpleWriteCode\":\n                                code_text = getattr(m, \"content\", \"\")\n                            if code_text and tests_text:\n                                break\n                except Exception:\n                    code_text = \"\"\n                    tests_text = \"\"\n                # If the incoming message contains one of them, prefer it\n                if message:\n                    if getattr(message, \"cause_by\", \"\") == \"SimpleWriteCode\":\n                        code_text = getattr(message, \"content\", \"\") or code_text\n                    if getattr(message, \"cause_by\", \"\") == \"SimpleWriteTest\":\n                        tests_text = getattr(message, \"content\", \"\") or tests_text\n                result = await action.run(code_text, tests_text)\n            else:\n                # Generic single-arg invocation\n                result = await action.run(getattr(message, \"content\", \"\") if message else \"\")\n        except Exception as e:\n            self._log(\"ROLE_ERROR\", f\"{action.name} failed: {str(e)}\")\n            result = f\"Action {action.name} encountered an error: {str(e)}\"\n\n        # Construct response message robustly\n        try:\n            response = _make_message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n        except Exception:\n            # Fallback minimal object\n            response = _make_message(content=result, role=self.profile, cause_by=action.name, sent_from=self.name)\n\n        self._log(\"ROLE_COMPLETE\", f\"{action.name} produced message {getattr(response, 'id', '')}\")\n        return response\n\nclass SimpleCoder(Role):\n    \"\"\"Role that writes code\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Alice\")\n        profile = kwargs.get('profile', \"SimpleCoder\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteCode(context=self.context)])\n        # Coder listens to user instructions\n        self._watch([])\n\nclass SimpleTester(Role):\n    \"\"\"Role that writes tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Bob\")\n        profile = kwargs.get('profile', \"SimpleTester\")\n        context = kwargs.get('context')\n        super().__init__(name=name, profile=profile, context=context, is_human=kwargs.get('is_human', False))\n        self.set_actions([SimpleWriteTest(context=self.context)])\n        # Watch for coder outputs\n        self._watch([SimpleWriteCode])\n\nclass SimpleReviewer(Role):\n    \"\"\"Role that reviews code and tests\"\"\"\n    def __init__(self, **kwargs):\n        name = kwargs.get('name', \"Charlie\")\n        profile = kwargs.get('profile', \"SimpleReviewer\")\n        context = kwargs.get('context')\n        is_human = kwargs.get('is_human', False)\n        super().__init__(name=name, profile=profile, context=context, is_human=is_human)\n        self.set_actions([SimpleWriteReview(is_human=self.is_human, context=self.context)])\n        # Watch for tester outputs\n        self._watch([SimpleWriteTest])\n\nclass Environment:\n    \"\"\"Environment for multi-agent collaboration\"\"\"\n    def __init__(self, tracer: Optional[ExecutionTracer] = None):\n        self.roles: List[Role] = []\n        self.history: List[Message] = []\n        self.tracer = tracer\n    \n    def add_role(self, role: Role):\n        \"\"\"Add a role to the environment\"\"\"\n        # Ensure role has pointer to environment context for history lookups\n        try:\n            if getattr(role, \"context\", None) is None:\n                role.context = Context()\n            # Provide environment reference inside context if possible (safe assignment)\n            try:\n                role.context.env = self\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n        self.roles.append(role)\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_ADD_ROLE\", \"Environment\", f\"Added role: {role.name} ({role.profile})\")\n            except Exception:\n                pass\n    \n    def get_roles(self, profile: Optional[str] = None) -> List[Role]:\n        \"\"\"Get roles by profile\"\"\"\n        if profile:\n            return [r for r in self.roles if r.profile == profile]\n        return self.roles\n    \n    def publish_message(self, message: Message):\n        \"\"\"Publish a message to the environment; robustly append and log\"\"\"\n        try:\n            self.history.append(message)\n        except Exception:\n            try:\n                m = _make_message(content=str(getattr(message, \"content\", message)), role=getattr(message, \"role\", \"Unknown\"), cause_by=getattr(message, \"cause_by\", \"\"))\n                self.history.append(m)\n                message = m\n            except Exception:\n                return\n        if self.tracer:\n            try:\n                self.tracer.log(\"ENV_MESSAGE\", \"Environment\", f\"Message from {getattr(message, 'sent_from', 'Unknown')}: {str(getattr(message, 'content', ''))[:200]}\")\n            except Exception:\n                pass\n    \n    def get_messages_for_role(self, role: Role) -> List[Message]:\n        \"\"\"Get messages that a role should respond to based on watched cause_by names\"\"\"\n        if not role.watch_list:\n            return []\n        relevant: List[Message] = []\n        for msg in self.history:\n            try:\n                if getattr(msg, \"cause_by\", \"\") in role.watch_list:\n                    relevant.append(msg)\n            except Exception:\n                continue\n        return relevant\n\nclass Team:\n    \"\"\"Team of agents working together\"\"\"\n    def __init__(self, context: Optional[Context] = None, log_file: Optional[str] = None):\n        self.context = context or Context()\n        self.tracer = ExecutionTracer(log_file)\n        # Ensure context has tracer for logging inside actions/roles\n        try:\n            self.context.tracer = self.tracer\n        except Exception:\n            pass\n        self.env = Environment(self.tracer)\n        # Expose env in context for easier lookups by roles/actions\n        try:\n            self.context.env = self.env\n        except Exception:\n            pass\n        self.investment: float = 10.0\n        self.idea: str = \"\"\n        self.log_file = log_file\n    \n    def hire(self, roles: List[Role]):\n        \"\"\"Hire roles into the team\"\"\"\n        for role in roles:\n            try:\n                role.context = self.context\n            except Exception:\n                pass\n            # Add role to environment (which will also attach env reference into context)\n            self.env.add_role(role)\n    \n    def invest(self, investment: float):\n        \"\"\"Set investment/budget\"\"\"\n        self.investment = investment\n    \n    def run_project(self, idea: str):\n        \"\"\"Set the project idea\"\"\"\n        self.idea = idea or \"\"\n        try:\n            self.tracer.log(\"TEAM_START\", \"Team\", f\"Starting project: {self.idea}\")\n        except Exception:\n            pass\n    \n    async def run(self, n_round: int = 3):\n        \"\"\"Run the team collaboration for n rounds with deterministic, low-failure behavior\"\"\"\n        n_round = max(1, int(n_round or 1))\n        try:\n            self.tracer.log(\"TEAM_RUN\", \"Team\", f\"Running {n_round} rounds\")\n        except Exception:\n            pass\n        \n        # Initial message with the idea\n        initial_msg = _make_message(\n            content=f\"Let's work on this project: {self.idea}\",\n            instruct_content=self.idea,\n            role=\"Human\",\n            sent_from=\"User\",\n            cause_by=\"UserInput\"\n        )\n        # Publish initial message\n        self.env.publish_message(initial_msg)\n        \n        # Deterministic sequential rounds\n        for round_num in range(n_round):\n            try:\n                self.tracer.log(\"ROUND_START\", \"Team\", f\"Round {round_num + 1}/{n_round}\")\n            except Exception:\n                pass\n\n            for role in list(self.env.roles):\n                response = None\n                try:\n                    # First round: allow coder to respond to initial instruction if they have a coder action\n                    if round_num == 0 and any(getattr(a, \"name\", \"\") == \"SimpleWriteCode\" for a in role.actions):\n                        response = await role.act(initial_msg)\n                    else:\n                        # For later rounds, use most recent relevant message for the role\n                        relevant = self.env.get_messages_for_role(role)\n                        if relevant:\n                            response = await role.act(relevant[-1])\n                        else:\n                            # Skip if nothing relevant\n                            continue\n                except Exception as e:\n                    try:\n                        self.tracer.log(\"ROLE_RUN_ERROR\", role.name, f\"Error during act: {str(e)}\")\n                    except Exception:\n                        pass\n                    continue\n\n                if response:\n                    # Ensure cause_by is present\n                    try:\n                        if not getattr(response, \"cause_by\", None):\n                            response.cause_by = getattr(response, \"cause_by\", \"\") or \"UnknownAction\"\n                    except Exception:\n                        pass\n                    # Publish response into environment and log\n                    self.env.publish_message(response)\n            \n            try:\n                self.tracer.log(\"ROUND_END\", \"Team\", f\"Round {round_num + 1} completed\")\n            except Exception:\n                pass\n        \n        try:\n            self.tracer.log(\"TEAM_END\", \"Team\", \"Project completed\")\n        except Exception:\n            pass\n        \n        # Final summary\n        try:\n            summary = f\"Project '{self.idea}' completed after {n_round} rounds with {len(self.env.history)} messages exchanged.\"\n            self.tracer.log(\"SUMMARY\", \"Team\", summary)\n        except Exception:\n            pass\n\n# EVOLVE-BLOCK-END\n\n# Fixed main execution function (not evolved)\nasync def run_multi_agent_task(idea: str, n_rounds: int = 3, log_file: str = None):\n    \"\"\"Run a multi-agent task and return the trace\"\"\"\n    # Create context\n    context = Context()\n    context.config.llm.api_key = os.getenv(\"OPENAI_API_KEY\", \"fake-key\")\n    \n    # Create team\n    team = Team(context=context, log_file=log_file)\n    team.hire([\n        SimpleCoder(context=context),\n        SimpleTester(context=context),\n        SimpleReviewer(context=context)\n    ])\n    \n    team.invest(investment=3.0)\n    team.run_project(idea)\n    await team.run(n_round=n_rounds)\n    \n    # Return the trace content\n    if log_file and os.path.exists(log_file):\n        with open(log_file, 'r') as f:\n            return f.read()\n    return \"\"\n```"]}}}